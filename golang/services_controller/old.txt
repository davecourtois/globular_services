
func (admin_server *server) stopService(s *sync.Map) error {

	// Set keep alive to false...
	s.Store("State", "terminated")
	admin_server.setService(s) // set in the map...

	_, hasProcessPid := s.Load("Process")
	if !hasProcessPid {
		s.Store("Process", -1)
	}

	pid := getIntVal(s, "Process")
	if pid != -1 {
		log.Println("stop service ", getStringVal(s, "Name"), "pid:", pid)
		if runtime.GOOS == "windows" {
			// Program written with dotnet on window need this command to stop...
			kill := exec.Command("TASKKILL", "/T", "/F", "/PID", strconv.Itoa(pid))
			kill.Stderr = os.Stderr
			kill.Stdout = os.Stdout
			kill.Run()
		} else {
			err := Utility.TerminateProcess(pid, 0)
			if err != nil {
				log.Println("fail to teminate process ", pid)
			}
		}
	}

	_, hasProxyProcessPid := s.Load("ProxyProcess")
	if !hasProxyProcessPid {
		s.Store("ProxyProcess", -1)
	}
	pid = getIntVal(s, "ProxyProcess")
	if pid != -1 {
		err := Utility.TerminateProcess(pid, 0)
		if err != nil {
			log.Println("fail to teminate proxy process ", pid)
		}
	}

	s.Store("Process", -1)
	s.Store("ProxyProcess", -1)
	s.Store("State", "stopped")

	// set the service back in the map.
	admin_server.setService(s)

	config := make(map[string]interface{}, 0)
	s.Range(func(k, v interface{}) bool {
		config[k.(string)] = v
		return true
	})

	// sync the data/config file with the service file.
	jsonStr, _ := Utility.ToJson(config)

	// here I will write the file
	configPath := admin_server.getServiceConfigPath(s)
	if len(configPath) > 0 {
		log.Println("save configuration at ", configPath)
		err := ioutil.WriteFile(configPath, []byte(jsonStr), 0644)
		if err != nil {
			return err
		}
	}

	// admin_server.logServiceInfo(getStringVal(s, "Name"), time.Now().String()+"Service "+getStringVal(s, "Name")+" was stopped!")

	return nil
}

// Stop a service
func (admin_server *server) StopService(ctx context.Context, rqst *adminpb.StopServiceRequest) (*adminpb.StopServiceResponse, error) {

	s := admin_server.getService(rqst.ServiceId)
	if s != nil {
		err := admin_server.stopService(s)
		if err != nil {
			return nil, status.Errorf(
				codes.Internal,
				Utility.JsonErrorStr(Utility.FunctionName(), Utility.FileLine(), err))
		}
	} else {
		// Close all services with a given name.
		services := admin_server.getServiceConfigByName(rqst.ServiceId)
		for i := 0; i < len(services); i++ {
			serviceId := services[i]["Id"].(string)
			s := admin_server.getService(serviceId)
			if s == nil {
				return nil, status.Errorf(
					codes.Internal,
					Utility.JsonErrorStr(Utility.FunctionName(), Utility.FileLine(), errors.New("No service found with id "+serviceId)))
			}
			err := admin_server.stopService(s)
			if err != nil {
				return nil, status.Errorf(
					codes.Internal,
					Utility.JsonErrorStr(Utility.FunctionName(), Utility.FileLine(), err))
			}
		}
	}

	return &adminpb.StopServiceResponse{
		Result: true,
	}, nil

}

// Start a service
func (admin_server *server) StartService(ctx context.Context, rqst *adminpb.StartServiceRequest) (*adminpb.StartServiceResponse, error) {

	s := admin_server.getService(rqst.ServiceId)
	proxy_pid := int64(-1)
	service_pid := int64(-1)

	if s == nil {
		services := admin_server.getServiceConfigByName(rqst.ServiceId)
		for i := 0; i < len(services); i++ {
			id := services[i]["Id"].(string)
			s := admin_server.getService(id)
			service_pid_, proxy_pid_, err := admin_server.startService(s)
			if err != nil {
				return nil, status.Errorf(
					codes.Internal,
					Utility.JsonErrorStr(Utility.FunctionName(), Utility.FileLine(), err))
			}
			proxy_pid = int64(proxy_pid_)
			service_pid = int64(service_pid_)
		}
	} else {
		service_pid_, proxy_pid_, err := admin_server.startService(s)
		if err != nil {
			return nil, status.Errorf(
				codes.Internal,
				Utility.JsonErrorStr(Utility.FunctionName(), Utility.FileLine(), err))
		}
		proxy_pid = int64(proxy_pid_)
		service_pid = int64(service_pid_)
	}

	return &adminpb.StartServiceResponse{
		ProxyPid:   proxy_pid,
		ServicePid: service_pid,
	}, nil
}

// Restart all Services also the http(s)
func (admin_server *server) RestartServices(ctx context.Context, rqst *adminpb.RestartServicesRequest) (*adminpb.RestartServicesResponse, error) {
	log.Println("restart service... ")
	admin_server.restartServices()

	return &adminpb.RestartServicesResponse{}, nil
}

func (admin_server *server) restartServices() {
	if admin_server.exit_ {
		return // already restarting I will ingnore the call.
	}

	// Stop all external services.
	admin_server.stopServices()
}


// uninstall service
func (admin_server *server) uninstallService(publisherId string, serviceId string, version string, deletePermissions bool) error {
	p, err := admin_server.getPersistenceStore()
	if err != nil {
		return err
	}

	log.Println("Uninstalling services ", publisherId, serviceId, "...")
	// First of all I will stop the running service(s) instance.
	for _, s := range admin_server.getServices() {
		// Stop the instance of the service.
		id, ok := s.Load("Id")
		if ok {
			name := getStringVal(s, "Name")
			if getStringVal(s, "PublisherId") == publisherId && id == serviceId && getStringVal(s, "Version") == version {
				// First of all I will unsubcribe to the package event...
				event_channel_id := getStringVal(s, "PublisherId") + ":" + getStringVal(s, "Id") + ":SERVICE_PUBLISH_EVENT"
				discoveries := getVal(s, "Discoveries")
				if discoveries != nil {
					for i := 0; i < len(discoveries.([]interface{})); i++ {
						discovery := discoveries.([]interface{})[i].(string)
						eventHub := admin_server.discorveriesEventHub[discovery]
						if eventHub != nil {
							pid := getIntVal(s, "Process")
							if pid != -1 {
								uuid := Utility.GenerateUUID(getStringVal(s, "Id") + Utility.ToString(pid))
								log.Println("Unsbuscribe to event channel ", event_channel_id, " whit listener uuid ", uuid)
								eventHub.UnSubscribe(event_channel_id, uuid)
							}

						}
					}
				}

				time.Sleep(time.Second * 5) // WAIT FOR LISTENERS TO DISCONNECT...
				log.Println("stop service ", name)
				admin_server.stopService(s)

				log.Println("delete service ", name)
				admin_server.deleteService(id.(string))

				// Get the list of method to remove from the list of actions.
				toDelete := admin_server.getServiceMethods(name, getStringVal(s, "Proto"))
				methods := make([]string, 0)
				for i := 0; i < len(admin_server.methods); i++ {
					if !Utility.Contains(toDelete, admin_server.methods[i]) {
						methods = append(methods, admin_server.methods[i])
					}
				}

				// Keep permissions use when we update a service.
				log.Println("delete service permissions")
				if deletePermissions {
					// Now I will remove action permissions
					for i := 0; i < len(toDelete); i++ {
						p.Delete(context.Background(), "local_resource", "local_resource", "ActionPermission", `{"action":"`+toDelete[i]+`"}`, "")

						// Delete it from Role.
						p.Update(context.Background(), "local_resource", "local_resource", "Roles", `{}`, `{"$pull":{"actions":"`+toDelete[i]+`"}}`, "")

						// Delete it from Application.
						p.Update(context.Background(), "local_resource", "local_resource", "Applications", `{}`, `{"$pull":{"actions":"`+toDelete[i]+`"}}`, "")

						// Delete it from Peer.
						p.Update(context.Background(), "local_resource", "local_resource", "Peers", `{}`, `{"$pull":{"actions":"`+toDelete[i]+`"}}`, "")

					}
				}

				admin_server.methods = methods

				admin_server.registerMethods() // refresh methods.

				// Test if the path exit.
				path := admin_server.path + "/services/" + publisherId + "/" + name + "/" + version + "/" + serviceId
				// Now I will remove the service.
				// Service are located into the packagespb...
				if Utility.Exists(path) {
					// remove directory and sub-directory.
					err = os.RemoveAll(path)
					if err != nil {
						return err
					}
				}

			}
		}
	}

	// save the config.
	log.Println("save globular configuration wiht service " + serviceId + "removed")
	defer admin_server.saveConfig()

	log.Println("services is now uninstalled")
	return nil

}

// Uninstall a service...
func (admin_server *server) UninstallService(ctx context.Context, rqst *adminpb.UninstallServiceRequest) (*adminpb.UninstallServiceResponse, error) {
	err := admin_server.uninstallService(rqst.PublisherId, rqst.ServiceId, rqst.Version, rqst.DeletePermissions)
	if err != nil {
		return nil, status.Errorf(
			codes.Internal,
			Utility.JsonErrorStr(Utility.FunctionName(), Utility.FileLine(), err))
	}

	return &adminpb.UninstallServiceResponse{
		Result: true,
	}, nil
}

// Install/Update a service on globular instance.
// TODO wrote the code to play the shell script..
// file postinst, postrm, preinst, postinst
func (admin_server *server) installService(descriptor *packagespb.PackageDescriptor) error {
	// repository must exist...
	log.Println("step 2: try to dowload service bundle")
	if len(descriptor.Repositories) == 0 {
		return errors.New("No service repository was found for service " + descriptor.Id)
	}

	for i := 0; i < len(descriptor.Repositories); i++ {

		services_repository, err := packages_client.NewServicesRepositoryService_Client(descriptor.Repositories[i], "packages.PackageRepository")
		if err != nil {
			return err
		}

		log.Println("try to download service from ", descriptor.Repositories[i])
		bundle, err := services_repository.DownloadBundle(descriptor, globular.GetPlatform())

		if err == nil {

			previous := admin_server.getService(descriptor.Id)
			if previous != nil {
				// Uninstall the previous version...
				admin_server.uninstallService(descriptor.PublisherId, descriptor.Id, descriptor.Version, false)
			}

			// Create the file.
			r := bytes.NewReader(bundle.Binairies)
			_extracted_path_, err := Utility.ExtractTarGz(r)
			defer os.RemoveAll(_extracted_path_)
			if err != nil {
				if err.Error() != "EOF" {
					// report the error and try to continue...
					log.Println(err)
				}
			}

			// I will save the binairy in file...
			Utility.CreateDirIfNotExist(admin_server.path + "/services/")

			err = Utility.CopyDir(_extracted_path_+"/"+descriptor.PublisherId, admin_server.path+"/services/")
			if err != nil {
				return err
			}

			path := admin_server.path + "/services/" + descriptor.PublisherId + "/" + descriptor.Name + "/" + descriptor.Version + "/" + descriptor.Id

			// before I will start the service I will get a look if preinst script must be run...
			if Utility.Exists(path + "/preinst") {
				// I that case I will run it...
				log.Println("run preinst script please wait...")
				script := exec.Command("/bin/sh", path+"/preinst")
				err := script.Run()
				if err != nil {
					log.Println("error with script ", err.Error())
					defer os.RemoveAll(path)
					return err
				}
				log.Println("preinst script was execute with success! ")
			}

			configs, _ := Utility.FindFileByName(path, "config.json")

			if len(configs) == 0 {
				log.Println("No configuration file was found at at path ", path)
				return errors.New("no configuration file was found")
			}

			s := make(map[string]interface{}, 0)
			data, err := ioutil.ReadFile(configs[0])
			if err != nil {
				return err
			}
			err = json.Unmarshal(data, &s)
			if err != nil {
				return err
			}

			protos, _ := Utility.FindFileByName(admin_server.path+"/services/"+descriptor.PublisherId+"/"+descriptor.Name+"/"+descriptor.Version, ".proto")
			if len(protos) == 0 {
				log.Println("No prototype file was found at at path ", admin_server.path+"/services/"+descriptor.PublisherId+"/"+descriptor.Name+"/"+descriptor.Version)
				return errors.New("no configuration file was found")
			}

			// I will replace the path inside the config...
			execName := s["Path"].(string)[strings.LastIndex(s["Path"].(string), "/")+1:]
			s["Path"] = path + "/" + execName
			s["Proto"] = protos[0]

			// Here I will get previous service values...
			if previous != nil {
				s["KeepAlive"] = getBoolVal(previous, "KeepAlive")
				s["KeepUpToDate"] = getBoolVal(previous, "KeepUpToDate")
			}

			err = os.Chmod(s["Path"].(string), 0755)
			if err != nil {
				log.Println(err)
			}

			jsonStr, _ := Utility.ToJson(s)
			ioutil.WriteFile(configs[0], []byte(jsonStr), 0644)

			// set the service in the map.
			s_ := new(sync.Map)
			setValues(s_, s)
			log.Println("Service is install successfully!")

			// initialyse the new service.
			err = admin_server.initService(s_)
			if err != nil {
				return err
			}

			// Here I will set the service method...
			admin_server.setServiceMethods(s["Name"].(string), s["Proto"].(string))
			admin_server.registerMethods()

			// Append to the list of service discoveries.
			needSave := false
			for i := 0; i < len(descriptor.Discoveries); i++ {
				if !Utility.Contains(admin_server.Discoveries, descriptor.Discoveries[i]) {
					admin_server.Discoveries = append(admin_server.Discoveries, descriptor.Discoveries[i])
					needSave = true
				}
			}

			if Utility.Exists(path + "/postinst") {
				// I that case I will run it...
				script := exec.Command("/bin/sh", path+"/postinst")
				err := script.Run()
				if err != nil {
					log.Println("error with script ", err.Error())
					defer os.RemoveAll(path)
					return err
				}
				log.Println("running script ", path)
			}

			if needSave {
				admin_server.saveConfig()
			}

			break
		} else {
			log.Println("fail to download error with error ", err)
			return err
		}
	}

	return nil

}

// Install/Update a service on globular instance.
func (admin_server *server) InstallService(ctx context.Context, rqst *adminpb.InstallServiceRequest) (*adminpb.InstallServiceResponse, error) {
	log.Println("Try to install new service ", rqst.ServiceId, "from", rqst.DicorveryId)

	// Connect to the dicovery services
	services_discovery, err := packages_client.NewPackagesDiscoveryService_Client(rqst.DicorveryId, "packages.PackageDiscovery")

	if err != nil {
		return nil, status.Errorf(
			codes.Internal,
			Utility.JsonErrorStr(Utility.FunctionName(), Utility.FileLine(), errors.New("fail to connect to "+rqst.DicorveryId)))
	}

	descriptors, err := services_discovery.GetPackageDescriptor(rqst.ServiceId, rqst.PublisherId)
	if err != nil {
		return nil, status.Errorf(
			codes.Internal,
			Utility.JsonErrorStr(Utility.FunctionName(), Utility.FileLine(), err))
	}

	log.Println("step 1: get service descriptor")
	// The first element in the array is the most recent descriptor
	// so if no version is given the most recent will be taken.
	descriptor := descriptors[0]
	for i := 0; i < len(descriptors); i++ {
		if descriptors[i].Version == rqst.Version {
			descriptor = descriptors[i]
			break
		}
	}

	err = admin_server.installService(descriptor)
	if err != nil {
		return nil, status.Errorf(
			codes.Internal,
			Utility.JsonErrorStr(Utility.FunctionName(), Utility.FileLine(), err))
	}

	log.Println("Service was install!")
	return &adminpb.InstallServiceResponse{
		Result: true,
	}, nil

}


//////////////////////////////////////////////////////////////// Client /////////////////////////////////////////////////////////


func (admin_client *Admin_Client) StartService(id string) (int, int, error) {
	rqst := new(adminpb.StartServiceRequest)
	rqst.ServiceId = id
	rsp, err := admin_client.c.StartService(globular.GetClientContext(admin_client), rqst)
	if err != nil {
		return -1, -1, err
	}

	return int(rsp.ServicePid), int(rsp.ProxyPid), nil
}

func (admin_client *Admin_Client) StopService(id string) error {
	rqst := new(adminpb.StopServiceRequest)
	rqst.ServiceId = id
	_, err := admin_client.c.StopService(globular.GetClientContext(admin_client), rqst)
	if err != nil {
		return err
	}

	return nil
}

func (admin_client *Admin_Client) RestartServices() error {
	rqst := new(adminpb.RestartServicesRequest)

	_, err := admin_client.c.RestartServices(globular.GetClientContext(admin_client), rqst)
	if err != nil {
		return err
	}

	return nil
}


/**
 * Intall a new service or update an existing one.
 */
func (admin_client *Admin_Client) InstallService(token string, domain string, user string, discoveryId string, publisherId string, serviceId string) error {

	log.Println("Install service", serviceId, "publisherId", publisherId, "discovery", discoveryId, "on", domain)
	log.Println("token: ", token)

	rqst := new(adminpb.InstallServiceRequest)
	rqst.DicorveryId = discoveryId
	rqst.PublisherId = publisherId
	rqst.ServiceId = serviceId
	ctx := globular.GetClientContext(admin_client)
	if len(token) > 0 {
		md, _ := metadata.FromOutgoingContext(ctx)
		if len(md.Get("token")) != 0 {
			md.Set("token", token)
		}
		ctx = metadata.NewOutgoingContext(context.Background(), md)
	}

	_, err := admin_client.c.InstallService(ctx, rqst)
	
	// Fail to install service.
	if err != nil {
		log.Println("fail to install service with error ", err.Error())
	}

	return err
}

/**
 * Intall a new service or update an existing one.
 */
func (admin_client *Admin_Client) UninstallService(token string, domain string, user string, publisherId string, serviceId string, version string) error {

	rqst := new(adminpb.UninstallServiceRequest)
	rqst.PublisherId = publisherId
	rqst.ServiceId = serviceId
	rqst.Version = version
	ctx := globular.GetClientContext(admin_client)
	if len(token) > 0 {
		md, _ := metadata.FromOutgoingContext(ctx)

		if len(md.Get("token")) != 0 {
			md.Set("token", token)
		}
		ctx = metadata.NewOutgoingContext(context.Background(), md)
	}

	_, err := admin_client.c.UninstallService(ctx, rqst)

	return err
}


// Install/Update a service on globular instance.
// TODO wrote the code to play the shell script..
// file postinst, postrm, preinst, postinst
func (globule *Globule) installService(descriptor *packagespb.PackageDescriptor) error {
	// repository must exist...
	log.Println("step 2: try to dowload service bundle")
	if len(descriptor.Repositories) == 0 {
		return errors.New("No service repository was found for service " + descriptor.Id)
	}

	for i := 0; i < len(descriptor.Repositories); i++ {

		services_repository, err := packages_client.NewServicesRepositoryService_Client(descriptor.Repositories[i], "packages.PackageRepository")
		if err != nil {
			return err
		}

		log.Println("try to download service from ", descriptor.Repositories[i])
		bundle, err := services_repository.DownloadBundle(descriptor, globular.GetPlatform())

		if err == nil {

			previous := globule.getService(descriptor.Id)
			if previous != nil {
				// Uninstall the previous version...
				globule.uninstallService(descriptor.PublisherId, descriptor.Id, descriptor.Version, false)
			}

			// Create the file.
			r := bytes.NewReader(bundle.Binairies)
			_extracted_path_, err := Utility.ExtractTarGz(r)
			defer os.RemoveAll(_extracted_path_)
			if err != nil {
				if err.Error() != "EOF" {
					// report the error and try to continue...
					log.Println(err)
				}
			}

			// I will save the binairy in file...
			Utility.CreateDirIfNotExist(globule.path + "/services/")

			err = Utility.CopyDir(_extracted_path_+"/"+descriptor.PublisherId, globule.path+"/services/")
			if err != nil {
				return err
			}

			path := globule.path + "/services/" + descriptor.PublisherId + "/" + descriptor.Name + "/" + descriptor.Version + "/" + descriptor.Id

			// before I will start the service I will get a look if preinst script must be run...
			if Utility.Exists(path + "/preinst") {
				// I that case I will run it...
				log.Println("run preinst script please wait...")
				script := exec.Command("/bin/sh", path+"/preinst")
				err := script.Run()
				if err != nil {
					log.Println("error with script ", err.Error())
					defer os.RemoveAll(path)
					return err
				}
				log.Println("preinst script was execute with success! ")
			}

			configs, _ := Utility.FindFileByName(path, "config.json")

			if len(configs) == 0 {
				log.Println("No configuration file was found at at path ", path)
				return errors.New("no configuration file was found")
			}

			s := make(map[string]interface{}, 0)
			data, err := ioutil.ReadFile(configs[0])
			if err != nil {
				return err
			}
			err = json.Unmarshal(data, &s)
			if err != nil {
				return err
			}

			protos, _ := Utility.FindFileByName(globule.path+"/services/"+descriptor.PublisherId+"/"+descriptor.Name+"/"+descriptor.Version, ".proto")
			if len(protos) == 0 {
				log.Println("No prototype file was found at at path ", globule.path+"/services/"+descriptor.PublisherId+"/"+descriptor.Name+"/"+descriptor.Version)
				return errors.New("no configuration file was found")
			}

			// I will replace the path inside the config...
			execName := s["Path"].(string)[strings.LastIndex(s["Path"].(string), "/")+1:]
			s["Path"] = path + "/" + execName
			s["Proto"] = protos[0]

			// Here I will get previous service values...
			if previous != nil {
				s["KeepAlive"] = getBoolVal(previous, "KeepAlive")
				s["KeepUpToDate"] = getBoolVal(previous, "KeepUpToDate")
			}

			err = os.Chmod(s["Path"].(string), 0755)
			if err != nil {
				log.Println(err)
			}

			jsonStr, _ := Utility.ToJson(s)
			ioutil.WriteFile(configs[0], []byte(jsonStr), 0644)

			// set the service in the map.
			s_ := new(sync.Map)
			setValues(s_, s)
			log.Println("Service is install successfully!")

			// initialyse the new service.
			err = globule.initService(s_)
			if err != nil {
				return err
			}

			// Here I will set the service method...
			globule.setServiceMethods(s["Name"].(string), s["Proto"].(string))
			globule.registerMethods()

			// Append to the list of service discoveries.
			needSave := false
			for i := 0; i < len(descriptor.Discoveries); i++ {
				if !Utility.Contains(globule.Discoveries, descriptor.Discoveries[i]) {
					globule.Discoveries = append(globule.Discoveries, descriptor.Discoveries[i])
					needSave = true
				}
			}

			if Utility.Exists(path + "/postinst") {
				// I that case I will run it...
				script := exec.Command("/bin/sh", path+"/postinst")
				err := script.Run()
				if err != nil {
					log.Println("error with script ", err.Error())
					defer os.RemoveAll(path)
					return err
				}
				log.Println("running script ", path)
			}

			if needSave {
				globule.saveConfig()
			}

			break
		} else {
			log.Println("fail to download error with error ", err)
			return err
		}
	}

	return nil

}

// Install/Update a service on globular instance.
func (globule *Globule) InstallService(ctx context.Context, rqst *adminpb.InstallServiceRequest) (*adminpb.InstallServiceResponse, error) {
	log.Println("Try to install new service ", rqst.ServiceId, "from", rqst.DicorveryId)

	// Connect to the dicovery services
	services_discovery, err := packages_client.NewPackagesDiscoveryService_Client(rqst.DicorveryId, "packages.PackageDiscovery")

	if err != nil {
		return nil, status.Errorf(
			codes.Internal,
			Utility.JsonErrorStr(Utility.FunctionName(), Utility.FileLine(), errors.New("fail to connect to "+rqst.DicorveryId)))
	}

	descriptors, err := services_discovery.GetPackageDescriptor(rqst.ServiceId, rqst.PublisherId)
	if err != nil {
		return nil, status.Errorf(
			codes.Internal,
			Utility.JsonErrorStr(Utility.FunctionName(), Utility.FileLine(), err))
	}

	log.Println("step 1: get service descriptor")
	// The first element in the array is the most recent descriptor
	// so if no version is given the most recent will be taken.
	descriptor := descriptors[0]
	for i := 0; i < len(descriptors); i++ {
		if descriptors[i].Version == rqst.Version {
			descriptor = descriptors[i]
			break
		}
	}

	err = globule.installService(descriptor)
	if err != nil {
		return nil, status.Errorf(
			codes.Internal,
			Utility.JsonErrorStr(Utility.FunctionName(), Utility.FileLine(), err))
	}

	log.Println("Service was install!")
	return &adminpb.InstallServiceResponse{
		Result: true,
	}, nil

}

// uninstall service
func (globule *Globule) uninstallService(publisherId string, serviceId string, version string, deletePermissions bool) error {
	p, err := globule.getPersistenceStore()
	if err != nil {
		return err
	}

	log.Println("Uninstalling services ", publisherId, serviceId, "...")
	// First of all I will stop the running service(s) instance.
	for _, s := range globule.getServices() {
		// Stop the instance of the service.
		id, ok := s.Load("Id")
		if ok {
			name := getStringVal(s, "Name")
			if getStringVal(s, "PublisherId") == publisherId && id == serviceId && getStringVal(s, "Version") == version {
				// First of all I will unsubcribe to the package event...
				event_channel_id := getStringVal(s, "PublisherId") + ":" + getStringVal(s, "Id") + ":SERVICE_PUBLISH_EVENT"
				discoveries := getVal(s, "Discoveries")
				if discoveries != nil {
					for i := 0; i < len(discoveries.([]interface{})); i++ {
						discovery := discoveries.([]interface{})[i].(string)
						eventHub := globule.discorveriesEventHub[discovery]
						if eventHub != nil {
							pid := getIntVal(s, "Process")
							if pid != -1 {
								uuid := Utility.GenerateUUID(getStringVal(s, "Id") + Utility.ToString(pid))
								log.Println("Unsbuscribe to event channel ", event_channel_id, " whit listener uuid ", uuid)
								eventHub.UnSubscribe(event_channel_id, uuid)
							}

						}
					}
				}

				time.Sleep(time.Second * 5) // WAIT FOR LISTENERS TO DISCONNECT...
				log.Println("stop service ", name)
				globule.stopService(s)

				log.Println("delete service ", name)
				globule.deleteService(id.(string))

				// Get the list of method to remove from the list of actions.
				toDelete := globule.getServiceMethods(name, getStringVal(s, "Proto"))
				methods := make([]string, 0)
				for i := 0; i < len(globule.methods); i++ {
					if !Utility.Contains(toDelete, globule.methods[i]) {
						methods = append(methods, globule.methods[i])
					}
				}

				// Keep permissions use when we update a service.
				log.Println("delete service permissions")
				if deletePermissions {
					// Now I will remove action permissions
					for i := 0; i < len(toDelete); i++ {
						p.Delete(context.Background(), "local_resource", "local_resource", "ActionPermission", `{"action":"`+toDelete[i]+`"}`, "")

						// Delete it from Role.
						p.Update(context.Background(), "local_resource", "local_resource", "Roles", `{}`, `{"$pull":{"actions":"`+toDelete[i]+`"}}`, "")

						// Delete it from Application.
						p.Update(context.Background(), "local_resource", "local_resource", "Applications", `{}`, `{"$pull":{"actions":"`+toDelete[i]+`"}}`, "")

						// Delete it from Peer.
						p.Update(context.Background(), "local_resource", "local_resource", "Peers", `{}`, `{"$pull":{"actions":"`+toDelete[i]+`"}}`, "")

					}
				}

				globule.methods = methods

				globule.registerMethods() // refresh methods.

				// Test if the path exit.
				path := globule.path + "/services/" + publisherId + "/" + name + "/" + version + "/" + serviceId
				// Now I will remove the service.
				// Service are located into the packagespb...
				if Utility.Exists(path) {
					// remove directory and sub-directory.
					err = os.RemoveAll(path)
					if err != nil {
						return err
					}
				}

			}
		}
	}

	// save the config.
	log.Println("save globular configuration wiht service " + serviceId + "removed")
	defer globule.saveConfig()

	log.Println("services is now uninstalled")
	return nil

}

// Uninstall a service...
func (globule *Globule) UninstallService(ctx context.Context, rqst *adminpb.UninstallServiceRequest) (*adminpb.UninstallServiceResponse, error) {
	err := globule.uninstallService(rqst.PublisherId, rqst.ServiceId, rqst.Version, rqst.DeletePermissions)
	if err != nil {
		return nil, status.Errorf(
			codes.Internal,
			Utility.JsonErrorStr(Utility.FunctionName(), Utility.FileLine(), err))
	}

	return &adminpb.UninstallServiceResponse{
		Result: true,
	}, nil
}



/**
 * Retunr the path of config.json for a given services.
 */
func (globule *Globule) getServiceConfigPath(s *sync.Map) string {

	path := getStringVal(s, "Path")
	index := strings.LastIndex(path, "/")
	if index == -1 {
		return ""
	}

	path = path[0:index] + "/config.json"
	return path
}

func (globule *Globule) stopService(s *sync.Map) error {

	// Set keep alive to false...
	s.Store("State", "terminated")
	globule.setService(s) // set in the map...

	_, hasProcessPid := s.Load("Process")
	if !hasProcessPid {
		s.Store("Process", -1)
	}

	pid := getIntVal(s, "Process")
	if pid != -1 {
		log.Println("stop service ", getStringVal(s, "Name"), "pid:", pid)
		if runtime.GOOS == "windows" {
			// Program written with dotnet on window need this command to stop...
			kill := exec.Command("TASKKILL", "/T", "/F", "/PID", strconv.Itoa(pid))
			kill.Stderr = os.Stderr
			kill.Stdout = os.Stdout
			kill.Run()
		} else {
			err := Utility.TerminateProcess(pid, 0)
			if err != nil {
				log.Println("fail to teminate process ", pid)
			}
		}
	}

	_, hasProxyProcessPid := s.Load("ProxyProcess")
	if !hasProxyProcessPid {
		s.Store("ProxyProcess", -1)
	}
	pid = getIntVal(s, "ProxyProcess")
	if pid != -1 {
		err := Utility.TerminateProcess(pid, 0)
		if err != nil {
			log.Println("fail to teminate proxy process ", pid)
		}
	}

	s.Store("Process", -1)
	s.Store("ProxyProcess", -1)
	s.Store("State", "stopped")

	// set the service back in the map.
	globule.setService(s)

	config := make(map[string]interface{}, 0)
	s.Range(func(k, v interface{}) bool {
		config[k.(string)] = v
		return true
	})

	// sync the data/config file with the service file.
	jsonStr, _ := Utility.ToJson(config)

	// here I will write the file
	configPath := globule.getServiceConfigPath(s)
	if len(configPath) > 0 {
		log.Println("save configuration at ", configPath)
		err := ioutil.WriteFile(configPath, []byte(jsonStr), 0644)
		if err != nil {
			return err
		}
	}

	// globule.logServiceInfo(getStringVal(s, "Name"), time.Now().String()+"Service "+getStringVal(s, "Name")+" was stopped!")

	return nil
}

// Stop a service
func (globule *Globule) StopService(ctx context.Context, rqst *adminpb.StopServiceRequest) (*adminpb.StopServiceResponse, error) {

	s := globule.getService(rqst.ServiceId)
	if s != nil {
		err := globule.stopService(s)
		if err != nil {
			return nil, status.Errorf(
				codes.Internal,
				Utility.JsonErrorStr(Utility.FunctionName(), Utility.FileLine(), err))
		}
	} else {
		// Close all services with a given name.
		services := globule.getServiceConfigByName(rqst.ServiceId)
		for i := 0; i < len(services); i++ {
			serviceId := services[i]["Id"].(string)
			s := globule.getService(serviceId)
			if s == nil {
				return nil, status.Errorf(
					codes.Internal,
					Utility.JsonErrorStr(Utility.FunctionName(), Utility.FileLine(), errors.New("No service found with id "+serviceId)))
			}
			err := globule.stopService(s)
			if err != nil {
				return nil, status.Errorf(
					codes.Internal,
					Utility.JsonErrorStr(Utility.FunctionName(), Utility.FileLine(), err))
			}
		}
	}

	return &adminpb.StopServiceResponse{
		Result: true,
	}, nil

}

// Start a service
func (globule *Globule) StartService(ctx context.Context, rqst *adminpb.StartServiceRequest) (*adminpb.StartServiceResponse, error) {

	s := globule.getService(rqst.ServiceId)
	proxy_pid := int64(-1)
	service_pid := int64(-1)

	if s == nil {
		services := globule.getServiceConfigByName(rqst.ServiceId)
		for i := 0; i < len(services); i++ {
			id := services[i]["Id"].(string)
			s := globule.getService(id)
			service_pid_, proxy_pid_, err := globule.startService(s)
			if err != nil {
				return nil, status.Errorf(
					codes.Internal,
					Utility.JsonErrorStr(Utility.FunctionName(), Utility.FileLine(), err))
			}
			proxy_pid = int64(proxy_pid_)
			service_pid = int64(service_pid_)
		}
	} else {
		service_pid_, proxy_pid_, err := globule.startService(s)
		if err != nil {
			return nil, status.Errorf(
				codes.Internal,
				Utility.JsonErrorStr(Utility.FunctionName(), Utility.FileLine(), err))
		}
		proxy_pid = int64(proxy_pid_)
		service_pid = int64(service_pid_)
	}

	return &adminpb.StartServiceResponse{
		ProxyPid:   proxy_pid,
		ServicePid: service_pid,
	}, nil
}

// Restart all Services also the http(s)
func (globule *Globule) RestartServices(ctx context.Context, rqst *adminpb.RestartServicesRequest) (*adminpb.RestartServicesResponse, error) {
	log.Println("restart service... ")
	globule.restartServices()

	return &adminpb.RestartServicesResponse{}, nil
}

func (globule *Globule) restartServices() {
	if globule.exit_ {
		return // already restarting I will ingnore the call.
	}

	// Stop all external services.
	globule.stopServices()
}

