// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: resource.proto
// Original file comments:
// *
// Management and definition of resources.
#ifndef GRPC_resource_2eproto__INCLUDED
#define GRPC_resource_2eproto__INCLUDED

#include "resource.pb.h"

#include <functional>
#include <grpc/impl/codegen/port_platform.h>
#include <grpcpp/impl/codegen/async_generic_service.h>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/client_context.h>
#include <grpcpp/impl/codegen/completion_queue.h>
#include <grpcpp/impl/codegen/message_allocator.h>
#include <grpcpp/impl/codegen/method_handler.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/codegen/rpc_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/server_callback_handlers.h>
#include <grpcpp/impl/codegen/server_context.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/impl/codegen/stub_options.h>
#include <grpcpp/impl/codegen/sync_stream.h>

namespace resource {

// *
// That service is use to manage Globular resource like permissions and accounts
// or role. The service made use of Persistence service to store various 
// objects.
class ResourceService final {
 public:
  static constexpr char const* service_full_name() {
    return "resource.ResourceService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // * Return the list of all grpc methods *
    virtual ::grpc::Status GetAllActions(::grpc::ClientContext* context, const ::resource::GetAllActionsRqst& request, ::resource::GetAllActionsRsp* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::GetAllActionsRsp>> AsyncGetAllActions(::grpc::ClientContext* context, const ::resource::GetAllActionsRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::GetAllActionsRsp>>(AsyncGetAllActionsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::GetAllActionsRsp>> PrepareAsyncGetAllActions(::grpc::ClientContext* context, const ::resource::GetAllActionsRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::GetAllActionsRsp>>(PrepareAsyncGetAllActionsRaw(context, request, cq));
    }
    // * Validate a token *
    virtual ::grpc::Status ValidateToken(::grpc::ClientContext* context, const ::resource::ValidateTokenRqst& request, ::resource::ValidateTokenRsp* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::ValidateTokenRsp>> AsyncValidateToken(::grpc::ClientContext* context, const ::resource::ValidateTokenRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::ValidateTokenRsp>>(AsyncValidateTokenRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::ValidateTokenRsp>> PrepareAsyncValidateToken(::grpc::ClientContext* context, const ::resource::ValidateTokenRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::ValidateTokenRsp>>(PrepareAsyncValidateTokenRaw(context, request, cq));
    }
    // * Refresh token get a new token *
    virtual ::grpc::Status RefreshToken(::grpc::ClientContext* context, const ::resource::RefreshTokenRqst& request, ::resource::RefreshTokenRsp* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::RefreshTokenRsp>> AsyncRefreshToken(::grpc::ClientContext* context, const ::resource::RefreshTokenRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::RefreshTokenRsp>>(AsyncRefreshTokenRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::RefreshTokenRsp>> PrepareAsyncRefreshToken(::grpc::ClientContext* context, const ::resource::RefreshTokenRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::RefreshTokenRsp>>(PrepareAsyncRefreshTokenRaw(context, request, cq));
    }
    // //////////////////////////////////////////////////////////////////////////
    // Authentication
    // //////////////////////////////////////////////////////////////////////////
    //
    // * Authenticate a user *
    virtual ::grpc::Status Authenticate(::grpc::ClientContext* context, const ::resource::AuthenticateRqst& request, ::resource::AuthenticateRsp* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::AuthenticateRsp>> AsyncAuthenticate(::grpc::ClientContext* context, const ::resource::AuthenticateRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::AuthenticateRsp>>(AsyncAuthenticateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::AuthenticateRsp>> PrepareAsyncAuthenticate(::grpc::ClientContext* context, const ::resource::AuthenticateRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::AuthenticateRsp>>(PrepareAsyncAuthenticateRaw(context, request, cq));
    }
    // * Synchronize Resource with LDAP if connection exist *
    virtual ::grpc::Status SynchronizeLdap(::grpc::ClientContext* context, const ::resource::SynchronizeLdapRqst& request, ::resource::SynchronizeLdapRsp* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::SynchronizeLdapRsp>> AsyncSynchronizeLdap(::grpc::ClientContext* context, const ::resource::SynchronizeLdapRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::SynchronizeLdapRsp>>(AsyncSynchronizeLdapRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::SynchronizeLdapRsp>> PrepareAsyncSynchronizeLdap(::grpc::ClientContext* context, const ::resource::SynchronizeLdapRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::SynchronizeLdapRsp>>(PrepareAsyncSynchronizeLdapRaw(context, request, cq));
    }
    // //////////////////////////////////////////////////////////////////////////
    // Resource's control objects
    // //////////////////////////////////////////////////////////////////////////
    //
    // //////////////////////////////////////////////////////////////////////////
    // Organization's
    // //////////////////////////////////////////////////////////////////////////
    //
    // * Register a new organization 
    virtual ::grpc::Status CreateOrganization(::grpc::ClientContext* context, const ::resource::CreateOrganizationRqst& request, ::resource::CreateOrganizationRsp* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::CreateOrganizationRsp>> AsyncCreateOrganization(::grpc::ClientContext* context, const ::resource::CreateOrganizationRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::CreateOrganizationRsp>>(AsyncCreateOrganizationRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::CreateOrganizationRsp>> PrepareAsyncCreateOrganization(::grpc::ClientContext* context, const ::resource::CreateOrganizationRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::CreateOrganizationRsp>>(PrepareAsyncCreateOrganizationRaw(context, request, cq));
    }
    // * Return the list of organizations 
    std::unique_ptr< ::grpc::ClientReaderInterface< ::resource::GetOrganizationsRsp>> GetOrganizations(::grpc::ClientContext* context, const ::resource::GetOrganizationsRqst& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::resource::GetOrganizationsRsp>>(GetOrganizationsRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::resource::GetOrganizationsRsp>> AsyncGetOrganizations(::grpc::ClientContext* context, const ::resource::GetOrganizationsRqst& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::resource::GetOrganizationsRsp>>(AsyncGetOrganizationsRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::resource::GetOrganizationsRsp>> PrepareAsyncGetOrganizations(::grpc::ClientContext* context, const ::resource::GetOrganizationsRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::resource::GetOrganizationsRsp>>(PrepareAsyncGetOrganizationsRaw(context, request, cq));
    }
    // * Delete organization 
    virtual ::grpc::Status DeleteOrganization(::grpc::ClientContext* context, const ::resource::DeleteOrganizationRqst& request, ::resource::DeleteOrganizationRsp* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::DeleteOrganizationRsp>> AsyncDeleteOrganization(::grpc::ClientContext* context, const ::resource::DeleteOrganizationRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::DeleteOrganizationRsp>>(AsyncDeleteOrganizationRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::DeleteOrganizationRsp>> PrepareAsyncDeleteOrganization(::grpc::ClientContext* context, const ::resource::DeleteOrganizationRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::DeleteOrganizationRsp>>(PrepareAsyncDeleteOrganizationRaw(context, request, cq));
    }
    // //////////////////////////////////////////////////////////////////////////
    // Group's
    // //////////////////////////////////////////////////////////////////////////
    //
    // * Register a new group 
    virtual ::grpc::Status CreateGroup(::grpc::ClientContext* context, const ::resource::CreateGroupRqst& request, ::resource::CreateGroupRsp* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::CreateGroupRsp>> AsyncCreateGroup(::grpc::ClientContext* context, const ::resource::CreateGroupRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::CreateGroupRsp>>(AsyncCreateGroupRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::CreateGroupRsp>> PrepareAsyncCreateGroup(::grpc::ClientContext* context, const ::resource::CreateGroupRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::CreateGroupRsp>>(PrepareAsyncCreateGroupRaw(context, request, cq));
    }
    // * Return the list of groups 
    std::unique_ptr< ::grpc::ClientReaderInterface< ::resource::GetGroupsRsp>> GetGroups(::grpc::ClientContext* context, const ::resource::GetGroupsRqst& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::resource::GetGroupsRsp>>(GetGroupsRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::resource::GetGroupsRsp>> AsyncGetGroups(::grpc::ClientContext* context, const ::resource::GetGroupsRqst& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::resource::GetGroupsRsp>>(AsyncGetGroupsRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::resource::GetGroupsRsp>> PrepareAsyncGetGroups(::grpc::ClientContext* context, const ::resource::GetGroupsRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::resource::GetGroupsRsp>>(PrepareAsyncGetGroupsRaw(context, request, cq));
    }
    // * Delete group 
    virtual ::grpc::Status DeleteGroup(::grpc::ClientContext* context, const ::resource::DeleteGroupRqst& request, ::resource::DeleteGroupRsp* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::DeleteGroupRsp>> AsyncDeleteGroup(::grpc::ClientContext* context, const ::resource::DeleteGroupRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::DeleteGroupRsp>>(AsyncDeleteGroupRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::DeleteGroupRsp>> PrepareAsyncDeleteGroup(::grpc::ClientContext* context, const ::resource::DeleteGroupRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::DeleteGroupRsp>>(PrepareAsyncDeleteGroupRaw(context, request, cq));
    }
    // * Add a member account to the group *
    virtual ::grpc::Status AddGroupMemberAccount(::grpc::ClientContext* context, const ::resource::AddGroupMemberAccountRqst& request, ::resource::AddGroupMemberAccountRsp* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::AddGroupMemberAccountRsp>> AsyncAddGroupMemberAccount(::grpc::ClientContext* context, const ::resource::AddGroupMemberAccountRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::AddGroupMemberAccountRsp>>(AsyncAddGroupMemberAccountRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::AddGroupMemberAccountRsp>> PrepareAsyncAddGroupMemberAccount(::grpc::ClientContext* context, const ::resource::AddGroupMemberAccountRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::AddGroupMemberAccountRsp>>(PrepareAsyncAddGroupMemberAccountRaw(context, request, cq));
    }
    // * Remove member account from the group *
    virtual ::grpc::Status RemoveGroupMemberAccount(::grpc::ClientContext* context, const ::resource::RemoveGroupMemberAccountRqst& request, ::resource::RemoveGroupMemberAccountRsp* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::RemoveGroupMemberAccountRsp>> AsyncRemoveGroupMemberAccount(::grpc::ClientContext* context, const ::resource::RemoveGroupMemberAccountRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::RemoveGroupMemberAccountRsp>>(AsyncRemoveGroupMemberAccountRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::RemoveGroupMemberAccountRsp>> PrepareAsyncRemoveGroupMemberAccount(::grpc::ClientContext* context, const ::resource::RemoveGroupMemberAccountRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::RemoveGroupMemberAccountRsp>>(PrepareAsyncRemoveGroupMemberAccountRaw(context, request, cq));
    }
    // //////////////////////////////////////////////////////////////////////////
    // Account's
    // //////////////////////////////////////////////////////////////////////////
    //
    // * Register a new Account *
    virtual ::grpc::Status RegisterAccount(::grpc::ClientContext* context, const ::resource::RegisterAccountRqst& request, ::resource::RegisterAccountRsp* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::RegisterAccountRsp>> AsyncRegisterAccount(::grpc::ClientContext* context, const ::resource::RegisterAccountRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::RegisterAccountRsp>>(AsyncRegisterAccountRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::RegisterAccountRsp>> PrepareAsyncRegisterAccount(::grpc::ClientContext* context, const ::resource::RegisterAccountRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::RegisterAccountRsp>>(PrepareAsyncRegisterAccountRaw(context, request, cq));
    }
    // * Delete an account *
    virtual ::grpc::Status DeleteAccount(::grpc::ClientContext* context, const ::resource::DeleteAccountRqst& request, ::resource::DeleteAccountRsp* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::DeleteAccountRsp>> AsyncDeleteAccount(::grpc::ClientContext* context, const ::resource::DeleteAccountRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::DeleteAccountRsp>>(AsyncDeleteAccountRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::DeleteAccountRsp>> PrepareAsyncDeleteAccount(::grpc::ClientContext* context, const ::resource::DeleteAccountRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::DeleteAccountRsp>>(PrepareAsyncDeleteAccountRaw(context, request, cq));
    }
    // * Add role to a given account *
    virtual ::grpc::Status AddAccountRole(::grpc::ClientContext* context, const ::resource::AddAccountRoleRqst& request, ::resource::AddAccountRoleRsp* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::AddAccountRoleRsp>> AsyncAddAccountRole(::grpc::ClientContext* context, const ::resource::AddAccountRoleRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::AddAccountRoleRsp>>(AsyncAddAccountRoleRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::AddAccountRoleRsp>> PrepareAsyncAddAccountRole(::grpc::ClientContext* context, const ::resource::AddAccountRoleRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::AddAccountRoleRsp>>(PrepareAsyncAddAccountRoleRaw(context, request, cq));
    }
    // * Remove a role from a given account *
    virtual ::grpc::Status RemoveAccountRole(::grpc::ClientContext* context, const ::resource::RemoveAccountRoleRqst& request, ::resource::RemoveAccountRoleRsp* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::RemoveAccountRoleRsp>> AsyncRemoveAccountRole(::grpc::ClientContext* context, const ::resource::RemoveAccountRoleRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::RemoveAccountRoleRsp>>(AsyncRemoveAccountRoleRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::RemoveAccountRoleRsp>> PrepareAsyncRemoveAccountRole(::grpc::ClientContext* context, const ::resource::RemoveAccountRoleRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::RemoveAccountRoleRsp>>(PrepareAsyncRemoveAccountRoleRaw(context, request, cq));
    }
    // //////////////////////////////////////////////////////////////////////////
    // Action's control objects
    // //////////////////////////////////////////////////////////////////////////
    //
    // //////////////////////////////////////////////////////////////////////////
    // Role's
    // //////////////////////////////////////////////////////////////////////////
    //
    // * Create a role with given action list *
    virtual ::grpc::Status CreateRole(::grpc::ClientContext* context, const ::resource::CreateRoleRqst& request, ::resource::CreateRoleRsp* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::CreateRoleRsp>> AsyncCreateRole(::grpc::ClientContext* context, const ::resource::CreateRoleRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::CreateRoleRsp>>(AsyncCreateRoleRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::CreateRoleRsp>> PrepareAsyncCreateRole(::grpc::ClientContext* context, const ::resource::CreateRoleRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::CreateRoleRsp>>(PrepareAsyncCreateRoleRaw(context, request, cq));
    }
    // * Delete a role with a given id *
    virtual ::grpc::Status DeleteRole(::grpc::ClientContext* context, const ::resource::DeleteRoleRqst& request, ::resource::DeleteRoleRsp* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::DeleteRoleRsp>> AsyncDeleteRole(::grpc::ClientContext* context, const ::resource::DeleteRoleRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::DeleteRoleRsp>>(AsyncDeleteRoleRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::DeleteRoleRsp>> PrepareAsyncDeleteRole(::grpc::ClientContext* context, const ::resource::DeleteRoleRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::DeleteRoleRsp>>(PrepareAsyncDeleteRoleRaw(context, request, cq));
    }
    // * Append an action to existing role. *
    virtual ::grpc::Status AddRoleAction(::grpc::ClientContext* context, const ::resource::AddRoleActionRqst& request, ::resource::AddRoleActionRsp* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::AddRoleActionRsp>> AsyncAddRoleAction(::grpc::ClientContext* context, const ::resource::AddRoleActionRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::AddRoleActionRsp>>(AsyncAddRoleActionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::AddRoleActionRsp>> PrepareAsyncAddRoleAction(::grpc::ClientContext* context, const ::resource::AddRoleActionRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::AddRoleActionRsp>>(PrepareAsyncAddRoleActionRaw(context, request, cq));
    }
    // * Remove an action to existing role. *
    virtual ::grpc::Status RemoveRoleAction(::grpc::ClientContext* context, const ::resource::RemoveRoleActionRqst& request, ::resource::RemoveRoleActionRsp* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::RemoveRoleActionRsp>> AsyncRemoveRoleAction(::grpc::ClientContext* context, const ::resource::RemoveRoleActionRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::RemoveRoleActionRsp>>(AsyncRemoveRoleActionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::RemoveRoleActionRsp>> PrepareAsyncRemoveRoleAction(::grpc::ClientContext* context, const ::resource::RemoveRoleActionRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::RemoveRoleActionRsp>>(PrepareAsyncRemoveRoleActionRaw(context, request, cq));
    }
    // //////////////////////////////////////////////////////////////////////////
    // Application's
    // //////////////////////////////////////////////////////////////////////////
    //
    // * Return a json string with all applications informations *
    virtual ::grpc::Status GetAllApplicationsInfo(::grpc::ClientContext* context, const ::resource::GetAllApplicationsInfoRqst& request, ::resource::GetAllApplicationsInfoRsp* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::GetAllApplicationsInfoRsp>> AsyncGetAllApplicationsInfo(::grpc::ClientContext* context, const ::resource::GetAllApplicationsInfoRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::GetAllApplicationsInfoRsp>>(AsyncGetAllApplicationsInfoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::GetAllApplicationsInfoRsp>> PrepareAsyncGetAllApplicationsInfo(::grpc::ClientContext* context, const ::resource::GetAllApplicationsInfoRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::GetAllApplicationsInfoRsp>>(PrepareAsyncGetAllApplicationsInfoRaw(context, request, cq));
    }
    // * Delete an application from the server. *
    virtual ::grpc::Status DeleteApplication(::grpc::ClientContext* context, const ::resource::DeleteApplicationRqst& request, ::resource::DeleteApplicationRsp* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::DeleteApplicationRsp>> AsyncDeleteApplication(::grpc::ClientContext* context, const ::resource::DeleteApplicationRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::DeleteApplicationRsp>>(AsyncDeleteApplicationRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::DeleteApplicationRsp>> PrepareAsyncDeleteApplication(::grpc::ClientContext* context, const ::resource::DeleteApplicationRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::DeleteApplicationRsp>>(PrepareAsyncDeleteApplicationRaw(context, request, cq));
    }
    // * Append an action to existing applications. *
    virtual ::grpc::Status AddApplicationAction(::grpc::ClientContext* context, const ::resource::AddApplicationActionRqst& request, ::resource::AddApplicationActionRsp* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::AddApplicationActionRsp>> AsyncAddApplicationAction(::grpc::ClientContext* context, const ::resource::AddApplicationActionRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::AddApplicationActionRsp>>(AsyncAddApplicationActionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::AddApplicationActionRsp>> PrepareAsyncAddApplicationAction(::grpc::ClientContext* context, const ::resource::AddApplicationActionRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::AddApplicationActionRsp>>(PrepareAsyncAddApplicationActionRaw(context, request, cq));
    }
    // * Remove an action to existing applications. *
    virtual ::grpc::Status RemoveApplicationAction(::grpc::ClientContext* context, const ::resource::RemoveApplicationActionRqst& request, ::resource::RemoveApplicationActionRsp* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::RemoveApplicationActionRsp>> AsyncRemoveApplicationAction(::grpc::ClientContext* context, const ::resource::RemoveApplicationActionRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::RemoveApplicationActionRsp>>(AsyncRemoveApplicationActionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::RemoveApplicationActionRsp>> PrepareAsyncRemoveApplicationAction(::grpc::ClientContext* context, const ::resource::RemoveApplicationActionRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::RemoveApplicationActionRsp>>(PrepareAsyncRemoveApplicationActionRaw(context, request, cq));
    }
    // //////////////////////////////////////////////////////////////////////////
    // Peer's
    // //////////////////////////////////////////////////////////////////////////
    //
    // * Register a peer on the network *
    virtual ::grpc::Status RegisterPeer(::grpc::ClientContext* context, const ::resource::RegisterPeerRqst& request, ::resource::RegisterPeerRsp* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::RegisterPeerRsp>> AsyncRegisterPeer(::grpc::ClientContext* context, const ::resource::RegisterPeerRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::RegisterPeerRsp>>(AsyncRegisterPeerRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::RegisterPeerRsp>> PrepareAsyncRegisterPeer(::grpc::ClientContext* context, const ::resource::RegisterPeerRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::RegisterPeerRsp>>(PrepareAsyncRegisterPeerRaw(context, request, cq));
    }
    // * Return the list of peers *
    std::unique_ptr< ::grpc::ClientReaderInterface< ::resource::GetPeersRsp>> GetPeers(::grpc::ClientContext* context, const ::resource::GetPeersRqst& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::resource::GetPeersRsp>>(GetPeersRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::resource::GetPeersRsp>> AsyncGetPeers(::grpc::ClientContext* context, const ::resource::GetPeersRqst& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::resource::GetPeersRsp>>(AsyncGetPeersRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::resource::GetPeersRsp>> PrepareAsyncGetPeers(::grpc::ClientContext* context, const ::resource::GetPeersRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::resource::GetPeersRsp>>(PrepareAsyncGetPeersRaw(context, request, cq));
    }
    // * Remove a peer from the network *
    virtual ::grpc::Status DeletePeer(::grpc::ClientContext* context, const ::resource::DeletePeerRqst& request, ::resource::DeletePeerRsp* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::DeletePeerRsp>> AsyncDeletePeer(::grpc::ClientContext* context, const ::resource::DeletePeerRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::DeletePeerRsp>>(AsyncDeletePeerRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::DeletePeerRsp>> PrepareAsyncDeletePeer(::grpc::ClientContext* context, const ::resource::DeletePeerRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::DeletePeerRsp>>(PrepareAsyncDeletePeerRaw(context, request, cq));
    }
    // * Add peer action permission *
    virtual ::grpc::Status AddPeerAction(::grpc::ClientContext* context, const ::resource::AddPeerActionRqst& request, ::resource::AddPeerActionRsp* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::AddPeerActionRsp>> AsyncAddPeerAction(::grpc::ClientContext* context, const ::resource::AddPeerActionRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::AddPeerActionRsp>>(AsyncAddPeerActionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::AddPeerActionRsp>> PrepareAsyncAddPeerAction(::grpc::ClientContext* context, const ::resource::AddPeerActionRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::AddPeerActionRsp>>(PrepareAsyncAddPeerActionRaw(context, request, cq));
    }
    // * Remove peer action permission *
    virtual ::grpc::Status RemovePeerAction(::grpc::ClientContext* context, const ::resource::RemovePeerActionRqst& request, ::resource::RemovePeerActionRsp* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::RemovePeerActionRsp>> AsyncRemovePeerAction(::grpc::ClientContext* context, const ::resource::RemovePeerActionRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::RemovePeerActionRsp>>(AsyncRemovePeerActionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::RemovePeerActionRsp>> PrepareAsyncRemovePeerAction(::grpc::ClientContext* context, const ::resource::RemovePeerActionRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::RemovePeerActionRsp>>(PrepareAsyncRemovePeerActionRaw(context, request, cq));
    }
    class experimental_async_interface {
     public:
      virtual ~experimental_async_interface() {}
      // * Return the list of all grpc methods *
      virtual void GetAllActions(::grpc::ClientContext* context, const ::resource::GetAllActionsRqst* request, ::resource::GetAllActionsRsp* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetAllActions(::grpc::ClientContext* context, const ::resource::GetAllActionsRqst* request, ::resource::GetAllActionsRsp* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetAllActions(::grpc::ClientContext* context, const ::resource::GetAllActionsRqst* request, ::resource::GetAllActionsRsp* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // * Validate a token *
      virtual void ValidateToken(::grpc::ClientContext* context, const ::resource::ValidateTokenRqst* request, ::resource::ValidateTokenRsp* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ValidateToken(::grpc::ClientContext* context, const ::resource::ValidateTokenRqst* request, ::resource::ValidateTokenRsp* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ValidateToken(::grpc::ClientContext* context, const ::resource::ValidateTokenRqst* request, ::resource::ValidateTokenRsp* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // * Refresh token get a new token *
      virtual void RefreshToken(::grpc::ClientContext* context, const ::resource::RefreshTokenRqst* request, ::resource::RefreshTokenRsp* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void RefreshToken(::grpc::ClientContext* context, const ::resource::RefreshTokenRqst* request, ::resource::RefreshTokenRsp* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void RefreshToken(::grpc::ClientContext* context, const ::resource::RefreshTokenRqst* request, ::resource::RefreshTokenRsp* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // //////////////////////////////////////////////////////////////////////////
      // Authentication
      // //////////////////////////////////////////////////////////////////////////
      //
      // * Authenticate a user *
      virtual void Authenticate(::grpc::ClientContext* context, const ::resource::AuthenticateRqst* request, ::resource::AuthenticateRsp* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void Authenticate(::grpc::ClientContext* context, const ::resource::AuthenticateRqst* request, ::resource::AuthenticateRsp* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void Authenticate(::grpc::ClientContext* context, const ::resource::AuthenticateRqst* request, ::resource::AuthenticateRsp* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // * Synchronize Resource with LDAP if connection exist *
      virtual void SynchronizeLdap(::grpc::ClientContext* context, const ::resource::SynchronizeLdapRqst* request, ::resource::SynchronizeLdapRsp* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void SynchronizeLdap(::grpc::ClientContext* context, const ::resource::SynchronizeLdapRqst* request, ::resource::SynchronizeLdapRsp* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void SynchronizeLdap(::grpc::ClientContext* context, const ::resource::SynchronizeLdapRqst* request, ::resource::SynchronizeLdapRsp* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // //////////////////////////////////////////////////////////////////////////
      // Resource's control objects
      // //////////////////////////////////////////////////////////////////////////
      //
      // //////////////////////////////////////////////////////////////////////////
      // Organization's
      // //////////////////////////////////////////////////////////////////////////
      //
      // * Register a new organization 
      virtual void CreateOrganization(::grpc::ClientContext* context, const ::resource::CreateOrganizationRqst* request, ::resource::CreateOrganizationRsp* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void CreateOrganization(::grpc::ClientContext* context, const ::resource::CreateOrganizationRqst* request, ::resource::CreateOrganizationRsp* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void CreateOrganization(::grpc::ClientContext* context, const ::resource::CreateOrganizationRqst* request, ::resource::CreateOrganizationRsp* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // * Return the list of organizations 
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetOrganizations(::grpc::ClientContext* context, ::resource::GetOrganizationsRqst* request, ::grpc::ClientReadReactor< ::resource::GetOrganizationsRsp>* reactor) = 0;
      #else
      virtual void GetOrganizations(::grpc::ClientContext* context, ::resource::GetOrganizationsRqst* request, ::grpc::experimental::ClientReadReactor< ::resource::GetOrganizationsRsp>* reactor) = 0;
      #endif
      // * Delete organization 
      virtual void DeleteOrganization(::grpc::ClientContext* context, const ::resource::DeleteOrganizationRqst* request, ::resource::DeleteOrganizationRsp* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void DeleteOrganization(::grpc::ClientContext* context, const ::resource::DeleteOrganizationRqst* request, ::resource::DeleteOrganizationRsp* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void DeleteOrganization(::grpc::ClientContext* context, const ::resource::DeleteOrganizationRqst* request, ::resource::DeleteOrganizationRsp* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // //////////////////////////////////////////////////////////////////////////
      // Group's
      // //////////////////////////////////////////////////////////////////////////
      //
      // * Register a new group 
      virtual void CreateGroup(::grpc::ClientContext* context, const ::resource::CreateGroupRqst* request, ::resource::CreateGroupRsp* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void CreateGroup(::grpc::ClientContext* context, const ::resource::CreateGroupRqst* request, ::resource::CreateGroupRsp* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void CreateGroup(::grpc::ClientContext* context, const ::resource::CreateGroupRqst* request, ::resource::CreateGroupRsp* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // * Return the list of groups 
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetGroups(::grpc::ClientContext* context, ::resource::GetGroupsRqst* request, ::grpc::ClientReadReactor< ::resource::GetGroupsRsp>* reactor) = 0;
      #else
      virtual void GetGroups(::grpc::ClientContext* context, ::resource::GetGroupsRqst* request, ::grpc::experimental::ClientReadReactor< ::resource::GetGroupsRsp>* reactor) = 0;
      #endif
      // * Delete group 
      virtual void DeleteGroup(::grpc::ClientContext* context, const ::resource::DeleteGroupRqst* request, ::resource::DeleteGroupRsp* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void DeleteGroup(::grpc::ClientContext* context, const ::resource::DeleteGroupRqst* request, ::resource::DeleteGroupRsp* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void DeleteGroup(::grpc::ClientContext* context, const ::resource::DeleteGroupRqst* request, ::resource::DeleteGroupRsp* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // * Add a member account to the group *
      virtual void AddGroupMemberAccount(::grpc::ClientContext* context, const ::resource::AddGroupMemberAccountRqst* request, ::resource::AddGroupMemberAccountRsp* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void AddGroupMemberAccount(::grpc::ClientContext* context, const ::resource::AddGroupMemberAccountRqst* request, ::resource::AddGroupMemberAccountRsp* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void AddGroupMemberAccount(::grpc::ClientContext* context, const ::resource::AddGroupMemberAccountRqst* request, ::resource::AddGroupMemberAccountRsp* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // * Remove member account from the group *
      virtual void RemoveGroupMemberAccount(::grpc::ClientContext* context, const ::resource::RemoveGroupMemberAccountRqst* request, ::resource::RemoveGroupMemberAccountRsp* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void RemoveGroupMemberAccount(::grpc::ClientContext* context, const ::resource::RemoveGroupMemberAccountRqst* request, ::resource::RemoveGroupMemberAccountRsp* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void RemoveGroupMemberAccount(::grpc::ClientContext* context, const ::resource::RemoveGroupMemberAccountRqst* request, ::resource::RemoveGroupMemberAccountRsp* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // //////////////////////////////////////////////////////////////////////////
      // Account's
      // //////////////////////////////////////////////////////////////////////////
      //
      // * Register a new Account *
      virtual void RegisterAccount(::grpc::ClientContext* context, const ::resource::RegisterAccountRqst* request, ::resource::RegisterAccountRsp* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void RegisterAccount(::grpc::ClientContext* context, const ::resource::RegisterAccountRqst* request, ::resource::RegisterAccountRsp* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void RegisterAccount(::grpc::ClientContext* context, const ::resource::RegisterAccountRqst* request, ::resource::RegisterAccountRsp* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // * Delete an account *
      virtual void DeleteAccount(::grpc::ClientContext* context, const ::resource::DeleteAccountRqst* request, ::resource::DeleteAccountRsp* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void DeleteAccount(::grpc::ClientContext* context, const ::resource::DeleteAccountRqst* request, ::resource::DeleteAccountRsp* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void DeleteAccount(::grpc::ClientContext* context, const ::resource::DeleteAccountRqst* request, ::resource::DeleteAccountRsp* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // * Add role to a given account *
      virtual void AddAccountRole(::grpc::ClientContext* context, const ::resource::AddAccountRoleRqst* request, ::resource::AddAccountRoleRsp* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void AddAccountRole(::grpc::ClientContext* context, const ::resource::AddAccountRoleRqst* request, ::resource::AddAccountRoleRsp* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void AddAccountRole(::grpc::ClientContext* context, const ::resource::AddAccountRoleRqst* request, ::resource::AddAccountRoleRsp* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // * Remove a role from a given account *
      virtual void RemoveAccountRole(::grpc::ClientContext* context, const ::resource::RemoveAccountRoleRqst* request, ::resource::RemoveAccountRoleRsp* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void RemoveAccountRole(::grpc::ClientContext* context, const ::resource::RemoveAccountRoleRqst* request, ::resource::RemoveAccountRoleRsp* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void RemoveAccountRole(::grpc::ClientContext* context, const ::resource::RemoveAccountRoleRqst* request, ::resource::RemoveAccountRoleRsp* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // //////////////////////////////////////////////////////////////////////////
      // Action's control objects
      // //////////////////////////////////////////////////////////////////////////
      //
      // //////////////////////////////////////////////////////////////////////////
      // Role's
      // //////////////////////////////////////////////////////////////////////////
      //
      // * Create a role with given action list *
      virtual void CreateRole(::grpc::ClientContext* context, const ::resource::CreateRoleRqst* request, ::resource::CreateRoleRsp* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void CreateRole(::grpc::ClientContext* context, const ::resource::CreateRoleRqst* request, ::resource::CreateRoleRsp* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void CreateRole(::grpc::ClientContext* context, const ::resource::CreateRoleRqst* request, ::resource::CreateRoleRsp* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // * Delete a role with a given id *
      virtual void DeleteRole(::grpc::ClientContext* context, const ::resource::DeleteRoleRqst* request, ::resource::DeleteRoleRsp* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void DeleteRole(::grpc::ClientContext* context, const ::resource::DeleteRoleRqst* request, ::resource::DeleteRoleRsp* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void DeleteRole(::grpc::ClientContext* context, const ::resource::DeleteRoleRqst* request, ::resource::DeleteRoleRsp* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // * Append an action to existing role. *
      virtual void AddRoleAction(::grpc::ClientContext* context, const ::resource::AddRoleActionRqst* request, ::resource::AddRoleActionRsp* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void AddRoleAction(::grpc::ClientContext* context, const ::resource::AddRoleActionRqst* request, ::resource::AddRoleActionRsp* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void AddRoleAction(::grpc::ClientContext* context, const ::resource::AddRoleActionRqst* request, ::resource::AddRoleActionRsp* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // * Remove an action to existing role. *
      virtual void RemoveRoleAction(::grpc::ClientContext* context, const ::resource::RemoveRoleActionRqst* request, ::resource::RemoveRoleActionRsp* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void RemoveRoleAction(::grpc::ClientContext* context, const ::resource::RemoveRoleActionRqst* request, ::resource::RemoveRoleActionRsp* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void RemoveRoleAction(::grpc::ClientContext* context, const ::resource::RemoveRoleActionRqst* request, ::resource::RemoveRoleActionRsp* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // //////////////////////////////////////////////////////////////////////////
      // Application's
      // //////////////////////////////////////////////////////////////////////////
      //
      // * Return a json string with all applications informations *
      virtual void GetAllApplicationsInfo(::grpc::ClientContext* context, const ::resource::GetAllApplicationsInfoRqst* request, ::resource::GetAllApplicationsInfoRsp* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetAllApplicationsInfo(::grpc::ClientContext* context, const ::resource::GetAllApplicationsInfoRqst* request, ::resource::GetAllApplicationsInfoRsp* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetAllApplicationsInfo(::grpc::ClientContext* context, const ::resource::GetAllApplicationsInfoRqst* request, ::resource::GetAllApplicationsInfoRsp* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // * Delete an application from the server. *
      virtual void DeleteApplication(::grpc::ClientContext* context, const ::resource::DeleteApplicationRqst* request, ::resource::DeleteApplicationRsp* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void DeleteApplication(::grpc::ClientContext* context, const ::resource::DeleteApplicationRqst* request, ::resource::DeleteApplicationRsp* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void DeleteApplication(::grpc::ClientContext* context, const ::resource::DeleteApplicationRqst* request, ::resource::DeleteApplicationRsp* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // * Append an action to existing applications. *
      virtual void AddApplicationAction(::grpc::ClientContext* context, const ::resource::AddApplicationActionRqst* request, ::resource::AddApplicationActionRsp* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void AddApplicationAction(::grpc::ClientContext* context, const ::resource::AddApplicationActionRqst* request, ::resource::AddApplicationActionRsp* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void AddApplicationAction(::grpc::ClientContext* context, const ::resource::AddApplicationActionRqst* request, ::resource::AddApplicationActionRsp* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // * Remove an action to existing applications. *
      virtual void RemoveApplicationAction(::grpc::ClientContext* context, const ::resource::RemoveApplicationActionRqst* request, ::resource::RemoveApplicationActionRsp* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void RemoveApplicationAction(::grpc::ClientContext* context, const ::resource::RemoveApplicationActionRqst* request, ::resource::RemoveApplicationActionRsp* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void RemoveApplicationAction(::grpc::ClientContext* context, const ::resource::RemoveApplicationActionRqst* request, ::resource::RemoveApplicationActionRsp* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // //////////////////////////////////////////////////////////////////////////
      // Peer's
      // //////////////////////////////////////////////////////////////////////////
      //
      // * Register a peer on the network *
      virtual void RegisterPeer(::grpc::ClientContext* context, const ::resource::RegisterPeerRqst* request, ::resource::RegisterPeerRsp* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void RegisterPeer(::grpc::ClientContext* context, const ::resource::RegisterPeerRqst* request, ::resource::RegisterPeerRsp* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void RegisterPeer(::grpc::ClientContext* context, const ::resource::RegisterPeerRqst* request, ::resource::RegisterPeerRsp* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // * Return the list of peers *
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetPeers(::grpc::ClientContext* context, ::resource::GetPeersRqst* request, ::grpc::ClientReadReactor< ::resource::GetPeersRsp>* reactor) = 0;
      #else
      virtual void GetPeers(::grpc::ClientContext* context, ::resource::GetPeersRqst* request, ::grpc::experimental::ClientReadReactor< ::resource::GetPeersRsp>* reactor) = 0;
      #endif
      // * Remove a peer from the network *
      virtual void DeletePeer(::grpc::ClientContext* context, const ::resource::DeletePeerRqst* request, ::resource::DeletePeerRsp* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void DeletePeer(::grpc::ClientContext* context, const ::resource::DeletePeerRqst* request, ::resource::DeletePeerRsp* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void DeletePeer(::grpc::ClientContext* context, const ::resource::DeletePeerRqst* request, ::resource::DeletePeerRsp* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // * Add peer action permission *
      virtual void AddPeerAction(::grpc::ClientContext* context, const ::resource::AddPeerActionRqst* request, ::resource::AddPeerActionRsp* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void AddPeerAction(::grpc::ClientContext* context, const ::resource::AddPeerActionRqst* request, ::resource::AddPeerActionRsp* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void AddPeerAction(::grpc::ClientContext* context, const ::resource::AddPeerActionRqst* request, ::resource::AddPeerActionRsp* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // * Remove peer action permission *
      virtual void RemovePeerAction(::grpc::ClientContext* context, const ::resource::RemovePeerActionRqst* request, ::resource::RemovePeerActionRsp* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void RemovePeerAction(::grpc::ClientContext* context, const ::resource::RemovePeerActionRqst* request, ::resource::RemovePeerActionRsp* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void RemovePeerAction(::grpc::ClientContext* context, const ::resource::RemovePeerActionRqst* request, ::resource::RemovePeerActionRsp* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
    };
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    typedef class experimental_async_interface async_interface;
    #endif
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    async_interface* async() { return experimental_async(); }
    #endif
    virtual class experimental_async_interface* experimental_async() { return nullptr; }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::resource::GetAllActionsRsp>* AsyncGetAllActionsRaw(::grpc::ClientContext* context, const ::resource::GetAllActionsRqst& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::resource::GetAllActionsRsp>* PrepareAsyncGetAllActionsRaw(::grpc::ClientContext* context, const ::resource::GetAllActionsRqst& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::resource::ValidateTokenRsp>* AsyncValidateTokenRaw(::grpc::ClientContext* context, const ::resource::ValidateTokenRqst& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::resource::ValidateTokenRsp>* PrepareAsyncValidateTokenRaw(::grpc::ClientContext* context, const ::resource::ValidateTokenRqst& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::resource::RefreshTokenRsp>* AsyncRefreshTokenRaw(::grpc::ClientContext* context, const ::resource::RefreshTokenRqst& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::resource::RefreshTokenRsp>* PrepareAsyncRefreshTokenRaw(::grpc::ClientContext* context, const ::resource::RefreshTokenRqst& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::resource::AuthenticateRsp>* AsyncAuthenticateRaw(::grpc::ClientContext* context, const ::resource::AuthenticateRqst& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::resource::AuthenticateRsp>* PrepareAsyncAuthenticateRaw(::grpc::ClientContext* context, const ::resource::AuthenticateRqst& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::resource::SynchronizeLdapRsp>* AsyncSynchronizeLdapRaw(::grpc::ClientContext* context, const ::resource::SynchronizeLdapRqst& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::resource::SynchronizeLdapRsp>* PrepareAsyncSynchronizeLdapRaw(::grpc::ClientContext* context, const ::resource::SynchronizeLdapRqst& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::resource::CreateOrganizationRsp>* AsyncCreateOrganizationRaw(::grpc::ClientContext* context, const ::resource::CreateOrganizationRqst& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::resource::CreateOrganizationRsp>* PrepareAsyncCreateOrganizationRaw(::grpc::ClientContext* context, const ::resource::CreateOrganizationRqst& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::resource::GetOrganizationsRsp>* GetOrganizationsRaw(::grpc::ClientContext* context, const ::resource::GetOrganizationsRqst& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::resource::GetOrganizationsRsp>* AsyncGetOrganizationsRaw(::grpc::ClientContext* context, const ::resource::GetOrganizationsRqst& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::resource::GetOrganizationsRsp>* PrepareAsyncGetOrganizationsRaw(::grpc::ClientContext* context, const ::resource::GetOrganizationsRqst& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::resource::DeleteOrganizationRsp>* AsyncDeleteOrganizationRaw(::grpc::ClientContext* context, const ::resource::DeleteOrganizationRqst& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::resource::DeleteOrganizationRsp>* PrepareAsyncDeleteOrganizationRaw(::grpc::ClientContext* context, const ::resource::DeleteOrganizationRqst& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::resource::CreateGroupRsp>* AsyncCreateGroupRaw(::grpc::ClientContext* context, const ::resource::CreateGroupRqst& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::resource::CreateGroupRsp>* PrepareAsyncCreateGroupRaw(::grpc::ClientContext* context, const ::resource::CreateGroupRqst& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::resource::GetGroupsRsp>* GetGroupsRaw(::grpc::ClientContext* context, const ::resource::GetGroupsRqst& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::resource::GetGroupsRsp>* AsyncGetGroupsRaw(::grpc::ClientContext* context, const ::resource::GetGroupsRqst& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::resource::GetGroupsRsp>* PrepareAsyncGetGroupsRaw(::grpc::ClientContext* context, const ::resource::GetGroupsRqst& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::resource::DeleteGroupRsp>* AsyncDeleteGroupRaw(::grpc::ClientContext* context, const ::resource::DeleteGroupRqst& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::resource::DeleteGroupRsp>* PrepareAsyncDeleteGroupRaw(::grpc::ClientContext* context, const ::resource::DeleteGroupRqst& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::resource::AddGroupMemberAccountRsp>* AsyncAddGroupMemberAccountRaw(::grpc::ClientContext* context, const ::resource::AddGroupMemberAccountRqst& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::resource::AddGroupMemberAccountRsp>* PrepareAsyncAddGroupMemberAccountRaw(::grpc::ClientContext* context, const ::resource::AddGroupMemberAccountRqst& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::resource::RemoveGroupMemberAccountRsp>* AsyncRemoveGroupMemberAccountRaw(::grpc::ClientContext* context, const ::resource::RemoveGroupMemberAccountRqst& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::resource::RemoveGroupMemberAccountRsp>* PrepareAsyncRemoveGroupMemberAccountRaw(::grpc::ClientContext* context, const ::resource::RemoveGroupMemberAccountRqst& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::resource::RegisterAccountRsp>* AsyncRegisterAccountRaw(::grpc::ClientContext* context, const ::resource::RegisterAccountRqst& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::resource::RegisterAccountRsp>* PrepareAsyncRegisterAccountRaw(::grpc::ClientContext* context, const ::resource::RegisterAccountRqst& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::resource::DeleteAccountRsp>* AsyncDeleteAccountRaw(::grpc::ClientContext* context, const ::resource::DeleteAccountRqst& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::resource::DeleteAccountRsp>* PrepareAsyncDeleteAccountRaw(::grpc::ClientContext* context, const ::resource::DeleteAccountRqst& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::resource::AddAccountRoleRsp>* AsyncAddAccountRoleRaw(::grpc::ClientContext* context, const ::resource::AddAccountRoleRqst& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::resource::AddAccountRoleRsp>* PrepareAsyncAddAccountRoleRaw(::grpc::ClientContext* context, const ::resource::AddAccountRoleRqst& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::resource::RemoveAccountRoleRsp>* AsyncRemoveAccountRoleRaw(::grpc::ClientContext* context, const ::resource::RemoveAccountRoleRqst& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::resource::RemoveAccountRoleRsp>* PrepareAsyncRemoveAccountRoleRaw(::grpc::ClientContext* context, const ::resource::RemoveAccountRoleRqst& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::resource::CreateRoleRsp>* AsyncCreateRoleRaw(::grpc::ClientContext* context, const ::resource::CreateRoleRqst& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::resource::CreateRoleRsp>* PrepareAsyncCreateRoleRaw(::grpc::ClientContext* context, const ::resource::CreateRoleRqst& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::resource::DeleteRoleRsp>* AsyncDeleteRoleRaw(::grpc::ClientContext* context, const ::resource::DeleteRoleRqst& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::resource::DeleteRoleRsp>* PrepareAsyncDeleteRoleRaw(::grpc::ClientContext* context, const ::resource::DeleteRoleRqst& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::resource::AddRoleActionRsp>* AsyncAddRoleActionRaw(::grpc::ClientContext* context, const ::resource::AddRoleActionRqst& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::resource::AddRoleActionRsp>* PrepareAsyncAddRoleActionRaw(::grpc::ClientContext* context, const ::resource::AddRoleActionRqst& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::resource::RemoveRoleActionRsp>* AsyncRemoveRoleActionRaw(::grpc::ClientContext* context, const ::resource::RemoveRoleActionRqst& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::resource::RemoveRoleActionRsp>* PrepareAsyncRemoveRoleActionRaw(::grpc::ClientContext* context, const ::resource::RemoveRoleActionRqst& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::resource::GetAllApplicationsInfoRsp>* AsyncGetAllApplicationsInfoRaw(::grpc::ClientContext* context, const ::resource::GetAllApplicationsInfoRqst& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::resource::GetAllApplicationsInfoRsp>* PrepareAsyncGetAllApplicationsInfoRaw(::grpc::ClientContext* context, const ::resource::GetAllApplicationsInfoRqst& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::resource::DeleteApplicationRsp>* AsyncDeleteApplicationRaw(::grpc::ClientContext* context, const ::resource::DeleteApplicationRqst& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::resource::DeleteApplicationRsp>* PrepareAsyncDeleteApplicationRaw(::grpc::ClientContext* context, const ::resource::DeleteApplicationRqst& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::resource::AddApplicationActionRsp>* AsyncAddApplicationActionRaw(::grpc::ClientContext* context, const ::resource::AddApplicationActionRqst& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::resource::AddApplicationActionRsp>* PrepareAsyncAddApplicationActionRaw(::grpc::ClientContext* context, const ::resource::AddApplicationActionRqst& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::resource::RemoveApplicationActionRsp>* AsyncRemoveApplicationActionRaw(::grpc::ClientContext* context, const ::resource::RemoveApplicationActionRqst& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::resource::RemoveApplicationActionRsp>* PrepareAsyncRemoveApplicationActionRaw(::grpc::ClientContext* context, const ::resource::RemoveApplicationActionRqst& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::resource::RegisterPeerRsp>* AsyncRegisterPeerRaw(::grpc::ClientContext* context, const ::resource::RegisterPeerRqst& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::resource::RegisterPeerRsp>* PrepareAsyncRegisterPeerRaw(::grpc::ClientContext* context, const ::resource::RegisterPeerRqst& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::resource::GetPeersRsp>* GetPeersRaw(::grpc::ClientContext* context, const ::resource::GetPeersRqst& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::resource::GetPeersRsp>* AsyncGetPeersRaw(::grpc::ClientContext* context, const ::resource::GetPeersRqst& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::resource::GetPeersRsp>* PrepareAsyncGetPeersRaw(::grpc::ClientContext* context, const ::resource::GetPeersRqst& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::resource::DeletePeerRsp>* AsyncDeletePeerRaw(::grpc::ClientContext* context, const ::resource::DeletePeerRqst& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::resource::DeletePeerRsp>* PrepareAsyncDeletePeerRaw(::grpc::ClientContext* context, const ::resource::DeletePeerRqst& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::resource::AddPeerActionRsp>* AsyncAddPeerActionRaw(::grpc::ClientContext* context, const ::resource::AddPeerActionRqst& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::resource::AddPeerActionRsp>* PrepareAsyncAddPeerActionRaw(::grpc::ClientContext* context, const ::resource::AddPeerActionRqst& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::resource::RemovePeerActionRsp>* AsyncRemovePeerActionRaw(::grpc::ClientContext* context, const ::resource::RemovePeerActionRqst& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::resource::RemovePeerActionRsp>* PrepareAsyncRemovePeerActionRaw(::grpc::ClientContext* context, const ::resource::RemovePeerActionRqst& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    ::grpc::Status GetAllActions(::grpc::ClientContext* context, const ::resource::GetAllActionsRqst& request, ::resource::GetAllActionsRsp* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::GetAllActionsRsp>> AsyncGetAllActions(::grpc::ClientContext* context, const ::resource::GetAllActionsRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::GetAllActionsRsp>>(AsyncGetAllActionsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::GetAllActionsRsp>> PrepareAsyncGetAllActions(::grpc::ClientContext* context, const ::resource::GetAllActionsRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::GetAllActionsRsp>>(PrepareAsyncGetAllActionsRaw(context, request, cq));
    }
    ::grpc::Status ValidateToken(::grpc::ClientContext* context, const ::resource::ValidateTokenRqst& request, ::resource::ValidateTokenRsp* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::ValidateTokenRsp>> AsyncValidateToken(::grpc::ClientContext* context, const ::resource::ValidateTokenRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::ValidateTokenRsp>>(AsyncValidateTokenRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::ValidateTokenRsp>> PrepareAsyncValidateToken(::grpc::ClientContext* context, const ::resource::ValidateTokenRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::ValidateTokenRsp>>(PrepareAsyncValidateTokenRaw(context, request, cq));
    }
    ::grpc::Status RefreshToken(::grpc::ClientContext* context, const ::resource::RefreshTokenRqst& request, ::resource::RefreshTokenRsp* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::RefreshTokenRsp>> AsyncRefreshToken(::grpc::ClientContext* context, const ::resource::RefreshTokenRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::RefreshTokenRsp>>(AsyncRefreshTokenRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::RefreshTokenRsp>> PrepareAsyncRefreshToken(::grpc::ClientContext* context, const ::resource::RefreshTokenRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::RefreshTokenRsp>>(PrepareAsyncRefreshTokenRaw(context, request, cq));
    }
    ::grpc::Status Authenticate(::grpc::ClientContext* context, const ::resource::AuthenticateRqst& request, ::resource::AuthenticateRsp* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::AuthenticateRsp>> AsyncAuthenticate(::grpc::ClientContext* context, const ::resource::AuthenticateRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::AuthenticateRsp>>(AsyncAuthenticateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::AuthenticateRsp>> PrepareAsyncAuthenticate(::grpc::ClientContext* context, const ::resource::AuthenticateRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::AuthenticateRsp>>(PrepareAsyncAuthenticateRaw(context, request, cq));
    }
    ::grpc::Status SynchronizeLdap(::grpc::ClientContext* context, const ::resource::SynchronizeLdapRqst& request, ::resource::SynchronizeLdapRsp* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::SynchronizeLdapRsp>> AsyncSynchronizeLdap(::grpc::ClientContext* context, const ::resource::SynchronizeLdapRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::SynchronizeLdapRsp>>(AsyncSynchronizeLdapRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::SynchronizeLdapRsp>> PrepareAsyncSynchronizeLdap(::grpc::ClientContext* context, const ::resource::SynchronizeLdapRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::SynchronizeLdapRsp>>(PrepareAsyncSynchronizeLdapRaw(context, request, cq));
    }
    ::grpc::Status CreateOrganization(::grpc::ClientContext* context, const ::resource::CreateOrganizationRqst& request, ::resource::CreateOrganizationRsp* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::CreateOrganizationRsp>> AsyncCreateOrganization(::grpc::ClientContext* context, const ::resource::CreateOrganizationRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::CreateOrganizationRsp>>(AsyncCreateOrganizationRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::CreateOrganizationRsp>> PrepareAsyncCreateOrganization(::grpc::ClientContext* context, const ::resource::CreateOrganizationRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::CreateOrganizationRsp>>(PrepareAsyncCreateOrganizationRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::resource::GetOrganizationsRsp>> GetOrganizations(::grpc::ClientContext* context, const ::resource::GetOrganizationsRqst& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::resource::GetOrganizationsRsp>>(GetOrganizationsRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::resource::GetOrganizationsRsp>> AsyncGetOrganizations(::grpc::ClientContext* context, const ::resource::GetOrganizationsRqst& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::resource::GetOrganizationsRsp>>(AsyncGetOrganizationsRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::resource::GetOrganizationsRsp>> PrepareAsyncGetOrganizations(::grpc::ClientContext* context, const ::resource::GetOrganizationsRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::resource::GetOrganizationsRsp>>(PrepareAsyncGetOrganizationsRaw(context, request, cq));
    }
    ::grpc::Status DeleteOrganization(::grpc::ClientContext* context, const ::resource::DeleteOrganizationRqst& request, ::resource::DeleteOrganizationRsp* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::DeleteOrganizationRsp>> AsyncDeleteOrganization(::grpc::ClientContext* context, const ::resource::DeleteOrganizationRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::DeleteOrganizationRsp>>(AsyncDeleteOrganizationRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::DeleteOrganizationRsp>> PrepareAsyncDeleteOrganization(::grpc::ClientContext* context, const ::resource::DeleteOrganizationRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::DeleteOrganizationRsp>>(PrepareAsyncDeleteOrganizationRaw(context, request, cq));
    }
    ::grpc::Status CreateGroup(::grpc::ClientContext* context, const ::resource::CreateGroupRqst& request, ::resource::CreateGroupRsp* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::CreateGroupRsp>> AsyncCreateGroup(::grpc::ClientContext* context, const ::resource::CreateGroupRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::CreateGroupRsp>>(AsyncCreateGroupRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::CreateGroupRsp>> PrepareAsyncCreateGroup(::grpc::ClientContext* context, const ::resource::CreateGroupRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::CreateGroupRsp>>(PrepareAsyncCreateGroupRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::resource::GetGroupsRsp>> GetGroups(::grpc::ClientContext* context, const ::resource::GetGroupsRqst& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::resource::GetGroupsRsp>>(GetGroupsRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::resource::GetGroupsRsp>> AsyncGetGroups(::grpc::ClientContext* context, const ::resource::GetGroupsRqst& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::resource::GetGroupsRsp>>(AsyncGetGroupsRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::resource::GetGroupsRsp>> PrepareAsyncGetGroups(::grpc::ClientContext* context, const ::resource::GetGroupsRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::resource::GetGroupsRsp>>(PrepareAsyncGetGroupsRaw(context, request, cq));
    }
    ::grpc::Status DeleteGroup(::grpc::ClientContext* context, const ::resource::DeleteGroupRqst& request, ::resource::DeleteGroupRsp* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::DeleteGroupRsp>> AsyncDeleteGroup(::grpc::ClientContext* context, const ::resource::DeleteGroupRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::DeleteGroupRsp>>(AsyncDeleteGroupRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::DeleteGroupRsp>> PrepareAsyncDeleteGroup(::grpc::ClientContext* context, const ::resource::DeleteGroupRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::DeleteGroupRsp>>(PrepareAsyncDeleteGroupRaw(context, request, cq));
    }
    ::grpc::Status AddGroupMemberAccount(::grpc::ClientContext* context, const ::resource::AddGroupMemberAccountRqst& request, ::resource::AddGroupMemberAccountRsp* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::AddGroupMemberAccountRsp>> AsyncAddGroupMemberAccount(::grpc::ClientContext* context, const ::resource::AddGroupMemberAccountRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::AddGroupMemberAccountRsp>>(AsyncAddGroupMemberAccountRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::AddGroupMemberAccountRsp>> PrepareAsyncAddGroupMemberAccount(::grpc::ClientContext* context, const ::resource::AddGroupMemberAccountRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::AddGroupMemberAccountRsp>>(PrepareAsyncAddGroupMemberAccountRaw(context, request, cq));
    }
    ::grpc::Status RemoveGroupMemberAccount(::grpc::ClientContext* context, const ::resource::RemoveGroupMemberAccountRqst& request, ::resource::RemoveGroupMemberAccountRsp* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::RemoveGroupMemberAccountRsp>> AsyncRemoveGroupMemberAccount(::grpc::ClientContext* context, const ::resource::RemoveGroupMemberAccountRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::RemoveGroupMemberAccountRsp>>(AsyncRemoveGroupMemberAccountRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::RemoveGroupMemberAccountRsp>> PrepareAsyncRemoveGroupMemberAccount(::grpc::ClientContext* context, const ::resource::RemoveGroupMemberAccountRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::RemoveGroupMemberAccountRsp>>(PrepareAsyncRemoveGroupMemberAccountRaw(context, request, cq));
    }
    ::grpc::Status RegisterAccount(::grpc::ClientContext* context, const ::resource::RegisterAccountRqst& request, ::resource::RegisterAccountRsp* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::RegisterAccountRsp>> AsyncRegisterAccount(::grpc::ClientContext* context, const ::resource::RegisterAccountRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::RegisterAccountRsp>>(AsyncRegisterAccountRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::RegisterAccountRsp>> PrepareAsyncRegisterAccount(::grpc::ClientContext* context, const ::resource::RegisterAccountRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::RegisterAccountRsp>>(PrepareAsyncRegisterAccountRaw(context, request, cq));
    }
    ::grpc::Status DeleteAccount(::grpc::ClientContext* context, const ::resource::DeleteAccountRqst& request, ::resource::DeleteAccountRsp* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::DeleteAccountRsp>> AsyncDeleteAccount(::grpc::ClientContext* context, const ::resource::DeleteAccountRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::DeleteAccountRsp>>(AsyncDeleteAccountRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::DeleteAccountRsp>> PrepareAsyncDeleteAccount(::grpc::ClientContext* context, const ::resource::DeleteAccountRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::DeleteAccountRsp>>(PrepareAsyncDeleteAccountRaw(context, request, cq));
    }
    ::grpc::Status AddAccountRole(::grpc::ClientContext* context, const ::resource::AddAccountRoleRqst& request, ::resource::AddAccountRoleRsp* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::AddAccountRoleRsp>> AsyncAddAccountRole(::grpc::ClientContext* context, const ::resource::AddAccountRoleRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::AddAccountRoleRsp>>(AsyncAddAccountRoleRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::AddAccountRoleRsp>> PrepareAsyncAddAccountRole(::grpc::ClientContext* context, const ::resource::AddAccountRoleRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::AddAccountRoleRsp>>(PrepareAsyncAddAccountRoleRaw(context, request, cq));
    }
    ::grpc::Status RemoveAccountRole(::grpc::ClientContext* context, const ::resource::RemoveAccountRoleRqst& request, ::resource::RemoveAccountRoleRsp* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::RemoveAccountRoleRsp>> AsyncRemoveAccountRole(::grpc::ClientContext* context, const ::resource::RemoveAccountRoleRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::RemoveAccountRoleRsp>>(AsyncRemoveAccountRoleRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::RemoveAccountRoleRsp>> PrepareAsyncRemoveAccountRole(::grpc::ClientContext* context, const ::resource::RemoveAccountRoleRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::RemoveAccountRoleRsp>>(PrepareAsyncRemoveAccountRoleRaw(context, request, cq));
    }
    ::grpc::Status CreateRole(::grpc::ClientContext* context, const ::resource::CreateRoleRqst& request, ::resource::CreateRoleRsp* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::CreateRoleRsp>> AsyncCreateRole(::grpc::ClientContext* context, const ::resource::CreateRoleRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::CreateRoleRsp>>(AsyncCreateRoleRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::CreateRoleRsp>> PrepareAsyncCreateRole(::grpc::ClientContext* context, const ::resource::CreateRoleRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::CreateRoleRsp>>(PrepareAsyncCreateRoleRaw(context, request, cq));
    }
    ::grpc::Status DeleteRole(::grpc::ClientContext* context, const ::resource::DeleteRoleRqst& request, ::resource::DeleteRoleRsp* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::DeleteRoleRsp>> AsyncDeleteRole(::grpc::ClientContext* context, const ::resource::DeleteRoleRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::DeleteRoleRsp>>(AsyncDeleteRoleRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::DeleteRoleRsp>> PrepareAsyncDeleteRole(::grpc::ClientContext* context, const ::resource::DeleteRoleRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::DeleteRoleRsp>>(PrepareAsyncDeleteRoleRaw(context, request, cq));
    }
    ::grpc::Status AddRoleAction(::grpc::ClientContext* context, const ::resource::AddRoleActionRqst& request, ::resource::AddRoleActionRsp* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::AddRoleActionRsp>> AsyncAddRoleAction(::grpc::ClientContext* context, const ::resource::AddRoleActionRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::AddRoleActionRsp>>(AsyncAddRoleActionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::AddRoleActionRsp>> PrepareAsyncAddRoleAction(::grpc::ClientContext* context, const ::resource::AddRoleActionRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::AddRoleActionRsp>>(PrepareAsyncAddRoleActionRaw(context, request, cq));
    }
    ::grpc::Status RemoveRoleAction(::grpc::ClientContext* context, const ::resource::RemoveRoleActionRqst& request, ::resource::RemoveRoleActionRsp* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::RemoveRoleActionRsp>> AsyncRemoveRoleAction(::grpc::ClientContext* context, const ::resource::RemoveRoleActionRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::RemoveRoleActionRsp>>(AsyncRemoveRoleActionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::RemoveRoleActionRsp>> PrepareAsyncRemoveRoleAction(::grpc::ClientContext* context, const ::resource::RemoveRoleActionRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::RemoveRoleActionRsp>>(PrepareAsyncRemoveRoleActionRaw(context, request, cq));
    }
    ::grpc::Status GetAllApplicationsInfo(::grpc::ClientContext* context, const ::resource::GetAllApplicationsInfoRqst& request, ::resource::GetAllApplicationsInfoRsp* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::GetAllApplicationsInfoRsp>> AsyncGetAllApplicationsInfo(::grpc::ClientContext* context, const ::resource::GetAllApplicationsInfoRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::GetAllApplicationsInfoRsp>>(AsyncGetAllApplicationsInfoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::GetAllApplicationsInfoRsp>> PrepareAsyncGetAllApplicationsInfo(::grpc::ClientContext* context, const ::resource::GetAllApplicationsInfoRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::GetAllApplicationsInfoRsp>>(PrepareAsyncGetAllApplicationsInfoRaw(context, request, cq));
    }
    ::grpc::Status DeleteApplication(::grpc::ClientContext* context, const ::resource::DeleteApplicationRqst& request, ::resource::DeleteApplicationRsp* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::DeleteApplicationRsp>> AsyncDeleteApplication(::grpc::ClientContext* context, const ::resource::DeleteApplicationRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::DeleteApplicationRsp>>(AsyncDeleteApplicationRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::DeleteApplicationRsp>> PrepareAsyncDeleteApplication(::grpc::ClientContext* context, const ::resource::DeleteApplicationRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::DeleteApplicationRsp>>(PrepareAsyncDeleteApplicationRaw(context, request, cq));
    }
    ::grpc::Status AddApplicationAction(::grpc::ClientContext* context, const ::resource::AddApplicationActionRqst& request, ::resource::AddApplicationActionRsp* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::AddApplicationActionRsp>> AsyncAddApplicationAction(::grpc::ClientContext* context, const ::resource::AddApplicationActionRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::AddApplicationActionRsp>>(AsyncAddApplicationActionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::AddApplicationActionRsp>> PrepareAsyncAddApplicationAction(::grpc::ClientContext* context, const ::resource::AddApplicationActionRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::AddApplicationActionRsp>>(PrepareAsyncAddApplicationActionRaw(context, request, cq));
    }
    ::grpc::Status RemoveApplicationAction(::grpc::ClientContext* context, const ::resource::RemoveApplicationActionRqst& request, ::resource::RemoveApplicationActionRsp* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::RemoveApplicationActionRsp>> AsyncRemoveApplicationAction(::grpc::ClientContext* context, const ::resource::RemoveApplicationActionRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::RemoveApplicationActionRsp>>(AsyncRemoveApplicationActionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::RemoveApplicationActionRsp>> PrepareAsyncRemoveApplicationAction(::grpc::ClientContext* context, const ::resource::RemoveApplicationActionRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::RemoveApplicationActionRsp>>(PrepareAsyncRemoveApplicationActionRaw(context, request, cq));
    }
    ::grpc::Status RegisterPeer(::grpc::ClientContext* context, const ::resource::RegisterPeerRqst& request, ::resource::RegisterPeerRsp* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::RegisterPeerRsp>> AsyncRegisterPeer(::grpc::ClientContext* context, const ::resource::RegisterPeerRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::RegisterPeerRsp>>(AsyncRegisterPeerRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::RegisterPeerRsp>> PrepareAsyncRegisterPeer(::grpc::ClientContext* context, const ::resource::RegisterPeerRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::RegisterPeerRsp>>(PrepareAsyncRegisterPeerRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::resource::GetPeersRsp>> GetPeers(::grpc::ClientContext* context, const ::resource::GetPeersRqst& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::resource::GetPeersRsp>>(GetPeersRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::resource::GetPeersRsp>> AsyncGetPeers(::grpc::ClientContext* context, const ::resource::GetPeersRqst& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::resource::GetPeersRsp>>(AsyncGetPeersRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::resource::GetPeersRsp>> PrepareAsyncGetPeers(::grpc::ClientContext* context, const ::resource::GetPeersRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::resource::GetPeersRsp>>(PrepareAsyncGetPeersRaw(context, request, cq));
    }
    ::grpc::Status DeletePeer(::grpc::ClientContext* context, const ::resource::DeletePeerRqst& request, ::resource::DeletePeerRsp* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::DeletePeerRsp>> AsyncDeletePeer(::grpc::ClientContext* context, const ::resource::DeletePeerRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::DeletePeerRsp>>(AsyncDeletePeerRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::DeletePeerRsp>> PrepareAsyncDeletePeer(::grpc::ClientContext* context, const ::resource::DeletePeerRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::DeletePeerRsp>>(PrepareAsyncDeletePeerRaw(context, request, cq));
    }
    ::grpc::Status AddPeerAction(::grpc::ClientContext* context, const ::resource::AddPeerActionRqst& request, ::resource::AddPeerActionRsp* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::AddPeerActionRsp>> AsyncAddPeerAction(::grpc::ClientContext* context, const ::resource::AddPeerActionRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::AddPeerActionRsp>>(AsyncAddPeerActionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::AddPeerActionRsp>> PrepareAsyncAddPeerAction(::grpc::ClientContext* context, const ::resource::AddPeerActionRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::AddPeerActionRsp>>(PrepareAsyncAddPeerActionRaw(context, request, cq));
    }
    ::grpc::Status RemovePeerAction(::grpc::ClientContext* context, const ::resource::RemovePeerActionRqst& request, ::resource::RemovePeerActionRsp* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::RemovePeerActionRsp>> AsyncRemovePeerAction(::grpc::ClientContext* context, const ::resource::RemovePeerActionRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::RemovePeerActionRsp>>(AsyncRemovePeerActionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::RemovePeerActionRsp>> PrepareAsyncRemovePeerAction(::grpc::ClientContext* context, const ::resource::RemovePeerActionRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::RemovePeerActionRsp>>(PrepareAsyncRemovePeerActionRaw(context, request, cq));
    }
    class experimental_async final :
      public StubInterface::experimental_async_interface {
     public:
      void GetAllActions(::grpc::ClientContext* context, const ::resource::GetAllActionsRqst* request, ::resource::GetAllActionsRsp* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetAllActions(::grpc::ClientContext* context, const ::resource::GetAllActionsRqst* request, ::resource::GetAllActionsRsp* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetAllActions(::grpc::ClientContext* context, const ::resource::GetAllActionsRqst* request, ::resource::GetAllActionsRsp* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void ValidateToken(::grpc::ClientContext* context, const ::resource::ValidateTokenRqst* request, ::resource::ValidateTokenRsp* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ValidateToken(::grpc::ClientContext* context, const ::resource::ValidateTokenRqst* request, ::resource::ValidateTokenRsp* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ValidateToken(::grpc::ClientContext* context, const ::resource::ValidateTokenRqst* request, ::resource::ValidateTokenRsp* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void RefreshToken(::grpc::ClientContext* context, const ::resource::RefreshTokenRqst* request, ::resource::RefreshTokenRsp* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void RefreshToken(::grpc::ClientContext* context, const ::resource::RefreshTokenRqst* request, ::resource::RefreshTokenRsp* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void RefreshToken(::grpc::ClientContext* context, const ::resource::RefreshTokenRqst* request, ::resource::RefreshTokenRsp* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void Authenticate(::grpc::ClientContext* context, const ::resource::AuthenticateRqst* request, ::resource::AuthenticateRsp* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void Authenticate(::grpc::ClientContext* context, const ::resource::AuthenticateRqst* request, ::resource::AuthenticateRsp* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void Authenticate(::grpc::ClientContext* context, const ::resource::AuthenticateRqst* request, ::resource::AuthenticateRsp* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void SynchronizeLdap(::grpc::ClientContext* context, const ::resource::SynchronizeLdapRqst* request, ::resource::SynchronizeLdapRsp* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void SynchronizeLdap(::grpc::ClientContext* context, const ::resource::SynchronizeLdapRqst* request, ::resource::SynchronizeLdapRsp* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void SynchronizeLdap(::grpc::ClientContext* context, const ::resource::SynchronizeLdapRqst* request, ::resource::SynchronizeLdapRsp* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void CreateOrganization(::grpc::ClientContext* context, const ::resource::CreateOrganizationRqst* request, ::resource::CreateOrganizationRsp* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void CreateOrganization(::grpc::ClientContext* context, const ::resource::CreateOrganizationRqst* request, ::resource::CreateOrganizationRsp* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void CreateOrganization(::grpc::ClientContext* context, const ::resource::CreateOrganizationRqst* request, ::resource::CreateOrganizationRsp* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetOrganizations(::grpc::ClientContext* context, ::resource::GetOrganizationsRqst* request, ::grpc::ClientReadReactor< ::resource::GetOrganizationsRsp>* reactor) override;
      #else
      void GetOrganizations(::grpc::ClientContext* context, ::resource::GetOrganizationsRqst* request, ::grpc::experimental::ClientReadReactor< ::resource::GetOrganizationsRsp>* reactor) override;
      #endif
      void DeleteOrganization(::grpc::ClientContext* context, const ::resource::DeleteOrganizationRqst* request, ::resource::DeleteOrganizationRsp* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void DeleteOrganization(::grpc::ClientContext* context, const ::resource::DeleteOrganizationRqst* request, ::resource::DeleteOrganizationRsp* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void DeleteOrganization(::grpc::ClientContext* context, const ::resource::DeleteOrganizationRqst* request, ::resource::DeleteOrganizationRsp* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void CreateGroup(::grpc::ClientContext* context, const ::resource::CreateGroupRqst* request, ::resource::CreateGroupRsp* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void CreateGroup(::grpc::ClientContext* context, const ::resource::CreateGroupRqst* request, ::resource::CreateGroupRsp* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void CreateGroup(::grpc::ClientContext* context, const ::resource::CreateGroupRqst* request, ::resource::CreateGroupRsp* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetGroups(::grpc::ClientContext* context, ::resource::GetGroupsRqst* request, ::grpc::ClientReadReactor< ::resource::GetGroupsRsp>* reactor) override;
      #else
      void GetGroups(::grpc::ClientContext* context, ::resource::GetGroupsRqst* request, ::grpc::experimental::ClientReadReactor< ::resource::GetGroupsRsp>* reactor) override;
      #endif
      void DeleteGroup(::grpc::ClientContext* context, const ::resource::DeleteGroupRqst* request, ::resource::DeleteGroupRsp* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void DeleteGroup(::grpc::ClientContext* context, const ::resource::DeleteGroupRqst* request, ::resource::DeleteGroupRsp* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void DeleteGroup(::grpc::ClientContext* context, const ::resource::DeleteGroupRqst* request, ::resource::DeleteGroupRsp* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void AddGroupMemberAccount(::grpc::ClientContext* context, const ::resource::AddGroupMemberAccountRqst* request, ::resource::AddGroupMemberAccountRsp* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void AddGroupMemberAccount(::grpc::ClientContext* context, const ::resource::AddGroupMemberAccountRqst* request, ::resource::AddGroupMemberAccountRsp* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void AddGroupMemberAccount(::grpc::ClientContext* context, const ::resource::AddGroupMemberAccountRqst* request, ::resource::AddGroupMemberAccountRsp* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void RemoveGroupMemberAccount(::grpc::ClientContext* context, const ::resource::RemoveGroupMemberAccountRqst* request, ::resource::RemoveGroupMemberAccountRsp* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void RemoveGroupMemberAccount(::grpc::ClientContext* context, const ::resource::RemoveGroupMemberAccountRqst* request, ::resource::RemoveGroupMemberAccountRsp* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void RemoveGroupMemberAccount(::grpc::ClientContext* context, const ::resource::RemoveGroupMemberAccountRqst* request, ::resource::RemoveGroupMemberAccountRsp* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void RegisterAccount(::grpc::ClientContext* context, const ::resource::RegisterAccountRqst* request, ::resource::RegisterAccountRsp* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void RegisterAccount(::grpc::ClientContext* context, const ::resource::RegisterAccountRqst* request, ::resource::RegisterAccountRsp* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void RegisterAccount(::grpc::ClientContext* context, const ::resource::RegisterAccountRqst* request, ::resource::RegisterAccountRsp* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void DeleteAccount(::grpc::ClientContext* context, const ::resource::DeleteAccountRqst* request, ::resource::DeleteAccountRsp* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void DeleteAccount(::grpc::ClientContext* context, const ::resource::DeleteAccountRqst* request, ::resource::DeleteAccountRsp* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void DeleteAccount(::grpc::ClientContext* context, const ::resource::DeleteAccountRqst* request, ::resource::DeleteAccountRsp* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void AddAccountRole(::grpc::ClientContext* context, const ::resource::AddAccountRoleRqst* request, ::resource::AddAccountRoleRsp* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void AddAccountRole(::grpc::ClientContext* context, const ::resource::AddAccountRoleRqst* request, ::resource::AddAccountRoleRsp* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void AddAccountRole(::grpc::ClientContext* context, const ::resource::AddAccountRoleRqst* request, ::resource::AddAccountRoleRsp* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void RemoveAccountRole(::grpc::ClientContext* context, const ::resource::RemoveAccountRoleRqst* request, ::resource::RemoveAccountRoleRsp* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void RemoveAccountRole(::grpc::ClientContext* context, const ::resource::RemoveAccountRoleRqst* request, ::resource::RemoveAccountRoleRsp* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void RemoveAccountRole(::grpc::ClientContext* context, const ::resource::RemoveAccountRoleRqst* request, ::resource::RemoveAccountRoleRsp* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void CreateRole(::grpc::ClientContext* context, const ::resource::CreateRoleRqst* request, ::resource::CreateRoleRsp* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void CreateRole(::grpc::ClientContext* context, const ::resource::CreateRoleRqst* request, ::resource::CreateRoleRsp* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void CreateRole(::grpc::ClientContext* context, const ::resource::CreateRoleRqst* request, ::resource::CreateRoleRsp* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void DeleteRole(::grpc::ClientContext* context, const ::resource::DeleteRoleRqst* request, ::resource::DeleteRoleRsp* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void DeleteRole(::grpc::ClientContext* context, const ::resource::DeleteRoleRqst* request, ::resource::DeleteRoleRsp* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void DeleteRole(::grpc::ClientContext* context, const ::resource::DeleteRoleRqst* request, ::resource::DeleteRoleRsp* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void AddRoleAction(::grpc::ClientContext* context, const ::resource::AddRoleActionRqst* request, ::resource::AddRoleActionRsp* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void AddRoleAction(::grpc::ClientContext* context, const ::resource::AddRoleActionRqst* request, ::resource::AddRoleActionRsp* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void AddRoleAction(::grpc::ClientContext* context, const ::resource::AddRoleActionRqst* request, ::resource::AddRoleActionRsp* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void RemoveRoleAction(::grpc::ClientContext* context, const ::resource::RemoveRoleActionRqst* request, ::resource::RemoveRoleActionRsp* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void RemoveRoleAction(::grpc::ClientContext* context, const ::resource::RemoveRoleActionRqst* request, ::resource::RemoveRoleActionRsp* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void RemoveRoleAction(::grpc::ClientContext* context, const ::resource::RemoveRoleActionRqst* request, ::resource::RemoveRoleActionRsp* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetAllApplicationsInfo(::grpc::ClientContext* context, const ::resource::GetAllApplicationsInfoRqst* request, ::resource::GetAllApplicationsInfoRsp* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetAllApplicationsInfo(::grpc::ClientContext* context, const ::resource::GetAllApplicationsInfoRqst* request, ::resource::GetAllApplicationsInfoRsp* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetAllApplicationsInfo(::grpc::ClientContext* context, const ::resource::GetAllApplicationsInfoRqst* request, ::resource::GetAllApplicationsInfoRsp* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void DeleteApplication(::grpc::ClientContext* context, const ::resource::DeleteApplicationRqst* request, ::resource::DeleteApplicationRsp* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void DeleteApplication(::grpc::ClientContext* context, const ::resource::DeleteApplicationRqst* request, ::resource::DeleteApplicationRsp* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void DeleteApplication(::grpc::ClientContext* context, const ::resource::DeleteApplicationRqst* request, ::resource::DeleteApplicationRsp* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void AddApplicationAction(::grpc::ClientContext* context, const ::resource::AddApplicationActionRqst* request, ::resource::AddApplicationActionRsp* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void AddApplicationAction(::grpc::ClientContext* context, const ::resource::AddApplicationActionRqst* request, ::resource::AddApplicationActionRsp* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void AddApplicationAction(::grpc::ClientContext* context, const ::resource::AddApplicationActionRqst* request, ::resource::AddApplicationActionRsp* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void RemoveApplicationAction(::grpc::ClientContext* context, const ::resource::RemoveApplicationActionRqst* request, ::resource::RemoveApplicationActionRsp* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void RemoveApplicationAction(::grpc::ClientContext* context, const ::resource::RemoveApplicationActionRqst* request, ::resource::RemoveApplicationActionRsp* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void RemoveApplicationAction(::grpc::ClientContext* context, const ::resource::RemoveApplicationActionRqst* request, ::resource::RemoveApplicationActionRsp* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void RegisterPeer(::grpc::ClientContext* context, const ::resource::RegisterPeerRqst* request, ::resource::RegisterPeerRsp* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void RegisterPeer(::grpc::ClientContext* context, const ::resource::RegisterPeerRqst* request, ::resource::RegisterPeerRsp* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void RegisterPeer(::grpc::ClientContext* context, const ::resource::RegisterPeerRqst* request, ::resource::RegisterPeerRsp* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetPeers(::grpc::ClientContext* context, ::resource::GetPeersRqst* request, ::grpc::ClientReadReactor< ::resource::GetPeersRsp>* reactor) override;
      #else
      void GetPeers(::grpc::ClientContext* context, ::resource::GetPeersRqst* request, ::grpc::experimental::ClientReadReactor< ::resource::GetPeersRsp>* reactor) override;
      #endif
      void DeletePeer(::grpc::ClientContext* context, const ::resource::DeletePeerRqst* request, ::resource::DeletePeerRsp* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void DeletePeer(::grpc::ClientContext* context, const ::resource::DeletePeerRqst* request, ::resource::DeletePeerRsp* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void DeletePeer(::grpc::ClientContext* context, const ::resource::DeletePeerRqst* request, ::resource::DeletePeerRsp* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void AddPeerAction(::grpc::ClientContext* context, const ::resource::AddPeerActionRqst* request, ::resource::AddPeerActionRsp* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void AddPeerAction(::grpc::ClientContext* context, const ::resource::AddPeerActionRqst* request, ::resource::AddPeerActionRsp* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void AddPeerAction(::grpc::ClientContext* context, const ::resource::AddPeerActionRqst* request, ::resource::AddPeerActionRsp* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void RemovePeerAction(::grpc::ClientContext* context, const ::resource::RemovePeerActionRqst* request, ::resource::RemovePeerActionRsp* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void RemovePeerAction(::grpc::ClientContext* context, const ::resource::RemovePeerActionRqst* request, ::resource::RemovePeerActionRsp* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void RemovePeerAction(::grpc::ClientContext* context, const ::resource::RemovePeerActionRqst* request, ::resource::RemovePeerActionRsp* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
     private:
      friend class Stub;
      explicit experimental_async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class experimental_async_interface* experimental_async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class experimental_async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::resource::GetAllActionsRsp>* AsyncGetAllActionsRaw(::grpc::ClientContext* context, const ::resource::GetAllActionsRqst& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::resource::GetAllActionsRsp>* PrepareAsyncGetAllActionsRaw(::grpc::ClientContext* context, const ::resource::GetAllActionsRqst& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::resource::ValidateTokenRsp>* AsyncValidateTokenRaw(::grpc::ClientContext* context, const ::resource::ValidateTokenRqst& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::resource::ValidateTokenRsp>* PrepareAsyncValidateTokenRaw(::grpc::ClientContext* context, const ::resource::ValidateTokenRqst& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::resource::RefreshTokenRsp>* AsyncRefreshTokenRaw(::grpc::ClientContext* context, const ::resource::RefreshTokenRqst& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::resource::RefreshTokenRsp>* PrepareAsyncRefreshTokenRaw(::grpc::ClientContext* context, const ::resource::RefreshTokenRqst& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::resource::AuthenticateRsp>* AsyncAuthenticateRaw(::grpc::ClientContext* context, const ::resource::AuthenticateRqst& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::resource::AuthenticateRsp>* PrepareAsyncAuthenticateRaw(::grpc::ClientContext* context, const ::resource::AuthenticateRqst& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::resource::SynchronizeLdapRsp>* AsyncSynchronizeLdapRaw(::grpc::ClientContext* context, const ::resource::SynchronizeLdapRqst& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::resource::SynchronizeLdapRsp>* PrepareAsyncSynchronizeLdapRaw(::grpc::ClientContext* context, const ::resource::SynchronizeLdapRqst& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::resource::CreateOrganizationRsp>* AsyncCreateOrganizationRaw(::grpc::ClientContext* context, const ::resource::CreateOrganizationRqst& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::resource::CreateOrganizationRsp>* PrepareAsyncCreateOrganizationRaw(::grpc::ClientContext* context, const ::resource::CreateOrganizationRqst& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::resource::GetOrganizationsRsp>* GetOrganizationsRaw(::grpc::ClientContext* context, const ::resource::GetOrganizationsRqst& request) override;
    ::grpc::ClientAsyncReader< ::resource::GetOrganizationsRsp>* AsyncGetOrganizationsRaw(::grpc::ClientContext* context, const ::resource::GetOrganizationsRqst& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::resource::GetOrganizationsRsp>* PrepareAsyncGetOrganizationsRaw(::grpc::ClientContext* context, const ::resource::GetOrganizationsRqst& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::resource::DeleteOrganizationRsp>* AsyncDeleteOrganizationRaw(::grpc::ClientContext* context, const ::resource::DeleteOrganizationRqst& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::resource::DeleteOrganizationRsp>* PrepareAsyncDeleteOrganizationRaw(::grpc::ClientContext* context, const ::resource::DeleteOrganizationRqst& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::resource::CreateGroupRsp>* AsyncCreateGroupRaw(::grpc::ClientContext* context, const ::resource::CreateGroupRqst& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::resource::CreateGroupRsp>* PrepareAsyncCreateGroupRaw(::grpc::ClientContext* context, const ::resource::CreateGroupRqst& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::resource::GetGroupsRsp>* GetGroupsRaw(::grpc::ClientContext* context, const ::resource::GetGroupsRqst& request) override;
    ::grpc::ClientAsyncReader< ::resource::GetGroupsRsp>* AsyncGetGroupsRaw(::grpc::ClientContext* context, const ::resource::GetGroupsRqst& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::resource::GetGroupsRsp>* PrepareAsyncGetGroupsRaw(::grpc::ClientContext* context, const ::resource::GetGroupsRqst& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::resource::DeleteGroupRsp>* AsyncDeleteGroupRaw(::grpc::ClientContext* context, const ::resource::DeleteGroupRqst& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::resource::DeleteGroupRsp>* PrepareAsyncDeleteGroupRaw(::grpc::ClientContext* context, const ::resource::DeleteGroupRqst& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::resource::AddGroupMemberAccountRsp>* AsyncAddGroupMemberAccountRaw(::grpc::ClientContext* context, const ::resource::AddGroupMemberAccountRqst& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::resource::AddGroupMemberAccountRsp>* PrepareAsyncAddGroupMemberAccountRaw(::grpc::ClientContext* context, const ::resource::AddGroupMemberAccountRqst& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::resource::RemoveGroupMemberAccountRsp>* AsyncRemoveGroupMemberAccountRaw(::grpc::ClientContext* context, const ::resource::RemoveGroupMemberAccountRqst& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::resource::RemoveGroupMemberAccountRsp>* PrepareAsyncRemoveGroupMemberAccountRaw(::grpc::ClientContext* context, const ::resource::RemoveGroupMemberAccountRqst& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::resource::RegisterAccountRsp>* AsyncRegisterAccountRaw(::grpc::ClientContext* context, const ::resource::RegisterAccountRqst& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::resource::RegisterAccountRsp>* PrepareAsyncRegisterAccountRaw(::grpc::ClientContext* context, const ::resource::RegisterAccountRqst& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::resource::DeleteAccountRsp>* AsyncDeleteAccountRaw(::grpc::ClientContext* context, const ::resource::DeleteAccountRqst& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::resource::DeleteAccountRsp>* PrepareAsyncDeleteAccountRaw(::grpc::ClientContext* context, const ::resource::DeleteAccountRqst& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::resource::AddAccountRoleRsp>* AsyncAddAccountRoleRaw(::grpc::ClientContext* context, const ::resource::AddAccountRoleRqst& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::resource::AddAccountRoleRsp>* PrepareAsyncAddAccountRoleRaw(::grpc::ClientContext* context, const ::resource::AddAccountRoleRqst& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::resource::RemoveAccountRoleRsp>* AsyncRemoveAccountRoleRaw(::grpc::ClientContext* context, const ::resource::RemoveAccountRoleRqst& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::resource::RemoveAccountRoleRsp>* PrepareAsyncRemoveAccountRoleRaw(::grpc::ClientContext* context, const ::resource::RemoveAccountRoleRqst& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::resource::CreateRoleRsp>* AsyncCreateRoleRaw(::grpc::ClientContext* context, const ::resource::CreateRoleRqst& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::resource::CreateRoleRsp>* PrepareAsyncCreateRoleRaw(::grpc::ClientContext* context, const ::resource::CreateRoleRqst& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::resource::DeleteRoleRsp>* AsyncDeleteRoleRaw(::grpc::ClientContext* context, const ::resource::DeleteRoleRqst& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::resource::DeleteRoleRsp>* PrepareAsyncDeleteRoleRaw(::grpc::ClientContext* context, const ::resource::DeleteRoleRqst& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::resource::AddRoleActionRsp>* AsyncAddRoleActionRaw(::grpc::ClientContext* context, const ::resource::AddRoleActionRqst& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::resource::AddRoleActionRsp>* PrepareAsyncAddRoleActionRaw(::grpc::ClientContext* context, const ::resource::AddRoleActionRqst& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::resource::RemoveRoleActionRsp>* AsyncRemoveRoleActionRaw(::grpc::ClientContext* context, const ::resource::RemoveRoleActionRqst& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::resource::RemoveRoleActionRsp>* PrepareAsyncRemoveRoleActionRaw(::grpc::ClientContext* context, const ::resource::RemoveRoleActionRqst& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::resource::GetAllApplicationsInfoRsp>* AsyncGetAllApplicationsInfoRaw(::grpc::ClientContext* context, const ::resource::GetAllApplicationsInfoRqst& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::resource::GetAllApplicationsInfoRsp>* PrepareAsyncGetAllApplicationsInfoRaw(::grpc::ClientContext* context, const ::resource::GetAllApplicationsInfoRqst& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::resource::DeleteApplicationRsp>* AsyncDeleteApplicationRaw(::grpc::ClientContext* context, const ::resource::DeleteApplicationRqst& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::resource::DeleteApplicationRsp>* PrepareAsyncDeleteApplicationRaw(::grpc::ClientContext* context, const ::resource::DeleteApplicationRqst& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::resource::AddApplicationActionRsp>* AsyncAddApplicationActionRaw(::grpc::ClientContext* context, const ::resource::AddApplicationActionRqst& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::resource::AddApplicationActionRsp>* PrepareAsyncAddApplicationActionRaw(::grpc::ClientContext* context, const ::resource::AddApplicationActionRqst& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::resource::RemoveApplicationActionRsp>* AsyncRemoveApplicationActionRaw(::grpc::ClientContext* context, const ::resource::RemoveApplicationActionRqst& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::resource::RemoveApplicationActionRsp>* PrepareAsyncRemoveApplicationActionRaw(::grpc::ClientContext* context, const ::resource::RemoveApplicationActionRqst& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::resource::RegisterPeerRsp>* AsyncRegisterPeerRaw(::grpc::ClientContext* context, const ::resource::RegisterPeerRqst& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::resource::RegisterPeerRsp>* PrepareAsyncRegisterPeerRaw(::grpc::ClientContext* context, const ::resource::RegisterPeerRqst& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::resource::GetPeersRsp>* GetPeersRaw(::grpc::ClientContext* context, const ::resource::GetPeersRqst& request) override;
    ::grpc::ClientAsyncReader< ::resource::GetPeersRsp>* AsyncGetPeersRaw(::grpc::ClientContext* context, const ::resource::GetPeersRqst& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::resource::GetPeersRsp>* PrepareAsyncGetPeersRaw(::grpc::ClientContext* context, const ::resource::GetPeersRqst& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::resource::DeletePeerRsp>* AsyncDeletePeerRaw(::grpc::ClientContext* context, const ::resource::DeletePeerRqst& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::resource::DeletePeerRsp>* PrepareAsyncDeletePeerRaw(::grpc::ClientContext* context, const ::resource::DeletePeerRqst& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::resource::AddPeerActionRsp>* AsyncAddPeerActionRaw(::grpc::ClientContext* context, const ::resource::AddPeerActionRqst& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::resource::AddPeerActionRsp>* PrepareAsyncAddPeerActionRaw(::grpc::ClientContext* context, const ::resource::AddPeerActionRqst& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::resource::RemovePeerActionRsp>* AsyncRemovePeerActionRaw(::grpc::ClientContext* context, const ::resource::RemovePeerActionRqst& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::resource::RemovePeerActionRsp>* PrepareAsyncRemovePeerActionRaw(::grpc::ClientContext* context, const ::resource::RemovePeerActionRqst& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_GetAllActions_;
    const ::grpc::internal::RpcMethod rpcmethod_ValidateToken_;
    const ::grpc::internal::RpcMethod rpcmethod_RefreshToken_;
    const ::grpc::internal::RpcMethod rpcmethod_Authenticate_;
    const ::grpc::internal::RpcMethod rpcmethod_SynchronizeLdap_;
    const ::grpc::internal::RpcMethod rpcmethod_CreateOrganization_;
    const ::grpc::internal::RpcMethod rpcmethod_GetOrganizations_;
    const ::grpc::internal::RpcMethod rpcmethod_DeleteOrganization_;
    const ::grpc::internal::RpcMethod rpcmethod_CreateGroup_;
    const ::grpc::internal::RpcMethod rpcmethod_GetGroups_;
    const ::grpc::internal::RpcMethod rpcmethod_DeleteGroup_;
    const ::grpc::internal::RpcMethod rpcmethod_AddGroupMemberAccount_;
    const ::grpc::internal::RpcMethod rpcmethod_RemoveGroupMemberAccount_;
    const ::grpc::internal::RpcMethod rpcmethod_RegisterAccount_;
    const ::grpc::internal::RpcMethod rpcmethod_DeleteAccount_;
    const ::grpc::internal::RpcMethod rpcmethod_AddAccountRole_;
    const ::grpc::internal::RpcMethod rpcmethod_RemoveAccountRole_;
    const ::grpc::internal::RpcMethod rpcmethod_CreateRole_;
    const ::grpc::internal::RpcMethod rpcmethod_DeleteRole_;
    const ::grpc::internal::RpcMethod rpcmethod_AddRoleAction_;
    const ::grpc::internal::RpcMethod rpcmethod_RemoveRoleAction_;
    const ::grpc::internal::RpcMethod rpcmethod_GetAllApplicationsInfo_;
    const ::grpc::internal::RpcMethod rpcmethod_DeleteApplication_;
    const ::grpc::internal::RpcMethod rpcmethod_AddApplicationAction_;
    const ::grpc::internal::RpcMethod rpcmethod_RemoveApplicationAction_;
    const ::grpc::internal::RpcMethod rpcmethod_RegisterPeer_;
    const ::grpc::internal::RpcMethod rpcmethod_GetPeers_;
    const ::grpc::internal::RpcMethod rpcmethod_DeletePeer_;
    const ::grpc::internal::RpcMethod rpcmethod_AddPeerAction_;
    const ::grpc::internal::RpcMethod rpcmethod_RemovePeerAction_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // * Return the list of all grpc methods *
    virtual ::grpc::Status GetAllActions(::grpc::ServerContext* context, const ::resource::GetAllActionsRqst* request, ::resource::GetAllActionsRsp* response);
    // * Validate a token *
    virtual ::grpc::Status ValidateToken(::grpc::ServerContext* context, const ::resource::ValidateTokenRqst* request, ::resource::ValidateTokenRsp* response);
    // * Refresh token get a new token *
    virtual ::grpc::Status RefreshToken(::grpc::ServerContext* context, const ::resource::RefreshTokenRqst* request, ::resource::RefreshTokenRsp* response);
    // //////////////////////////////////////////////////////////////////////////
    // Authentication
    // //////////////////////////////////////////////////////////////////////////
    //
    // * Authenticate a user *
    virtual ::grpc::Status Authenticate(::grpc::ServerContext* context, const ::resource::AuthenticateRqst* request, ::resource::AuthenticateRsp* response);
    // * Synchronize Resource with LDAP if connection exist *
    virtual ::grpc::Status SynchronizeLdap(::grpc::ServerContext* context, const ::resource::SynchronizeLdapRqst* request, ::resource::SynchronizeLdapRsp* response);
    // //////////////////////////////////////////////////////////////////////////
    // Resource's control objects
    // //////////////////////////////////////////////////////////////////////////
    //
    // //////////////////////////////////////////////////////////////////////////
    // Organization's
    // //////////////////////////////////////////////////////////////////////////
    //
    // * Register a new organization 
    virtual ::grpc::Status CreateOrganization(::grpc::ServerContext* context, const ::resource::CreateOrganizationRqst* request, ::resource::CreateOrganizationRsp* response);
    // * Return the list of organizations 
    virtual ::grpc::Status GetOrganizations(::grpc::ServerContext* context, const ::resource::GetOrganizationsRqst* request, ::grpc::ServerWriter< ::resource::GetOrganizationsRsp>* writer);
    // * Delete organization 
    virtual ::grpc::Status DeleteOrganization(::grpc::ServerContext* context, const ::resource::DeleteOrganizationRqst* request, ::resource::DeleteOrganizationRsp* response);
    // //////////////////////////////////////////////////////////////////////////
    // Group's
    // //////////////////////////////////////////////////////////////////////////
    //
    // * Register a new group 
    virtual ::grpc::Status CreateGroup(::grpc::ServerContext* context, const ::resource::CreateGroupRqst* request, ::resource::CreateGroupRsp* response);
    // * Return the list of groups 
    virtual ::grpc::Status GetGroups(::grpc::ServerContext* context, const ::resource::GetGroupsRqst* request, ::grpc::ServerWriter< ::resource::GetGroupsRsp>* writer);
    // * Delete group 
    virtual ::grpc::Status DeleteGroup(::grpc::ServerContext* context, const ::resource::DeleteGroupRqst* request, ::resource::DeleteGroupRsp* response);
    // * Add a member account to the group *
    virtual ::grpc::Status AddGroupMemberAccount(::grpc::ServerContext* context, const ::resource::AddGroupMemberAccountRqst* request, ::resource::AddGroupMemberAccountRsp* response);
    // * Remove member account from the group *
    virtual ::grpc::Status RemoveGroupMemberAccount(::grpc::ServerContext* context, const ::resource::RemoveGroupMemberAccountRqst* request, ::resource::RemoveGroupMemberAccountRsp* response);
    // //////////////////////////////////////////////////////////////////////////
    // Account's
    // //////////////////////////////////////////////////////////////////////////
    //
    // * Register a new Account *
    virtual ::grpc::Status RegisterAccount(::grpc::ServerContext* context, const ::resource::RegisterAccountRqst* request, ::resource::RegisterAccountRsp* response);
    // * Delete an account *
    virtual ::grpc::Status DeleteAccount(::grpc::ServerContext* context, const ::resource::DeleteAccountRqst* request, ::resource::DeleteAccountRsp* response);
    // * Add role to a given account *
    virtual ::grpc::Status AddAccountRole(::grpc::ServerContext* context, const ::resource::AddAccountRoleRqst* request, ::resource::AddAccountRoleRsp* response);
    // * Remove a role from a given account *
    virtual ::grpc::Status RemoveAccountRole(::grpc::ServerContext* context, const ::resource::RemoveAccountRoleRqst* request, ::resource::RemoveAccountRoleRsp* response);
    // //////////////////////////////////////////////////////////////////////////
    // Action's control objects
    // //////////////////////////////////////////////////////////////////////////
    //
    // //////////////////////////////////////////////////////////////////////////
    // Role's
    // //////////////////////////////////////////////////////////////////////////
    //
    // * Create a role with given action list *
    virtual ::grpc::Status CreateRole(::grpc::ServerContext* context, const ::resource::CreateRoleRqst* request, ::resource::CreateRoleRsp* response);
    // * Delete a role with a given id *
    virtual ::grpc::Status DeleteRole(::grpc::ServerContext* context, const ::resource::DeleteRoleRqst* request, ::resource::DeleteRoleRsp* response);
    // * Append an action to existing role. *
    virtual ::grpc::Status AddRoleAction(::grpc::ServerContext* context, const ::resource::AddRoleActionRqst* request, ::resource::AddRoleActionRsp* response);
    // * Remove an action to existing role. *
    virtual ::grpc::Status RemoveRoleAction(::grpc::ServerContext* context, const ::resource::RemoveRoleActionRqst* request, ::resource::RemoveRoleActionRsp* response);
    // //////////////////////////////////////////////////////////////////////////
    // Application's
    // //////////////////////////////////////////////////////////////////////////
    //
    // * Return a json string with all applications informations *
    virtual ::grpc::Status GetAllApplicationsInfo(::grpc::ServerContext* context, const ::resource::GetAllApplicationsInfoRqst* request, ::resource::GetAllApplicationsInfoRsp* response);
    // * Delete an application from the server. *
    virtual ::grpc::Status DeleteApplication(::grpc::ServerContext* context, const ::resource::DeleteApplicationRqst* request, ::resource::DeleteApplicationRsp* response);
    // * Append an action to existing applications. *
    virtual ::grpc::Status AddApplicationAction(::grpc::ServerContext* context, const ::resource::AddApplicationActionRqst* request, ::resource::AddApplicationActionRsp* response);
    // * Remove an action to existing applications. *
    virtual ::grpc::Status RemoveApplicationAction(::grpc::ServerContext* context, const ::resource::RemoveApplicationActionRqst* request, ::resource::RemoveApplicationActionRsp* response);
    // //////////////////////////////////////////////////////////////////////////
    // Peer's
    // //////////////////////////////////////////////////////////////////////////
    //
    // * Register a peer on the network *
    virtual ::grpc::Status RegisterPeer(::grpc::ServerContext* context, const ::resource::RegisterPeerRqst* request, ::resource::RegisterPeerRsp* response);
    // * Return the list of peers *
    virtual ::grpc::Status GetPeers(::grpc::ServerContext* context, const ::resource::GetPeersRqst* request, ::grpc::ServerWriter< ::resource::GetPeersRsp>* writer);
    // * Remove a peer from the network *
    virtual ::grpc::Status DeletePeer(::grpc::ServerContext* context, const ::resource::DeletePeerRqst* request, ::resource::DeletePeerRsp* response);
    // * Add peer action permission *
    virtual ::grpc::Status AddPeerAction(::grpc::ServerContext* context, const ::resource::AddPeerActionRqst* request, ::resource::AddPeerActionRsp* response);
    // * Remove peer action permission *
    virtual ::grpc::Status RemovePeerAction(::grpc::ServerContext* context, const ::resource::RemovePeerActionRqst* request, ::resource::RemovePeerActionRsp* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_GetAllActions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetAllActions() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_GetAllActions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAllActions(::grpc::ServerContext* /*context*/, const ::resource::GetAllActionsRqst* /*request*/, ::resource::GetAllActionsRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetAllActions(::grpc::ServerContext* context, ::resource::GetAllActionsRqst* request, ::grpc::ServerAsyncResponseWriter< ::resource::GetAllActionsRsp>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ValidateToken : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ValidateToken() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_ValidateToken() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ValidateToken(::grpc::ServerContext* /*context*/, const ::resource::ValidateTokenRqst* /*request*/, ::resource::ValidateTokenRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestValidateToken(::grpc::ServerContext* context, ::resource::ValidateTokenRqst* request, ::grpc::ServerAsyncResponseWriter< ::resource::ValidateTokenRsp>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_RefreshToken : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_RefreshToken() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_RefreshToken() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RefreshToken(::grpc::ServerContext* /*context*/, const ::resource::RefreshTokenRqst* /*request*/, ::resource::RefreshTokenRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRefreshToken(::grpc::ServerContext* context, ::resource::RefreshTokenRqst* request, ::grpc::ServerAsyncResponseWriter< ::resource::RefreshTokenRsp>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Authenticate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Authenticate() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_Authenticate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Authenticate(::grpc::ServerContext* /*context*/, const ::resource::AuthenticateRqst* /*request*/, ::resource::AuthenticateRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAuthenticate(::grpc::ServerContext* context, ::resource::AuthenticateRqst* request, ::grpc::ServerAsyncResponseWriter< ::resource::AuthenticateRsp>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SynchronizeLdap : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SynchronizeLdap() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_SynchronizeLdap() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SynchronizeLdap(::grpc::ServerContext* /*context*/, const ::resource::SynchronizeLdapRqst* /*request*/, ::resource::SynchronizeLdapRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSynchronizeLdap(::grpc::ServerContext* context, ::resource::SynchronizeLdapRqst* request, ::grpc::ServerAsyncResponseWriter< ::resource::SynchronizeLdapRsp>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_CreateOrganization : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_CreateOrganization() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_CreateOrganization() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateOrganization(::grpc::ServerContext* /*context*/, const ::resource::CreateOrganizationRqst* /*request*/, ::resource::CreateOrganizationRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCreateOrganization(::grpc::ServerContext* context, ::resource::CreateOrganizationRqst* request, ::grpc::ServerAsyncResponseWriter< ::resource::CreateOrganizationRsp>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetOrganizations : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetOrganizations() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_GetOrganizations() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetOrganizations(::grpc::ServerContext* /*context*/, const ::resource::GetOrganizationsRqst* /*request*/, ::grpc::ServerWriter< ::resource::GetOrganizationsRsp>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetOrganizations(::grpc::ServerContext* context, ::resource::GetOrganizationsRqst* request, ::grpc::ServerAsyncWriter< ::resource::GetOrganizationsRsp>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(6, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DeleteOrganization : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_DeleteOrganization() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_DeleteOrganization() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteOrganization(::grpc::ServerContext* /*context*/, const ::resource::DeleteOrganizationRqst* /*request*/, ::resource::DeleteOrganizationRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteOrganization(::grpc::ServerContext* context, ::resource::DeleteOrganizationRqst* request, ::grpc::ServerAsyncResponseWriter< ::resource::DeleteOrganizationRsp>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_CreateGroup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_CreateGroup() {
      ::grpc::Service::MarkMethodAsync(8);
    }
    ~WithAsyncMethod_CreateGroup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateGroup(::grpc::ServerContext* /*context*/, const ::resource::CreateGroupRqst* /*request*/, ::resource::CreateGroupRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCreateGroup(::grpc::ServerContext* context, ::resource::CreateGroupRqst* request, ::grpc::ServerAsyncResponseWriter< ::resource::CreateGroupRsp>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetGroups : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetGroups() {
      ::grpc::Service::MarkMethodAsync(9);
    }
    ~WithAsyncMethod_GetGroups() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetGroups(::grpc::ServerContext* /*context*/, const ::resource::GetGroupsRqst* /*request*/, ::grpc::ServerWriter< ::resource::GetGroupsRsp>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetGroups(::grpc::ServerContext* context, ::resource::GetGroupsRqst* request, ::grpc::ServerAsyncWriter< ::resource::GetGroupsRsp>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(9, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DeleteGroup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_DeleteGroup() {
      ::grpc::Service::MarkMethodAsync(10);
    }
    ~WithAsyncMethod_DeleteGroup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteGroup(::grpc::ServerContext* /*context*/, const ::resource::DeleteGroupRqst* /*request*/, ::resource::DeleteGroupRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteGroup(::grpc::ServerContext* context, ::resource::DeleteGroupRqst* request, ::grpc::ServerAsyncResponseWriter< ::resource::DeleteGroupRsp>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_AddGroupMemberAccount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_AddGroupMemberAccount() {
      ::grpc::Service::MarkMethodAsync(11);
    }
    ~WithAsyncMethod_AddGroupMemberAccount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AddGroupMemberAccount(::grpc::ServerContext* /*context*/, const ::resource::AddGroupMemberAccountRqst* /*request*/, ::resource::AddGroupMemberAccountRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAddGroupMemberAccount(::grpc::ServerContext* context, ::resource::AddGroupMemberAccountRqst* request, ::grpc::ServerAsyncResponseWriter< ::resource::AddGroupMemberAccountRsp>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_RemoveGroupMemberAccount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_RemoveGroupMemberAccount() {
      ::grpc::Service::MarkMethodAsync(12);
    }
    ~WithAsyncMethod_RemoveGroupMemberAccount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RemoveGroupMemberAccount(::grpc::ServerContext* /*context*/, const ::resource::RemoveGroupMemberAccountRqst* /*request*/, ::resource::RemoveGroupMemberAccountRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRemoveGroupMemberAccount(::grpc::ServerContext* context, ::resource::RemoveGroupMemberAccountRqst* request, ::grpc::ServerAsyncResponseWriter< ::resource::RemoveGroupMemberAccountRsp>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_RegisterAccount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_RegisterAccount() {
      ::grpc::Service::MarkMethodAsync(13);
    }
    ~WithAsyncMethod_RegisterAccount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RegisterAccount(::grpc::ServerContext* /*context*/, const ::resource::RegisterAccountRqst* /*request*/, ::resource::RegisterAccountRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRegisterAccount(::grpc::ServerContext* context, ::resource::RegisterAccountRqst* request, ::grpc::ServerAsyncResponseWriter< ::resource::RegisterAccountRsp>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DeleteAccount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_DeleteAccount() {
      ::grpc::Service::MarkMethodAsync(14);
    }
    ~WithAsyncMethod_DeleteAccount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteAccount(::grpc::ServerContext* /*context*/, const ::resource::DeleteAccountRqst* /*request*/, ::resource::DeleteAccountRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteAccount(::grpc::ServerContext* context, ::resource::DeleteAccountRqst* request, ::grpc::ServerAsyncResponseWriter< ::resource::DeleteAccountRsp>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_AddAccountRole : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_AddAccountRole() {
      ::grpc::Service::MarkMethodAsync(15);
    }
    ~WithAsyncMethod_AddAccountRole() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AddAccountRole(::grpc::ServerContext* /*context*/, const ::resource::AddAccountRoleRqst* /*request*/, ::resource::AddAccountRoleRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAddAccountRole(::grpc::ServerContext* context, ::resource::AddAccountRoleRqst* request, ::grpc::ServerAsyncResponseWriter< ::resource::AddAccountRoleRsp>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_RemoveAccountRole : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_RemoveAccountRole() {
      ::grpc::Service::MarkMethodAsync(16);
    }
    ~WithAsyncMethod_RemoveAccountRole() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RemoveAccountRole(::grpc::ServerContext* /*context*/, const ::resource::RemoveAccountRoleRqst* /*request*/, ::resource::RemoveAccountRoleRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRemoveAccountRole(::grpc::ServerContext* context, ::resource::RemoveAccountRoleRqst* request, ::grpc::ServerAsyncResponseWriter< ::resource::RemoveAccountRoleRsp>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(16, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_CreateRole : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_CreateRole() {
      ::grpc::Service::MarkMethodAsync(17);
    }
    ~WithAsyncMethod_CreateRole() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateRole(::grpc::ServerContext* /*context*/, const ::resource::CreateRoleRqst* /*request*/, ::resource::CreateRoleRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCreateRole(::grpc::ServerContext* context, ::resource::CreateRoleRqst* request, ::grpc::ServerAsyncResponseWriter< ::resource::CreateRoleRsp>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(17, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DeleteRole : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_DeleteRole() {
      ::grpc::Service::MarkMethodAsync(18);
    }
    ~WithAsyncMethod_DeleteRole() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteRole(::grpc::ServerContext* /*context*/, const ::resource::DeleteRoleRqst* /*request*/, ::resource::DeleteRoleRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteRole(::grpc::ServerContext* context, ::resource::DeleteRoleRqst* request, ::grpc::ServerAsyncResponseWriter< ::resource::DeleteRoleRsp>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(18, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_AddRoleAction : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_AddRoleAction() {
      ::grpc::Service::MarkMethodAsync(19);
    }
    ~WithAsyncMethod_AddRoleAction() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AddRoleAction(::grpc::ServerContext* /*context*/, const ::resource::AddRoleActionRqst* /*request*/, ::resource::AddRoleActionRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAddRoleAction(::grpc::ServerContext* context, ::resource::AddRoleActionRqst* request, ::grpc::ServerAsyncResponseWriter< ::resource::AddRoleActionRsp>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(19, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_RemoveRoleAction : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_RemoveRoleAction() {
      ::grpc::Service::MarkMethodAsync(20);
    }
    ~WithAsyncMethod_RemoveRoleAction() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RemoveRoleAction(::grpc::ServerContext* /*context*/, const ::resource::RemoveRoleActionRqst* /*request*/, ::resource::RemoveRoleActionRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRemoveRoleAction(::grpc::ServerContext* context, ::resource::RemoveRoleActionRqst* request, ::grpc::ServerAsyncResponseWriter< ::resource::RemoveRoleActionRsp>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(20, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetAllApplicationsInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetAllApplicationsInfo() {
      ::grpc::Service::MarkMethodAsync(21);
    }
    ~WithAsyncMethod_GetAllApplicationsInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAllApplicationsInfo(::grpc::ServerContext* /*context*/, const ::resource::GetAllApplicationsInfoRqst* /*request*/, ::resource::GetAllApplicationsInfoRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetAllApplicationsInfo(::grpc::ServerContext* context, ::resource::GetAllApplicationsInfoRqst* request, ::grpc::ServerAsyncResponseWriter< ::resource::GetAllApplicationsInfoRsp>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(21, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DeleteApplication : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_DeleteApplication() {
      ::grpc::Service::MarkMethodAsync(22);
    }
    ~WithAsyncMethod_DeleteApplication() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteApplication(::grpc::ServerContext* /*context*/, const ::resource::DeleteApplicationRqst* /*request*/, ::resource::DeleteApplicationRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteApplication(::grpc::ServerContext* context, ::resource::DeleteApplicationRqst* request, ::grpc::ServerAsyncResponseWriter< ::resource::DeleteApplicationRsp>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(22, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_AddApplicationAction : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_AddApplicationAction() {
      ::grpc::Service::MarkMethodAsync(23);
    }
    ~WithAsyncMethod_AddApplicationAction() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AddApplicationAction(::grpc::ServerContext* /*context*/, const ::resource::AddApplicationActionRqst* /*request*/, ::resource::AddApplicationActionRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAddApplicationAction(::grpc::ServerContext* context, ::resource::AddApplicationActionRqst* request, ::grpc::ServerAsyncResponseWriter< ::resource::AddApplicationActionRsp>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(23, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_RemoveApplicationAction : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_RemoveApplicationAction() {
      ::grpc::Service::MarkMethodAsync(24);
    }
    ~WithAsyncMethod_RemoveApplicationAction() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RemoveApplicationAction(::grpc::ServerContext* /*context*/, const ::resource::RemoveApplicationActionRqst* /*request*/, ::resource::RemoveApplicationActionRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRemoveApplicationAction(::grpc::ServerContext* context, ::resource::RemoveApplicationActionRqst* request, ::grpc::ServerAsyncResponseWriter< ::resource::RemoveApplicationActionRsp>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(24, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_RegisterPeer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_RegisterPeer() {
      ::grpc::Service::MarkMethodAsync(25);
    }
    ~WithAsyncMethod_RegisterPeer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RegisterPeer(::grpc::ServerContext* /*context*/, const ::resource::RegisterPeerRqst* /*request*/, ::resource::RegisterPeerRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRegisterPeer(::grpc::ServerContext* context, ::resource::RegisterPeerRqst* request, ::grpc::ServerAsyncResponseWriter< ::resource::RegisterPeerRsp>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(25, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetPeers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetPeers() {
      ::grpc::Service::MarkMethodAsync(26);
    }
    ~WithAsyncMethod_GetPeers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPeers(::grpc::ServerContext* /*context*/, const ::resource::GetPeersRqst* /*request*/, ::grpc::ServerWriter< ::resource::GetPeersRsp>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetPeers(::grpc::ServerContext* context, ::resource::GetPeersRqst* request, ::grpc::ServerAsyncWriter< ::resource::GetPeersRsp>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(26, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DeletePeer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_DeletePeer() {
      ::grpc::Service::MarkMethodAsync(27);
    }
    ~WithAsyncMethod_DeletePeer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeletePeer(::grpc::ServerContext* /*context*/, const ::resource::DeletePeerRqst* /*request*/, ::resource::DeletePeerRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeletePeer(::grpc::ServerContext* context, ::resource::DeletePeerRqst* request, ::grpc::ServerAsyncResponseWriter< ::resource::DeletePeerRsp>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(27, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_AddPeerAction : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_AddPeerAction() {
      ::grpc::Service::MarkMethodAsync(28);
    }
    ~WithAsyncMethod_AddPeerAction() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AddPeerAction(::grpc::ServerContext* /*context*/, const ::resource::AddPeerActionRqst* /*request*/, ::resource::AddPeerActionRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAddPeerAction(::grpc::ServerContext* context, ::resource::AddPeerActionRqst* request, ::grpc::ServerAsyncResponseWriter< ::resource::AddPeerActionRsp>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(28, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_RemovePeerAction : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_RemovePeerAction() {
      ::grpc::Service::MarkMethodAsync(29);
    }
    ~WithAsyncMethod_RemovePeerAction() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RemovePeerAction(::grpc::ServerContext* /*context*/, const ::resource::RemovePeerActionRqst* /*request*/, ::resource::RemovePeerActionRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRemovePeerAction(::grpc::ServerContext* context, ::resource::RemovePeerActionRqst* request, ::grpc::ServerAsyncResponseWriter< ::resource::RemovePeerActionRsp>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(29, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_GetAllActions<WithAsyncMethod_ValidateToken<WithAsyncMethod_RefreshToken<WithAsyncMethod_Authenticate<WithAsyncMethod_SynchronizeLdap<WithAsyncMethod_CreateOrganization<WithAsyncMethod_GetOrganizations<WithAsyncMethod_DeleteOrganization<WithAsyncMethod_CreateGroup<WithAsyncMethod_GetGroups<WithAsyncMethod_DeleteGroup<WithAsyncMethod_AddGroupMemberAccount<WithAsyncMethod_RemoveGroupMemberAccount<WithAsyncMethod_RegisterAccount<WithAsyncMethod_DeleteAccount<WithAsyncMethod_AddAccountRole<WithAsyncMethod_RemoveAccountRole<WithAsyncMethod_CreateRole<WithAsyncMethod_DeleteRole<WithAsyncMethod_AddRoleAction<WithAsyncMethod_RemoveRoleAction<WithAsyncMethod_GetAllApplicationsInfo<WithAsyncMethod_DeleteApplication<WithAsyncMethod_AddApplicationAction<WithAsyncMethod_RemoveApplicationAction<WithAsyncMethod_RegisterPeer<WithAsyncMethod_GetPeers<WithAsyncMethod_DeletePeer<WithAsyncMethod_AddPeerAction<WithAsyncMethod_RemovePeerAction<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > AsyncService;
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetAllActions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetAllActions() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::resource::GetAllActionsRqst, ::resource::GetAllActionsRsp>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::resource::GetAllActionsRqst* request, ::resource::GetAllActionsRsp* response) { return this->GetAllActions(context, request, response); }));}
    void SetMessageAllocatorFor_GetAllActions(
        ::grpc::experimental::MessageAllocator< ::resource::GetAllActionsRqst, ::resource::GetAllActionsRsp>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(0);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::resource::GetAllActionsRqst, ::resource::GetAllActionsRsp>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetAllActions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAllActions(::grpc::ServerContext* /*context*/, const ::resource::GetAllActionsRqst* /*request*/, ::resource::GetAllActionsRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetAllActions(
      ::grpc::CallbackServerContext* /*context*/, const ::resource::GetAllActionsRqst* /*request*/, ::resource::GetAllActionsRsp* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetAllActions(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::resource::GetAllActionsRqst* /*request*/, ::resource::GetAllActionsRsp* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ValidateToken : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ValidateToken() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::resource::ValidateTokenRqst, ::resource::ValidateTokenRsp>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::resource::ValidateTokenRqst* request, ::resource::ValidateTokenRsp* response) { return this->ValidateToken(context, request, response); }));}
    void SetMessageAllocatorFor_ValidateToken(
        ::grpc::experimental::MessageAllocator< ::resource::ValidateTokenRqst, ::resource::ValidateTokenRsp>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(1);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::resource::ValidateTokenRqst, ::resource::ValidateTokenRsp>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ValidateToken() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ValidateToken(::grpc::ServerContext* /*context*/, const ::resource::ValidateTokenRqst* /*request*/, ::resource::ValidateTokenRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ValidateToken(
      ::grpc::CallbackServerContext* /*context*/, const ::resource::ValidateTokenRqst* /*request*/, ::resource::ValidateTokenRsp* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ValidateToken(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::resource::ValidateTokenRqst* /*request*/, ::resource::ValidateTokenRsp* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_RefreshToken : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_RefreshToken() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::resource::RefreshTokenRqst, ::resource::RefreshTokenRsp>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::resource::RefreshTokenRqst* request, ::resource::RefreshTokenRsp* response) { return this->RefreshToken(context, request, response); }));}
    void SetMessageAllocatorFor_RefreshToken(
        ::grpc::experimental::MessageAllocator< ::resource::RefreshTokenRqst, ::resource::RefreshTokenRsp>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(2);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::resource::RefreshTokenRqst, ::resource::RefreshTokenRsp>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_RefreshToken() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RefreshToken(::grpc::ServerContext* /*context*/, const ::resource::RefreshTokenRqst* /*request*/, ::resource::RefreshTokenRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* RefreshToken(
      ::grpc::CallbackServerContext* /*context*/, const ::resource::RefreshTokenRqst* /*request*/, ::resource::RefreshTokenRsp* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* RefreshToken(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::resource::RefreshTokenRqst* /*request*/, ::resource::RefreshTokenRsp* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_Authenticate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_Authenticate() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::resource::AuthenticateRqst, ::resource::AuthenticateRsp>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::resource::AuthenticateRqst* request, ::resource::AuthenticateRsp* response) { return this->Authenticate(context, request, response); }));}
    void SetMessageAllocatorFor_Authenticate(
        ::grpc::experimental::MessageAllocator< ::resource::AuthenticateRqst, ::resource::AuthenticateRsp>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(3);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::resource::AuthenticateRqst, ::resource::AuthenticateRsp>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_Authenticate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Authenticate(::grpc::ServerContext* /*context*/, const ::resource::AuthenticateRqst* /*request*/, ::resource::AuthenticateRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Authenticate(
      ::grpc::CallbackServerContext* /*context*/, const ::resource::AuthenticateRqst* /*request*/, ::resource::AuthenticateRsp* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Authenticate(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::resource::AuthenticateRqst* /*request*/, ::resource::AuthenticateRsp* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SynchronizeLdap : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_SynchronizeLdap() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::resource::SynchronizeLdapRqst, ::resource::SynchronizeLdapRsp>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::resource::SynchronizeLdapRqst* request, ::resource::SynchronizeLdapRsp* response) { return this->SynchronizeLdap(context, request, response); }));}
    void SetMessageAllocatorFor_SynchronizeLdap(
        ::grpc::experimental::MessageAllocator< ::resource::SynchronizeLdapRqst, ::resource::SynchronizeLdapRsp>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(4);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::resource::SynchronizeLdapRqst, ::resource::SynchronizeLdapRsp>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_SynchronizeLdap() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SynchronizeLdap(::grpc::ServerContext* /*context*/, const ::resource::SynchronizeLdapRqst* /*request*/, ::resource::SynchronizeLdapRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* SynchronizeLdap(
      ::grpc::CallbackServerContext* /*context*/, const ::resource::SynchronizeLdapRqst* /*request*/, ::resource::SynchronizeLdapRsp* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* SynchronizeLdap(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::resource::SynchronizeLdapRqst* /*request*/, ::resource::SynchronizeLdapRsp* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_CreateOrganization : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_CreateOrganization() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::resource::CreateOrganizationRqst, ::resource::CreateOrganizationRsp>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::resource::CreateOrganizationRqst* request, ::resource::CreateOrganizationRsp* response) { return this->CreateOrganization(context, request, response); }));}
    void SetMessageAllocatorFor_CreateOrganization(
        ::grpc::experimental::MessageAllocator< ::resource::CreateOrganizationRqst, ::resource::CreateOrganizationRsp>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(5);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(5);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::resource::CreateOrganizationRqst, ::resource::CreateOrganizationRsp>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_CreateOrganization() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateOrganization(::grpc::ServerContext* /*context*/, const ::resource::CreateOrganizationRqst* /*request*/, ::resource::CreateOrganizationRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* CreateOrganization(
      ::grpc::CallbackServerContext* /*context*/, const ::resource::CreateOrganizationRqst* /*request*/, ::resource::CreateOrganizationRsp* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* CreateOrganization(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::resource::CreateOrganizationRqst* /*request*/, ::resource::CreateOrganizationRsp* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetOrganizations : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetOrganizations() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(6,
          new ::grpc::internal::CallbackServerStreamingHandler< ::resource::GetOrganizationsRqst, ::resource::GetOrganizationsRsp>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::resource::GetOrganizationsRqst* request) { return this->GetOrganizations(context, request); }));
    }
    ~ExperimentalWithCallbackMethod_GetOrganizations() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetOrganizations(::grpc::ServerContext* /*context*/, const ::resource::GetOrganizationsRqst* /*request*/, ::grpc::ServerWriter< ::resource::GetOrganizationsRsp>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::resource::GetOrganizationsRsp>* GetOrganizations(
      ::grpc::CallbackServerContext* /*context*/, const ::resource::GetOrganizationsRqst* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::resource::GetOrganizationsRsp>* GetOrganizations(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::resource::GetOrganizationsRqst* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_DeleteOrganization : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_DeleteOrganization() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::resource::DeleteOrganizationRqst, ::resource::DeleteOrganizationRsp>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::resource::DeleteOrganizationRqst* request, ::resource::DeleteOrganizationRsp* response) { return this->DeleteOrganization(context, request, response); }));}
    void SetMessageAllocatorFor_DeleteOrganization(
        ::grpc::experimental::MessageAllocator< ::resource::DeleteOrganizationRqst, ::resource::DeleteOrganizationRsp>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(7);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(7);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::resource::DeleteOrganizationRqst, ::resource::DeleteOrganizationRsp>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_DeleteOrganization() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteOrganization(::grpc::ServerContext* /*context*/, const ::resource::DeleteOrganizationRqst* /*request*/, ::resource::DeleteOrganizationRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DeleteOrganization(
      ::grpc::CallbackServerContext* /*context*/, const ::resource::DeleteOrganizationRqst* /*request*/, ::resource::DeleteOrganizationRsp* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DeleteOrganization(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::resource::DeleteOrganizationRqst* /*request*/, ::resource::DeleteOrganizationRsp* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_CreateGroup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_CreateGroup() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::resource::CreateGroupRqst, ::resource::CreateGroupRsp>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::resource::CreateGroupRqst* request, ::resource::CreateGroupRsp* response) { return this->CreateGroup(context, request, response); }));}
    void SetMessageAllocatorFor_CreateGroup(
        ::grpc::experimental::MessageAllocator< ::resource::CreateGroupRqst, ::resource::CreateGroupRsp>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(8);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(8);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::resource::CreateGroupRqst, ::resource::CreateGroupRsp>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_CreateGroup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateGroup(::grpc::ServerContext* /*context*/, const ::resource::CreateGroupRqst* /*request*/, ::resource::CreateGroupRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* CreateGroup(
      ::grpc::CallbackServerContext* /*context*/, const ::resource::CreateGroupRqst* /*request*/, ::resource::CreateGroupRsp* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* CreateGroup(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::resource::CreateGroupRqst* /*request*/, ::resource::CreateGroupRsp* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetGroups : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetGroups() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(9,
          new ::grpc::internal::CallbackServerStreamingHandler< ::resource::GetGroupsRqst, ::resource::GetGroupsRsp>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::resource::GetGroupsRqst* request) { return this->GetGroups(context, request); }));
    }
    ~ExperimentalWithCallbackMethod_GetGroups() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetGroups(::grpc::ServerContext* /*context*/, const ::resource::GetGroupsRqst* /*request*/, ::grpc::ServerWriter< ::resource::GetGroupsRsp>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::resource::GetGroupsRsp>* GetGroups(
      ::grpc::CallbackServerContext* /*context*/, const ::resource::GetGroupsRqst* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::resource::GetGroupsRsp>* GetGroups(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::resource::GetGroupsRqst* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_DeleteGroup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_DeleteGroup() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(10,
          new ::grpc::internal::CallbackUnaryHandler< ::resource::DeleteGroupRqst, ::resource::DeleteGroupRsp>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::resource::DeleteGroupRqst* request, ::resource::DeleteGroupRsp* response) { return this->DeleteGroup(context, request, response); }));}
    void SetMessageAllocatorFor_DeleteGroup(
        ::grpc::experimental::MessageAllocator< ::resource::DeleteGroupRqst, ::resource::DeleteGroupRsp>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(10);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(10);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::resource::DeleteGroupRqst, ::resource::DeleteGroupRsp>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_DeleteGroup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteGroup(::grpc::ServerContext* /*context*/, const ::resource::DeleteGroupRqst* /*request*/, ::resource::DeleteGroupRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DeleteGroup(
      ::grpc::CallbackServerContext* /*context*/, const ::resource::DeleteGroupRqst* /*request*/, ::resource::DeleteGroupRsp* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DeleteGroup(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::resource::DeleteGroupRqst* /*request*/, ::resource::DeleteGroupRsp* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_AddGroupMemberAccount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_AddGroupMemberAccount() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(11,
          new ::grpc::internal::CallbackUnaryHandler< ::resource::AddGroupMemberAccountRqst, ::resource::AddGroupMemberAccountRsp>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::resource::AddGroupMemberAccountRqst* request, ::resource::AddGroupMemberAccountRsp* response) { return this->AddGroupMemberAccount(context, request, response); }));}
    void SetMessageAllocatorFor_AddGroupMemberAccount(
        ::grpc::experimental::MessageAllocator< ::resource::AddGroupMemberAccountRqst, ::resource::AddGroupMemberAccountRsp>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(11);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(11);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::resource::AddGroupMemberAccountRqst, ::resource::AddGroupMemberAccountRsp>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_AddGroupMemberAccount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AddGroupMemberAccount(::grpc::ServerContext* /*context*/, const ::resource::AddGroupMemberAccountRqst* /*request*/, ::resource::AddGroupMemberAccountRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* AddGroupMemberAccount(
      ::grpc::CallbackServerContext* /*context*/, const ::resource::AddGroupMemberAccountRqst* /*request*/, ::resource::AddGroupMemberAccountRsp* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* AddGroupMemberAccount(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::resource::AddGroupMemberAccountRqst* /*request*/, ::resource::AddGroupMemberAccountRsp* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_RemoveGroupMemberAccount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_RemoveGroupMemberAccount() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(12,
          new ::grpc::internal::CallbackUnaryHandler< ::resource::RemoveGroupMemberAccountRqst, ::resource::RemoveGroupMemberAccountRsp>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::resource::RemoveGroupMemberAccountRqst* request, ::resource::RemoveGroupMemberAccountRsp* response) { return this->RemoveGroupMemberAccount(context, request, response); }));}
    void SetMessageAllocatorFor_RemoveGroupMemberAccount(
        ::grpc::experimental::MessageAllocator< ::resource::RemoveGroupMemberAccountRqst, ::resource::RemoveGroupMemberAccountRsp>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(12);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(12);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::resource::RemoveGroupMemberAccountRqst, ::resource::RemoveGroupMemberAccountRsp>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_RemoveGroupMemberAccount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RemoveGroupMemberAccount(::grpc::ServerContext* /*context*/, const ::resource::RemoveGroupMemberAccountRqst* /*request*/, ::resource::RemoveGroupMemberAccountRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* RemoveGroupMemberAccount(
      ::grpc::CallbackServerContext* /*context*/, const ::resource::RemoveGroupMemberAccountRqst* /*request*/, ::resource::RemoveGroupMemberAccountRsp* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* RemoveGroupMemberAccount(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::resource::RemoveGroupMemberAccountRqst* /*request*/, ::resource::RemoveGroupMemberAccountRsp* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_RegisterAccount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_RegisterAccount() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(13,
          new ::grpc::internal::CallbackUnaryHandler< ::resource::RegisterAccountRqst, ::resource::RegisterAccountRsp>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::resource::RegisterAccountRqst* request, ::resource::RegisterAccountRsp* response) { return this->RegisterAccount(context, request, response); }));}
    void SetMessageAllocatorFor_RegisterAccount(
        ::grpc::experimental::MessageAllocator< ::resource::RegisterAccountRqst, ::resource::RegisterAccountRsp>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(13);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(13);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::resource::RegisterAccountRqst, ::resource::RegisterAccountRsp>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_RegisterAccount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RegisterAccount(::grpc::ServerContext* /*context*/, const ::resource::RegisterAccountRqst* /*request*/, ::resource::RegisterAccountRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* RegisterAccount(
      ::grpc::CallbackServerContext* /*context*/, const ::resource::RegisterAccountRqst* /*request*/, ::resource::RegisterAccountRsp* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* RegisterAccount(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::resource::RegisterAccountRqst* /*request*/, ::resource::RegisterAccountRsp* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_DeleteAccount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_DeleteAccount() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(14,
          new ::grpc::internal::CallbackUnaryHandler< ::resource::DeleteAccountRqst, ::resource::DeleteAccountRsp>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::resource::DeleteAccountRqst* request, ::resource::DeleteAccountRsp* response) { return this->DeleteAccount(context, request, response); }));}
    void SetMessageAllocatorFor_DeleteAccount(
        ::grpc::experimental::MessageAllocator< ::resource::DeleteAccountRqst, ::resource::DeleteAccountRsp>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(14);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(14);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::resource::DeleteAccountRqst, ::resource::DeleteAccountRsp>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_DeleteAccount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteAccount(::grpc::ServerContext* /*context*/, const ::resource::DeleteAccountRqst* /*request*/, ::resource::DeleteAccountRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DeleteAccount(
      ::grpc::CallbackServerContext* /*context*/, const ::resource::DeleteAccountRqst* /*request*/, ::resource::DeleteAccountRsp* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DeleteAccount(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::resource::DeleteAccountRqst* /*request*/, ::resource::DeleteAccountRsp* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_AddAccountRole : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_AddAccountRole() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(15,
          new ::grpc::internal::CallbackUnaryHandler< ::resource::AddAccountRoleRqst, ::resource::AddAccountRoleRsp>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::resource::AddAccountRoleRqst* request, ::resource::AddAccountRoleRsp* response) { return this->AddAccountRole(context, request, response); }));}
    void SetMessageAllocatorFor_AddAccountRole(
        ::grpc::experimental::MessageAllocator< ::resource::AddAccountRoleRqst, ::resource::AddAccountRoleRsp>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(15);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(15);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::resource::AddAccountRoleRqst, ::resource::AddAccountRoleRsp>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_AddAccountRole() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AddAccountRole(::grpc::ServerContext* /*context*/, const ::resource::AddAccountRoleRqst* /*request*/, ::resource::AddAccountRoleRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* AddAccountRole(
      ::grpc::CallbackServerContext* /*context*/, const ::resource::AddAccountRoleRqst* /*request*/, ::resource::AddAccountRoleRsp* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* AddAccountRole(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::resource::AddAccountRoleRqst* /*request*/, ::resource::AddAccountRoleRsp* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_RemoveAccountRole : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_RemoveAccountRole() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(16,
          new ::grpc::internal::CallbackUnaryHandler< ::resource::RemoveAccountRoleRqst, ::resource::RemoveAccountRoleRsp>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::resource::RemoveAccountRoleRqst* request, ::resource::RemoveAccountRoleRsp* response) { return this->RemoveAccountRole(context, request, response); }));}
    void SetMessageAllocatorFor_RemoveAccountRole(
        ::grpc::experimental::MessageAllocator< ::resource::RemoveAccountRoleRqst, ::resource::RemoveAccountRoleRsp>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(16);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(16);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::resource::RemoveAccountRoleRqst, ::resource::RemoveAccountRoleRsp>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_RemoveAccountRole() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RemoveAccountRole(::grpc::ServerContext* /*context*/, const ::resource::RemoveAccountRoleRqst* /*request*/, ::resource::RemoveAccountRoleRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* RemoveAccountRole(
      ::grpc::CallbackServerContext* /*context*/, const ::resource::RemoveAccountRoleRqst* /*request*/, ::resource::RemoveAccountRoleRsp* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* RemoveAccountRole(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::resource::RemoveAccountRoleRqst* /*request*/, ::resource::RemoveAccountRoleRsp* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_CreateRole : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_CreateRole() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(17,
          new ::grpc::internal::CallbackUnaryHandler< ::resource::CreateRoleRqst, ::resource::CreateRoleRsp>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::resource::CreateRoleRqst* request, ::resource::CreateRoleRsp* response) { return this->CreateRole(context, request, response); }));}
    void SetMessageAllocatorFor_CreateRole(
        ::grpc::experimental::MessageAllocator< ::resource::CreateRoleRqst, ::resource::CreateRoleRsp>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(17);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(17);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::resource::CreateRoleRqst, ::resource::CreateRoleRsp>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_CreateRole() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateRole(::grpc::ServerContext* /*context*/, const ::resource::CreateRoleRqst* /*request*/, ::resource::CreateRoleRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* CreateRole(
      ::grpc::CallbackServerContext* /*context*/, const ::resource::CreateRoleRqst* /*request*/, ::resource::CreateRoleRsp* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* CreateRole(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::resource::CreateRoleRqst* /*request*/, ::resource::CreateRoleRsp* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_DeleteRole : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_DeleteRole() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(18,
          new ::grpc::internal::CallbackUnaryHandler< ::resource::DeleteRoleRqst, ::resource::DeleteRoleRsp>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::resource::DeleteRoleRqst* request, ::resource::DeleteRoleRsp* response) { return this->DeleteRole(context, request, response); }));}
    void SetMessageAllocatorFor_DeleteRole(
        ::grpc::experimental::MessageAllocator< ::resource::DeleteRoleRqst, ::resource::DeleteRoleRsp>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(18);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(18);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::resource::DeleteRoleRqst, ::resource::DeleteRoleRsp>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_DeleteRole() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteRole(::grpc::ServerContext* /*context*/, const ::resource::DeleteRoleRqst* /*request*/, ::resource::DeleteRoleRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DeleteRole(
      ::grpc::CallbackServerContext* /*context*/, const ::resource::DeleteRoleRqst* /*request*/, ::resource::DeleteRoleRsp* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DeleteRole(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::resource::DeleteRoleRqst* /*request*/, ::resource::DeleteRoleRsp* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_AddRoleAction : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_AddRoleAction() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(19,
          new ::grpc::internal::CallbackUnaryHandler< ::resource::AddRoleActionRqst, ::resource::AddRoleActionRsp>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::resource::AddRoleActionRqst* request, ::resource::AddRoleActionRsp* response) { return this->AddRoleAction(context, request, response); }));}
    void SetMessageAllocatorFor_AddRoleAction(
        ::grpc::experimental::MessageAllocator< ::resource::AddRoleActionRqst, ::resource::AddRoleActionRsp>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(19);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(19);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::resource::AddRoleActionRqst, ::resource::AddRoleActionRsp>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_AddRoleAction() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AddRoleAction(::grpc::ServerContext* /*context*/, const ::resource::AddRoleActionRqst* /*request*/, ::resource::AddRoleActionRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* AddRoleAction(
      ::grpc::CallbackServerContext* /*context*/, const ::resource::AddRoleActionRqst* /*request*/, ::resource::AddRoleActionRsp* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* AddRoleAction(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::resource::AddRoleActionRqst* /*request*/, ::resource::AddRoleActionRsp* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_RemoveRoleAction : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_RemoveRoleAction() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(20,
          new ::grpc::internal::CallbackUnaryHandler< ::resource::RemoveRoleActionRqst, ::resource::RemoveRoleActionRsp>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::resource::RemoveRoleActionRqst* request, ::resource::RemoveRoleActionRsp* response) { return this->RemoveRoleAction(context, request, response); }));}
    void SetMessageAllocatorFor_RemoveRoleAction(
        ::grpc::experimental::MessageAllocator< ::resource::RemoveRoleActionRqst, ::resource::RemoveRoleActionRsp>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(20);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(20);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::resource::RemoveRoleActionRqst, ::resource::RemoveRoleActionRsp>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_RemoveRoleAction() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RemoveRoleAction(::grpc::ServerContext* /*context*/, const ::resource::RemoveRoleActionRqst* /*request*/, ::resource::RemoveRoleActionRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* RemoveRoleAction(
      ::grpc::CallbackServerContext* /*context*/, const ::resource::RemoveRoleActionRqst* /*request*/, ::resource::RemoveRoleActionRsp* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* RemoveRoleAction(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::resource::RemoveRoleActionRqst* /*request*/, ::resource::RemoveRoleActionRsp* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetAllApplicationsInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetAllApplicationsInfo() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(21,
          new ::grpc::internal::CallbackUnaryHandler< ::resource::GetAllApplicationsInfoRqst, ::resource::GetAllApplicationsInfoRsp>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::resource::GetAllApplicationsInfoRqst* request, ::resource::GetAllApplicationsInfoRsp* response) { return this->GetAllApplicationsInfo(context, request, response); }));}
    void SetMessageAllocatorFor_GetAllApplicationsInfo(
        ::grpc::experimental::MessageAllocator< ::resource::GetAllApplicationsInfoRqst, ::resource::GetAllApplicationsInfoRsp>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(21);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(21);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::resource::GetAllApplicationsInfoRqst, ::resource::GetAllApplicationsInfoRsp>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetAllApplicationsInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAllApplicationsInfo(::grpc::ServerContext* /*context*/, const ::resource::GetAllApplicationsInfoRqst* /*request*/, ::resource::GetAllApplicationsInfoRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetAllApplicationsInfo(
      ::grpc::CallbackServerContext* /*context*/, const ::resource::GetAllApplicationsInfoRqst* /*request*/, ::resource::GetAllApplicationsInfoRsp* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetAllApplicationsInfo(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::resource::GetAllApplicationsInfoRqst* /*request*/, ::resource::GetAllApplicationsInfoRsp* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_DeleteApplication : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_DeleteApplication() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(22,
          new ::grpc::internal::CallbackUnaryHandler< ::resource::DeleteApplicationRqst, ::resource::DeleteApplicationRsp>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::resource::DeleteApplicationRqst* request, ::resource::DeleteApplicationRsp* response) { return this->DeleteApplication(context, request, response); }));}
    void SetMessageAllocatorFor_DeleteApplication(
        ::grpc::experimental::MessageAllocator< ::resource::DeleteApplicationRqst, ::resource::DeleteApplicationRsp>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(22);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(22);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::resource::DeleteApplicationRqst, ::resource::DeleteApplicationRsp>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_DeleteApplication() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteApplication(::grpc::ServerContext* /*context*/, const ::resource::DeleteApplicationRqst* /*request*/, ::resource::DeleteApplicationRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DeleteApplication(
      ::grpc::CallbackServerContext* /*context*/, const ::resource::DeleteApplicationRqst* /*request*/, ::resource::DeleteApplicationRsp* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DeleteApplication(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::resource::DeleteApplicationRqst* /*request*/, ::resource::DeleteApplicationRsp* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_AddApplicationAction : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_AddApplicationAction() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(23,
          new ::grpc::internal::CallbackUnaryHandler< ::resource::AddApplicationActionRqst, ::resource::AddApplicationActionRsp>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::resource::AddApplicationActionRqst* request, ::resource::AddApplicationActionRsp* response) { return this->AddApplicationAction(context, request, response); }));}
    void SetMessageAllocatorFor_AddApplicationAction(
        ::grpc::experimental::MessageAllocator< ::resource::AddApplicationActionRqst, ::resource::AddApplicationActionRsp>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(23);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(23);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::resource::AddApplicationActionRqst, ::resource::AddApplicationActionRsp>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_AddApplicationAction() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AddApplicationAction(::grpc::ServerContext* /*context*/, const ::resource::AddApplicationActionRqst* /*request*/, ::resource::AddApplicationActionRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* AddApplicationAction(
      ::grpc::CallbackServerContext* /*context*/, const ::resource::AddApplicationActionRqst* /*request*/, ::resource::AddApplicationActionRsp* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* AddApplicationAction(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::resource::AddApplicationActionRqst* /*request*/, ::resource::AddApplicationActionRsp* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_RemoveApplicationAction : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_RemoveApplicationAction() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(24,
          new ::grpc::internal::CallbackUnaryHandler< ::resource::RemoveApplicationActionRqst, ::resource::RemoveApplicationActionRsp>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::resource::RemoveApplicationActionRqst* request, ::resource::RemoveApplicationActionRsp* response) { return this->RemoveApplicationAction(context, request, response); }));}
    void SetMessageAllocatorFor_RemoveApplicationAction(
        ::grpc::experimental::MessageAllocator< ::resource::RemoveApplicationActionRqst, ::resource::RemoveApplicationActionRsp>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(24);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(24);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::resource::RemoveApplicationActionRqst, ::resource::RemoveApplicationActionRsp>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_RemoveApplicationAction() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RemoveApplicationAction(::grpc::ServerContext* /*context*/, const ::resource::RemoveApplicationActionRqst* /*request*/, ::resource::RemoveApplicationActionRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* RemoveApplicationAction(
      ::grpc::CallbackServerContext* /*context*/, const ::resource::RemoveApplicationActionRqst* /*request*/, ::resource::RemoveApplicationActionRsp* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* RemoveApplicationAction(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::resource::RemoveApplicationActionRqst* /*request*/, ::resource::RemoveApplicationActionRsp* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_RegisterPeer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_RegisterPeer() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(25,
          new ::grpc::internal::CallbackUnaryHandler< ::resource::RegisterPeerRqst, ::resource::RegisterPeerRsp>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::resource::RegisterPeerRqst* request, ::resource::RegisterPeerRsp* response) { return this->RegisterPeer(context, request, response); }));}
    void SetMessageAllocatorFor_RegisterPeer(
        ::grpc::experimental::MessageAllocator< ::resource::RegisterPeerRqst, ::resource::RegisterPeerRsp>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(25);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(25);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::resource::RegisterPeerRqst, ::resource::RegisterPeerRsp>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_RegisterPeer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RegisterPeer(::grpc::ServerContext* /*context*/, const ::resource::RegisterPeerRqst* /*request*/, ::resource::RegisterPeerRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* RegisterPeer(
      ::grpc::CallbackServerContext* /*context*/, const ::resource::RegisterPeerRqst* /*request*/, ::resource::RegisterPeerRsp* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* RegisterPeer(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::resource::RegisterPeerRqst* /*request*/, ::resource::RegisterPeerRsp* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetPeers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetPeers() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(26,
          new ::grpc::internal::CallbackServerStreamingHandler< ::resource::GetPeersRqst, ::resource::GetPeersRsp>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::resource::GetPeersRqst* request) { return this->GetPeers(context, request); }));
    }
    ~ExperimentalWithCallbackMethod_GetPeers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPeers(::grpc::ServerContext* /*context*/, const ::resource::GetPeersRqst* /*request*/, ::grpc::ServerWriter< ::resource::GetPeersRsp>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::resource::GetPeersRsp>* GetPeers(
      ::grpc::CallbackServerContext* /*context*/, const ::resource::GetPeersRqst* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::resource::GetPeersRsp>* GetPeers(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::resource::GetPeersRqst* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_DeletePeer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_DeletePeer() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(27,
          new ::grpc::internal::CallbackUnaryHandler< ::resource::DeletePeerRqst, ::resource::DeletePeerRsp>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::resource::DeletePeerRqst* request, ::resource::DeletePeerRsp* response) { return this->DeletePeer(context, request, response); }));}
    void SetMessageAllocatorFor_DeletePeer(
        ::grpc::experimental::MessageAllocator< ::resource::DeletePeerRqst, ::resource::DeletePeerRsp>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(27);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(27);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::resource::DeletePeerRqst, ::resource::DeletePeerRsp>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_DeletePeer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeletePeer(::grpc::ServerContext* /*context*/, const ::resource::DeletePeerRqst* /*request*/, ::resource::DeletePeerRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DeletePeer(
      ::grpc::CallbackServerContext* /*context*/, const ::resource::DeletePeerRqst* /*request*/, ::resource::DeletePeerRsp* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DeletePeer(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::resource::DeletePeerRqst* /*request*/, ::resource::DeletePeerRsp* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_AddPeerAction : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_AddPeerAction() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(28,
          new ::grpc::internal::CallbackUnaryHandler< ::resource::AddPeerActionRqst, ::resource::AddPeerActionRsp>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::resource::AddPeerActionRqst* request, ::resource::AddPeerActionRsp* response) { return this->AddPeerAction(context, request, response); }));}
    void SetMessageAllocatorFor_AddPeerAction(
        ::grpc::experimental::MessageAllocator< ::resource::AddPeerActionRqst, ::resource::AddPeerActionRsp>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(28);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(28);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::resource::AddPeerActionRqst, ::resource::AddPeerActionRsp>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_AddPeerAction() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AddPeerAction(::grpc::ServerContext* /*context*/, const ::resource::AddPeerActionRqst* /*request*/, ::resource::AddPeerActionRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* AddPeerAction(
      ::grpc::CallbackServerContext* /*context*/, const ::resource::AddPeerActionRqst* /*request*/, ::resource::AddPeerActionRsp* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* AddPeerAction(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::resource::AddPeerActionRqst* /*request*/, ::resource::AddPeerActionRsp* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_RemovePeerAction : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_RemovePeerAction() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(29,
          new ::grpc::internal::CallbackUnaryHandler< ::resource::RemovePeerActionRqst, ::resource::RemovePeerActionRsp>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::resource::RemovePeerActionRqst* request, ::resource::RemovePeerActionRsp* response) { return this->RemovePeerAction(context, request, response); }));}
    void SetMessageAllocatorFor_RemovePeerAction(
        ::grpc::experimental::MessageAllocator< ::resource::RemovePeerActionRqst, ::resource::RemovePeerActionRsp>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(29);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(29);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::resource::RemovePeerActionRqst, ::resource::RemovePeerActionRsp>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_RemovePeerAction() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RemovePeerAction(::grpc::ServerContext* /*context*/, const ::resource::RemovePeerActionRqst* /*request*/, ::resource::RemovePeerActionRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* RemovePeerAction(
      ::grpc::CallbackServerContext* /*context*/, const ::resource::RemovePeerActionRqst* /*request*/, ::resource::RemovePeerActionRsp* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* RemovePeerAction(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::resource::RemovePeerActionRqst* /*request*/, ::resource::RemovePeerActionRsp* /*response*/)
    #endif
      { return nullptr; }
  };
  #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
  typedef ExperimentalWithCallbackMethod_GetAllActions<ExperimentalWithCallbackMethod_ValidateToken<ExperimentalWithCallbackMethod_RefreshToken<ExperimentalWithCallbackMethod_Authenticate<ExperimentalWithCallbackMethod_SynchronizeLdap<ExperimentalWithCallbackMethod_CreateOrganization<ExperimentalWithCallbackMethod_GetOrganizations<ExperimentalWithCallbackMethod_DeleteOrganization<ExperimentalWithCallbackMethod_CreateGroup<ExperimentalWithCallbackMethod_GetGroups<ExperimentalWithCallbackMethod_DeleteGroup<ExperimentalWithCallbackMethod_AddGroupMemberAccount<ExperimentalWithCallbackMethod_RemoveGroupMemberAccount<ExperimentalWithCallbackMethod_RegisterAccount<ExperimentalWithCallbackMethod_DeleteAccount<ExperimentalWithCallbackMethod_AddAccountRole<ExperimentalWithCallbackMethod_RemoveAccountRole<ExperimentalWithCallbackMethod_CreateRole<ExperimentalWithCallbackMethod_DeleteRole<ExperimentalWithCallbackMethod_AddRoleAction<ExperimentalWithCallbackMethod_RemoveRoleAction<ExperimentalWithCallbackMethod_GetAllApplicationsInfo<ExperimentalWithCallbackMethod_DeleteApplication<ExperimentalWithCallbackMethod_AddApplicationAction<ExperimentalWithCallbackMethod_RemoveApplicationAction<ExperimentalWithCallbackMethod_RegisterPeer<ExperimentalWithCallbackMethod_GetPeers<ExperimentalWithCallbackMethod_DeletePeer<ExperimentalWithCallbackMethod_AddPeerAction<ExperimentalWithCallbackMethod_RemovePeerAction<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > CallbackService;
  #endif

  typedef ExperimentalWithCallbackMethod_GetAllActions<ExperimentalWithCallbackMethod_ValidateToken<ExperimentalWithCallbackMethod_RefreshToken<ExperimentalWithCallbackMethod_Authenticate<ExperimentalWithCallbackMethod_SynchronizeLdap<ExperimentalWithCallbackMethod_CreateOrganization<ExperimentalWithCallbackMethod_GetOrganizations<ExperimentalWithCallbackMethod_DeleteOrganization<ExperimentalWithCallbackMethod_CreateGroup<ExperimentalWithCallbackMethod_GetGroups<ExperimentalWithCallbackMethod_DeleteGroup<ExperimentalWithCallbackMethod_AddGroupMemberAccount<ExperimentalWithCallbackMethod_RemoveGroupMemberAccount<ExperimentalWithCallbackMethod_RegisterAccount<ExperimentalWithCallbackMethod_DeleteAccount<ExperimentalWithCallbackMethod_AddAccountRole<ExperimentalWithCallbackMethod_RemoveAccountRole<ExperimentalWithCallbackMethod_CreateRole<ExperimentalWithCallbackMethod_DeleteRole<ExperimentalWithCallbackMethod_AddRoleAction<ExperimentalWithCallbackMethod_RemoveRoleAction<ExperimentalWithCallbackMethod_GetAllApplicationsInfo<ExperimentalWithCallbackMethod_DeleteApplication<ExperimentalWithCallbackMethod_AddApplicationAction<ExperimentalWithCallbackMethod_RemoveApplicationAction<ExperimentalWithCallbackMethod_RegisterPeer<ExperimentalWithCallbackMethod_GetPeers<ExperimentalWithCallbackMethod_DeletePeer<ExperimentalWithCallbackMethod_AddPeerAction<ExperimentalWithCallbackMethod_RemovePeerAction<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_GetAllActions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetAllActions() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_GetAllActions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAllActions(::grpc::ServerContext* /*context*/, const ::resource::GetAllActionsRqst* /*request*/, ::resource::GetAllActionsRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ValidateToken : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ValidateToken() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_ValidateToken() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ValidateToken(::grpc::ServerContext* /*context*/, const ::resource::ValidateTokenRqst* /*request*/, ::resource::ValidateTokenRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_RefreshToken : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_RefreshToken() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_RefreshToken() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RefreshToken(::grpc::ServerContext* /*context*/, const ::resource::RefreshTokenRqst* /*request*/, ::resource::RefreshTokenRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Authenticate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Authenticate() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_Authenticate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Authenticate(::grpc::ServerContext* /*context*/, const ::resource::AuthenticateRqst* /*request*/, ::resource::AuthenticateRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SynchronizeLdap : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SynchronizeLdap() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_SynchronizeLdap() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SynchronizeLdap(::grpc::ServerContext* /*context*/, const ::resource::SynchronizeLdapRqst* /*request*/, ::resource::SynchronizeLdapRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_CreateOrganization : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_CreateOrganization() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_CreateOrganization() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateOrganization(::grpc::ServerContext* /*context*/, const ::resource::CreateOrganizationRqst* /*request*/, ::resource::CreateOrganizationRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetOrganizations : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetOrganizations() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_GetOrganizations() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetOrganizations(::grpc::ServerContext* /*context*/, const ::resource::GetOrganizationsRqst* /*request*/, ::grpc::ServerWriter< ::resource::GetOrganizationsRsp>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DeleteOrganization : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_DeleteOrganization() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_DeleteOrganization() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteOrganization(::grpc::ServerContext* /*context*/, const ::resource::DeleteOrganizationRqst* /*request*/, ::resource::DeleteOrganizationRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_CreateGroup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_CreateGroup() {
      ::grpc::Service::MarkMethodGeneric(8);
    }
    ~WithGenericMethod_CreateGroup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateGroup(::grpc::ServerContext* /*context*/, const ::resource::CreateGroupRqst* /*request*/, ::resource::CreateGroupRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetGroups : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetGroups() {
      ::grpc::Service::MarkMethodGeneric(9);
    }
    ~WithGenericMethod_GetGroups() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetGroups(::grpc::ServerContext* /*context*/, const ::resource::GetGroupsRqst* /*request*/, ::grpc::ServerWriter< ::resource::GetGroupsRsp>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DeleteGroup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_DeleteGroup() {
      ::grpc::Service::MarkMethodGeneric(10);
    }
    ~WithGenericMethod_DeleteGroup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteGroup(::grpc::ServerContext* /*context*/, const ::resource::DeleteGroupRqst* /*request*/, ::resource::DeleteGroupRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_AddGroupMemberAccount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_AddGroupMemberAccount() {
      ::grpc::Service::MarkMethodGeneric(11);
    }
    ~WithGenericMethod_AddGroupMemberAccount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AddGroupMemberAccount(::grpc::ServerContext* /*context*/, const ::resource::AddGroupMemberAccountRqst* /*request*/, ::resource::AddGroupMemberAccountRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_RemoveGroupMemberAccount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_RemoveGroupMemberAccount() {
      ::grpc::Service::MarkMethodGeneric(12);
    }
    ~WithGenericMethod_RemoveGroupMemberAccount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RemoveGroupMemberAccount(::grpc::ServerContext* /*context*/, const ::resource::RemoveGroupMemberAccountRqst* /*request*/, ::resource::RemoveGroupMemberAccountRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_RegisterAccount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_RegisterAccount() {
      ::grpc::Service::MarkMethodGeneric(13);
    }
    ~WithGenericMethod_RegisterAccount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RegisterAccount(::grpc::ServerContext* /*context*/, const ::resource::RegisterAccountRqst* /*request*/, ::resource::RegisterAccountRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DeleteAccount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_DeleteAccount() {
      ::grpc::Service::MarkMethodGeneric(14);
    }
    ~WithGenericMethod_DeleteAccount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteAccount(::grpc::ServerContext* /*context*/, const ::resource::DeleteAccountRqst* /*request*/, ::resource::DeleteAccountRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_AddAccountRole : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_AddAccountRole() {
      ::grpc::Service::MarkMethodGeneric(15);
    }
    ~WithGenericMethod_AddAccountRole() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AddAccountRole(::grpc::ServerContext* /*context*/, const ::resource::AddAccountRoleRqst* /*request*/, ::resource::AddAccountRoleRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_RemoveAccountRole : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_RemoveAccountRole() {
      ::grpc::Service::MarkMethodGeneric(16);
    }
    ~WithGenericMethod_RemoveAccountRole() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RemoveAccountRole(::grpc::ServerContext* /*context*/, const ::resource::RemoveAccountRoleRqst* /*request*/, ::resource::RemoveAccountRoleRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_CreateRole : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_CreateRole() {
      ::grpc::Service::MarkMethodGeneric(17);
    }
    ~WithGenericMethod_CreateRole() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateRole(::grpc::ServerContext* /*context*/, const ::resource::CreateRoleRqst* /*request*/, ::resource::CreateRoleRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DeleteRole : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_DeleteRole() {
      ::grpc::Service::MarkMethodGeneric(18);
    }
    ~WithGenericMethod_DeleteRole() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteRole(::grpc::ServerContext* /*context*/, const ::resource::DeleteRoleRqst* /*request*/, ::resource::DeleteRoleRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_AddRoleAction : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_AddRoleAction() {
      ::grpc::Service::MarkMethodGeneric(19);
    }
    ~WithGenericMethod_AddRoleAction() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AddRoleAction(::grpc::ServerContext* /*context*/, const ::resource::AddRoleActionRqst* /*request*/, ::resource::AddRoleActionRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_RemoveRoleAction : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_RemoveRoleAction() {
      ::grpc::Service::MarkMethodGeneric(20);
    }
    ~WithGenericMethod_RemoveRoleAction() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RemoveRoleAction(::grpc::ServerContext* /*context*/, const ::resource::RemoveRoleActionRqst* /*request*/, ::resource::RemoveRoleActionRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetAllApplicationsInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetAllApplicationsInfo() {
      ::grpc::Service::MarkMethodGeneric(21);
    }
    ~WithGenericMethod_GetAllApplicationsInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAllApplicationsInfo(::grpc::ServerContext* /*context*/, const ::resource::GetAllApplicationsInfoRqst* /*request*/, ::resource::GetAllApplicationsInfoRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DeleteApplication : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_DeleteApplication() {
      ::grpc::Service::MarkMethodGeneric(22);
    }
    ~WithGenericMethod_DeleteApplication() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteApplication(::grpc::ServerContext* /*context*/, const ::resource::DeleteApplicationRqst* /*request*/, ::resource::DeleteApplicationRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_AddApplicationAction : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_AddApplicationAction() {
      ::grpc::Service::MarkMethodGeneric(23);
    }
    ~WithGenericMethod_AddApplicationAction() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AddApplicationAction(::grpc::ServerContext* /*context*/, const ::resource::AddApplicationActionRqst* /*request*/, ::resource::AddApplicationActionRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_RemoveApplicationAction : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_RemoveApplicationAction() {
      ::grpc::Service::MarkMethodGeneric(24);
    }
    ~WithGenericMethod_RemoveApplicationAction() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RemoveApplicationAction(::grpc::ServerContext* /*context*/, const ::resource::RemoveApplicationActionRqst* /*request*/, ::resource::RemoveApplicationActionRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_RegisterPeer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_RegisterPeer() {
      ::grpc::Service::MarkMethodGeneric(25);
    }
    ~WithGenericMethod_RegisterPeer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RegisterPeer(::grpc::ServerContext* /*context*/, const ::resource::RegisterPeerRqst* /*request*/, ::resource::RegisterPeerRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetPeers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetPeers() {
      ::grpc::Service::MarkMethodGeneric(26);
    }
    ~WithGenericMethod_GetPeers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPeers(::grpc::ServerContext* /*context*/, const ::resource::GetPeersRqst* /*request*/, ::grpc::ServerWriter< ::resource::GetPeersRsp>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DeletePeer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_DeletePeer() {
      ::grpc::Service::MarkMethodGeneric(27);
    }
    ~WithGenericMethod_DeletePeer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeletePeer(::grpc::ServerContext* /*context*/, const ::resource::DeletePeerRqst* /*request*/, ::resource::DeletePeerRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_AddPeerAction : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_AddPeerAction() {
      ::grpc::Service::MarkMethodGeneric(28);
    }
    ~WithGenericMethod_AddPeerAction() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AddPeerAction(::grpc::ServerContext* /*context*/, const ::resource::AddPeerActionRqst* /*request*/, ::resource::AddPeerActionRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_RemovePeerAction : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_RemovePeerAction() {
      ::grpc::Service::MarkMethodGeneric(29);
    }
    ~WithGenericMethod_RemovePeerAction() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RemovePeerAction(::grpc::ServerContext* /*context*/, const ::resource::RemovePeerActionRqst* /*request*/, ::resource::RemovePeerActionRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetAllActions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetAllActions() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_GetAllActions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAllActions(::grpc::ServerContext* /*context*/, const ::resource::GetAllActionsRqst* /*request*/, ::resource::GetAllActionsRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetAllActions(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ValidateToken : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ValidateToken() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_ValidateToken() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ValidateToken(::grpc::ServerContext* /*context*/, const ::resource::ValidateTokenRqst* /*request*/, ::resource::ValidateTokenRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestValidateToken(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_RefreshToken : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_RefreshToken() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_RefreshToken() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RefreshToken(::grpc::ServerContext* /*context*/, const ::resource::RefreshTokenRqst* /*request*/, ::resource::RefreshTokenRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRefreshToken(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Authenticate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Authenticate() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_Authenticate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Authenticate(::grpc::ServerContext* /*context*/, const ::resource::AuthenticateRqst* /*request*/, ::resource::AuthenticateRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAuthenticate(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SynchronizeLdap : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SynchronizeLdap() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_SynchronizeLdap() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SynchronizeLdap(::grpc::ServerContext* /*context*/, const ::resource::SynchronizeLdapRqst* /*request*/, ::resource::SynchronizeLdapRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSynchronizeLdap(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_CreateOrganization : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_CreateOrganization() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_CreateOrganization() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateOrganization(::grpc::ServerContext* /*context*/, const ::resource::CreateOrganizationRqst* /*request*/, ::resource::CreateOrganizationRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCreateOrganization(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetOrganizations : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetOrganizations() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_GetOrganizations() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetOrganizations(::grpc::ServerContext* /*context*/, const ::resource::GetOrganizationsRqst* /*request*/, ::grpc::ServerWriter< ::resource::GetOrganizationsRsp>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetOrganizations(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(6, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DeleteOrganization : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_DeleteOrganization() {
      ::grpc::Service::MarkMethodRaw(7);
    }
    ~WithRawMethod_DeleteOrganization() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteOrganization(::grpc::ServerContext* /*context*/, const ::resource::DeleteOrganizationRqst* /*request*/, ::resource::DeleteOrganizationRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteOrganization(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_CreateGroup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_CreateGroup() {
      ::grpc::Service::MarkMethodRaw(8);
    }
    ~WithRawMethod_CreateGroup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateGroup(::grpc::ServerContext* /*context*/, const ::resource::CreateGroupRqst* /*request*/, ::resource::CreateGroupRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCreateGroup(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetGroups : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetGroups() {
      ::grpc::Service::MarkMethodRaw(9);
    }
    ~WithRawMethod_GetGroups() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetGroups(::grpc::ServerContext* /*context*/, const ::resource::GetGroupsRqst* /*request*/, ::grpc::ServerWriter< ::resource::GetGroupsRsp>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetGroups(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(9, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DeleteGroup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_DeleteGroup() {
      ::grpc::Service::MarkMethodRaw(10);
    }
    ~WithRawMethod_DeleteGroup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteGroup(::grpc::ServerContext* /*context*/, const ::resource::DeleteGroupRqst* /*request*/, ::resource::DeleteGroupRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteGroup(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_AddGroupMemberAccount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_AddGroupMemberAccount() {
      ::grpc::Service::MarkMethodRaw(11);
    }
    ~WithRawMethod_AddGroupMemberAccount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AddGroupMemberAccount(::grpc::ServerContext* /*context*/, const ::resource::AddGroupMemberAccountRqst* /*request*/, ::resource::AddGroupMemberAccountRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAddGroupMemberAccount(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_RemoveGroupMemberAccount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_RemoveGroupMemberAccount() {
      ::grpc::Service::MarkMethodRaw(12);
    }
    ~WithRawMethod_RemoveGroupMemberAccount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RemoveGroupMemberAccount(::grpc::ServerContext* /*context*/, const ::resource::RemoveGroupMemberAccountRqst* /*request*/, ::resource::RemoveGroupMemberAccountRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRemoveGroupMemberAccount(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_RegisterAccount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_RegisterAccount() {
      ::grpc::Service::MarkMethodRaw(13);
    }
    ~WithRawMethod_RegisterAccount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RegisterAccount(::grpc::ServerContext* /*context*/, const ::resource::RegisterAccountRqst* /*request*/, ::resource::RegisterAccountRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRegisterAccount(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DeleteAccount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_DeleteAccount() {
      ::grpc::Service::MarkMethodRaw(14);
    }
    ~WithRawMethod_DeleteAccount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteAccount(::grpc::ServerContext* /*context*/, const ::resource::DeleteAccountRqst* /*request*/, ::resource::DeleteAccountRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteAccount(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_AddAccountRole : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_AddAccountRole() {
      ::grpc::Service::MarkMethodRaw(15);
    }
    ~WithRawMethod_AddAccountRole() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AddAccountRole(::grpc::ServerContext* /*context*/, const ::resource::AddAccountRoleRqst* /*request*/, ::resource::AddAccountRoleRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAddAccountRole(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_RemoveAccountRole : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_RemoveAccountRole() {
      ::grpc::Service::MarkMethodRaw(16);
    }
    ~WithRawMethod_RemoveAccountRole() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RemoveAccountRole(::grpc::ServerContext* /*context*/, const ::resource::RemoveAccountRoleRqst* /*request*/, ::resource::RemoveAccountRoleRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRemoveAccountRole(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(16, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_CreateRole : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_CreateRole() {
      ::grpc::Service::MarkMethodRaw(17);
    }
    ~WithRawMethod_CreateRole() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateRole(::grpc::ServerContext* /*context*/, const ::resource::CreateRoleRqst* /*request*/, ::resource::CreateRoleRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCreateRole(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(17, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DeleteRole : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_DeleteRole() {
      ::grpc::Service::MarkMethodRaw(18);
    }
    ~WithRawMethod_DeleteRole() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteRole(::grpc::ServerContext* /*context*/, const ::resource::DeleteRoleRqst* /*request*/, ::resource::DeleteRoleRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteRole(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(18, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_AddRoleAction : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_AddRoleAction() {
      ::grpc::Service::MarkMethodRaw(19);
    }
    ~WithRawMethod_AddRoleAction() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AddRoleAction(::grpc::ServerContext* /*context*/, const ::resource::AddRoleActionRqst* /*request*/, ::resource::AddRoleActionRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAddRoleAction(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(19, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_RemoveRoleAction : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_RemoveRoleAction() {
      ::grpc::Service::MarkMethodRaw(20);
    }
    ~WithRawMethod_RemoveRoleAction() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RemoveRoleAction(::grpc::ServerContext* /*context*/, const ::resource::RemoveRoleActionRqst* /*request*/, ::resource::RemoveRoleActionRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRemoveRoleAction(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(20, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetAllApplicationsInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetAllApplicationsInfo() {
      ::grpc::Service::MarkMethodRaw(21);
    }
    ~WithRawMethod_GetAllApplicationsInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAllApplicationsInfo(::grpc::ServerContext* /*context*/, const ::resource::GetAllApplicationsInfoRqst* /*request*/, ::resource::GetAllApplicationsInfoRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetAllApplicationsInfo(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(21, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DeleteApplication : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_DeleteApplication() {
      ::grpc::Service::MarkMethodRaw(22);
    }
    ~WithRawMethod_DeleteApplication() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteApplication(::grpc::ServerContext* /*context*/, const ::resource::DeleteApplicationRqst* /*request*/, ::resource::DeleteApplicationRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteApplication(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(22, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_AddApplicationAction : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_AddApplicationAction() {
      ::grpc::Service::MarkMethodRaw(23);
    }
    ~WithRawMethod_AddApplicationAction() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AddApplicationAction(::grpc::ServerContext* /*context*/, const ::resource::AddApplicationActionRqst* /*request*/, ::resource::AddApplicationActionRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAddApplicationAction(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(23, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_RemoveApplicationAction : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_RemoveApplicationAction() {
      ::grpc::Service::MarkMethodRaw(24);
    }
    ~WithRawMethod_RemoveApplicationAction() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RemoveApplicationAction(::grpc::ServerContext* /*context*/, const ::resource::RemoveApplicationActionRqst* /*request*/, ::resource::RemoveApplicationActionRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRemoveApplicationAction(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(24, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_RegisterPeer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_RegisterPeer() {
      ::grpc::Service::MarkMethodRaw(25);
    }
    ~WithRawMethod_RegisterPeer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RegisterPeer(::grpc::ServerContext* /*context*/, const ::resource::RegisterPeerRqst* /*request*/, ::resource::RegisterPeerRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRegisterPeer(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(25, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetPeers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetPeers() {
      ::grpc::Service::MarkMethodRaw(26);
    }
    ~WithRawMethod_GetPeers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPeers(::grpc::ServerContext* /*context*/, const ::resource::GetPeersRqst* /*request*/, ::grpc::ServerWriter< ::resource::GetPeersRsp>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetPeers(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(26, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DeletePeer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_DeletePeer() {
      ::grpc::Service::MarkMethodRaw(27);
    }
    ~WithRawMethod_DeletePeer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeletePeer(::grpc::ServerContext* /*context*/, const ::resource::DeletePeerRqst* /*request*/, ::resource::DeletePeerRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeletePeer(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(27, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_AddPeerAction : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_AddPeerAction() {
      ::grpc::Service::MarkMethodRaw(28);
    }
    ~WithRawMethod_AddPeerAction() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AddPeerAction(::grpc::ServerContext* /*context*/, const ::resource::AddPeerActionRqst* /*request*/, ::resource::AddPeerActionRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAddPeerAction(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(28, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_RemovePeerAction : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_RemovePeerAction() {
      ::grpc::Service::MarkMethodRaw(29);
    }
    ~WithRawMethod_RemovePeerAction() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RemovePeerAction(::grpc::ServerContext* /*context*/, const ::resource::RemovePeerActionRqst* /*request*/, ::resource::RemovePeerActionRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRemovePeerAction(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(29, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetAllActions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetAllActions() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetAllActions(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetAllActions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAllActions(::grpc::ServerContext* /*context*/, const ::resource::GetAllActionsRqst* /*request*/, ::resource::GetAllActionsRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetAllActions(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetAllActions(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ValidateToken : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ValidateToken() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ValidateToken(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ValidateToken() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ValidateToken(::grpc::ServerContext* /*context*/, const ::resource::ValidateTokenRqst* /*request*/, ::resource::ValidateTokenRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ValidateToken(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ValidateToken(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_RefreshToken : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_RefreshToken() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->RefreshToken(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_RefreshToken() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RefreshToken(::grpc::ServerContext* /*context*/, const ::resource::RefreshTokenRqst* /*request*/, ::resource::RefreshTokenRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* RefreshToken(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* RefreshToken(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_Authenticate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_Authenticate() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Authenticate(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_Authenticate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Authenticate(::grpc::ServerContext* /*context*/, const ::resource::AuthenticateRqst* /*request*/, ::resource::AuthenticateRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Authenticate(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Authenticate(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SynchronizeLdap : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_SynchronizeLdap() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SynchronizeLdap(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_SynchronizeLdap() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SynchronizeLdap(::grpc::ServerContext* /*context*/, const ::resource::SynchronizeLdapRqst* /*request*/, ::resource::SynchronizeLdapRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* SynchronizeLdap(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* SynchronizeLdap(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_CreateOrganization : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_CreateOrganization() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->CreateOrganization(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_CreateOrganization() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateOrganization(::grpc::ServerContext* /*context*/, const ::resource::CreateOrganizationRqst* /*request*/, ::resource::CreateOrganizationRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* CreateOrganization(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* CreateOrganization(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetOrganizations : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetOrganizations() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(6,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const::grpc::ByteBuffer* request) { return this->GetOrganizations(context, request); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetOrganizations() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetOrganizations(::grpc::ServerContext* /*context*/, const ::resource::GetOrganizationsRqst* /*request*/, ::grpc::ServerWriter< ::resource::GetOrganizationsRsp>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* GetOrganizations(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::grpc::ByteBuffer>* GetOrganizations(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_DeleteOrganization : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_DeleteOrganization() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->DeleteOrganization(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_DeleteOrganization() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteOrganization(::grpc::ServerContext* /*context*/, const ::resource::DeleteOrganizationRqst* /*request*/, ::resource::DeleteOrganizationRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DeleteOrganization(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DeleteOrganization(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_CreateGroup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_CreateGroup() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->CreateGroup(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_CreateGroup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateGroup(::grpc::ServerContext* /*context*/, const ::resource::CreateGroupRqst* /*request*/, ::resource::CreateGroupRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* CreateGroup(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* CreateGroup(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetGroups : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetGroups() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(9,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const::grpc::ByteBuffer* request) { return this->GetGroups(context, request); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetGroups() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetGroups(::grpc::ServerContext* /*context*/, const ::resource::GetGroupsRqst* /*request*/, ::grpc::ServerWriter< ::resource::GetGroupsRsp>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* GetGroups(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::grpc::ByteBuffer>* GetGroups(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_DeleteGroup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_DeleteGroup() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(10,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->DeleteGroup(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_DeleteGroup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteGroup(::grpc::ServerContext* /*context*/, const ::resource::DeleteGroupRqst* /*request*/, ::resource::DeleteGroupRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DeleteGroup(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DeleteGroup(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_AddGroupMemberAccount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_AddGroupMemberAccount() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(11,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->AddGroupMemberAccount(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_AddGroupMemberAccount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AddGroupMemberAccount(::grpc::ServerContext* /*context*/, const ::resource::AddGroupMemberAccountRqst* /*request*/, ::resource::AddGroupMemberAccountRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* AddGroupMemberAccount(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* AddGroupMemberAccount(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_RemoveGroupMemberAccount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_RemoveGroupMemberAccount() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(12,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->RemoveGroupMemberAccount(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_RemoveGroupMemberAccount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RemoveGroupMemberAccount(::grpc::ServerContext* /*context*/, const ::resource::RemoveGroupMemberAccountRqst* /*request*/, ::resource::RemoveGroupMemberAccountRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* RemoveGroupMemberAccount(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* RemoveGroupMemberAccount(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_RegisterAccount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_RegisterAccount() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(13,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->RegisterAccount(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_RegisterAccount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RegisterAccount(::grpc::ServerContext* /*context*/, const ::resource::RegisterAccountRqst* /*request*/, ::resource::RegisterAccountRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* RegisterAccount(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* RegisterAccount(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_DeleteAccount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_DeleteAccount() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(14,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->DeleteAccount(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_DeleteAccount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteAccount(::grpc::ServerContext* /*context*/, const ::resource::DeleteAccountRqst* /*request*/, ::resource::DeleteAccountRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DeleteAccount(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DeleteAccount(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_AddAccountRole : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_AddAccountRole() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(15,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->AddAccountRole(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_AddAccountRole() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AddAccountRole(::grpc::ServerContext* /*context*/, const ::resource::AddAccountRoleRqst* /*request*/, ::resource::AddAccountRoleRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* AddAccountRole(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* AddAccountRole(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_RemoveAccountRole : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_RemoveAccountRole() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(16,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->RemoveAccountRole(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_RemoveAccountRole() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RemoveAccountRole(::grpc::ServerContext* /*context*/, const ::resource::RemoveAccountRoleRqst* /*request*/, ::resource::RemoveAccountRoleRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* RemoveAccountRole(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* RemoveAccountRole(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_CreateRole : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_CreateRole() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(17,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->CreateRole(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_CreateRole() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateRole(::grpc::ServerContext* /*context*/, const ::resource::CreateRoleRqst* /*request*/, ::resource::CreateRoleRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* CreateRole(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* CreateRole(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_DeleteRole : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_DeleteRole() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(18,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->DeleteRole(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_DeleteRole() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteRole(::grpc::ServerContext* /*context*/, const ::resource::DeleteRoleRqst* /*request*/, ::resource::DeleteRoleRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DeleteRole(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DeleteRole(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_AddRoleAction : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_AddRoleAction() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(19,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->AddRoleAction(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_AddRoleAction() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AddRoleAction(::grpc::ServerContext* /*context*/, const ::resource::AddRoleActionRqst* /*request*/, ::resource::AddRoleActionRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* AddRoleAction(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* AddRoleAction(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_RemoveRoleAction : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_RemoveRoleAction() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(20,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->RemoveRoleAction(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_RemoveRoleAction() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RemoveRoleAction(::grpc::ServerContext* /*context*/, const ::resource::RemoveRoleActionRqst* /*request*/, ::resource::RemoveRoleActionRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* RemoveRoleAction(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* RemoveRoleAction(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetAllApplicationsInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetAllApplicationsInfo() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(21,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetAllApplicationsInfo(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetAllApplicationsInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAllApplicationsInfo(::grpc::ServerContext* /*context*/, const ::resource::GetAllApplicationsInfoRqst* /*request*/, ::resource::GetAllApplicationsInfoRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetAllApplicationsInfo(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetAllApplicationsInfo(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_DeleteApplication : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_DeleteApplication() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(22,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->DeleteApplication(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_DeleteApplication() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteApplication(::grpc::ServerContext* /*context*/, const ::resource::DeleteApplicationRqst* /*request*/, ::resource::DeleteApplicationRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DeleteApplication(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DeleteApplication(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_AddApplicationAction : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_AddApplicationAction() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(23,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->AddApplicationAction(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_AddApplicationAction() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AddApplicationAction(::grpc::ServerContext* /*context*/, const ::resource::AddApplicationActionRqst* /*request*/, ::resource::AddApplicationActionRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* AddApplicationAction(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* AddApplicationAction(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_RemoveApplicationAction : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_RemoveApplicationAction() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(24,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->RemoveApplicationAction(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_RemoveApplicationAction() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RemoveApplicationAction(::grpc::ServerContext* /*context*/, const ::resource::RemoveApplicationActionRqst* /*request*/, ::resource::RemoveApplicationActionRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* RemoveApplicationAction(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* RemoveApplicationAction(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_RegisterPeer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_RegisterPeer() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(25,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->RegisterPeer(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_RegisterPeer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RegisterPeer(::grpc::ServerContext* /*context*/, const ::resource::RegisterPeerRqst* /*request*/, ::resource::RegisterPeerRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* RegisterPeer(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* RegisterPeer(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetPeers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetPeers() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(26,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const::grpc::ByteBuffer* request) { return this->GetPeers(context, request); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetPeers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPeers(::grpc::ServerContext* /*context*/, const ::resource::GetPeersRqst* /*request*/, ::grpc::ServerWriter< ::resource::GetPeersRsp>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* GetPeers(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::grpc::ByteBuffer>* GetPeers(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_DeletePeer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_DeletePeer() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(27,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->DeletePeer(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_DeletePeer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeletePeer(::grpc::ServerContext* /*context*/, const ::resource::DeletePeerRqst* /*request*/, ::resource::DeletePeerRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DeletePeer(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DeletePeer(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_AddPeerAction : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_AddPeerAction() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(28,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->AddPeerAction(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_AddPeerAction() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AddPeerAction(::grpc::ServerContext* /*context*/, const ::resource::AddPeerActionRqst* /*request*/, ::resource::AddPeerActionRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* AddPeerAction(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* AddPeerAction(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_RemovePeerAction : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_RemovePeerAction() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(29,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->RemovePeerAction(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_RemovePeerAction() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RemovePeerAction(::grpc::ServerContext* /*context*/, const ::resource::RemovePeerActionRqst* /*request*/, ::resource::RemovePeerActionRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* RemovePeerAction(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* RemovePeerAction(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetAllActions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetAllActions() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::resource::GetAllActionsRqst, ::resource::GetAllActionsRsp>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::resource::GetAllActionsRqst, ::resource::GetAllActionsRsp>* streamer) {
                       return this->StreamedGetAllActions(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetAllActions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetAllActions(::grpc::ServerContext* /*context*/, const ::resource::GetAllActionsRqst* /*request*/, ::resource::GetAllActionsRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetAllActions(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::resource::GetAllActionsRqst,::resource::GetAllActionsRsp>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ValidateToken : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ValidateToken() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::resource::ValidateTokenRqst, ::resource::ValidateTokenRsp>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::resource::ValidateTokenRqst, ::resource::ValidateTokenRsp>* streamer) {
                       return this->StreamedValidateToken(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ValidateToken() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ValidateToken(::grpc::ServerContext* /*context*/, const ::resource::ValidateTokenRqst* /*request*/, ::resource::ValidateTokenRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedValidateToken(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::resource::ValidateTokenRqst,::resource::ValidateTokenRsp>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_RefreshToken : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_RefreshToken() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::resource::RefreshTokenRqst, ::resource::RefreshTokenRsp>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::resource::RefreshTokenRqst, ::resource::RefreshTokenRsp>* streamer) {
                       return this->StreamedRefreshToken(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_RefreshToken() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status RefreshToken(::grpc::ServerContext* /*context*/, const ::resource::RefreshTokenRqst* /*request*/, ::resource::RefreshTokenRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedRefreshToken(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::resource::RefreshTokenRqst,::resource::RefreshTokenRsp>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Authenticate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Authenticate() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::resource::AuthenticateRqst, ::resource::AuthenticateRsp>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::resource::AuthenticateRqst, ::resource::AuthenticateRsp>* streamer) {
                       return this->StreamedAuthenticate(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Authenticate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Authenticate(::grpc::ServerContext* /*context*/, const ::resource::AuthenticateRqst* /*request*/, ::resource::AuthenticateRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedAuthenticate(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::resource::AuthenticateRqst,::resource::AuthenticateRsp>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SynchronizeLdap : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SynchronizeLdap() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler<
          ::resource::SynchronizeLdapRqst, ::resource::SynchronizeLdapRsp>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::resource::SynchronizeLdapRqst, ::resource::SynchronizeLdapRsp>* streamer) {
                       return this->StreamedSynchronizeLdap(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SynchronizeLdap() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SynchronizeLdap(::grpc::ServerContext* /*context*/, const ::resource::SynchronizeLdapRqst* /*request*/, ::resource::SynchronizeLdapRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSynchronizeLdap(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::resource::SynchronizeLdapRqst,::resource::SynchronizeLdapRsp>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_CreateOrganization : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_CreateOrganization() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler<
          ::resource::CreateOrganizationRqst, ::resource::CreateOrganizationRsp>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::resource::CreateOrganizationRqst, ::resource::CreateOrganizationRsp>* streamer) {
                       return this->StreamedCreateOrganization(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_CreateOrganization() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status CreateOrganization(::grpc::ServerContext* /*context*/, const ::resource::CreateOrganizationRqst* /*request*/, ::resource::CreateOrganizationRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedCreateOrganization(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::resource::CreateOrganizationRqst,::resource::CreateOrganizationRsp>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DeleteOrganization : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_DeleteOrganization() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::StreamedUnaryHandler<
          ::resource::DeleteOrganizationRqst, ::resource::DeleteOrganizationRsp>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::resource::DeleteOrganizationRqst, ::resource::DeleteOrganizationRsp>* streamer) {
                       return this->StreamedDeleteOrganization(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_DeleteOrganization() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DeleteOrganization(::grpc::ServerContext* /*context*/, const ::resource::DeleteOrganizationRqst* /*request*/, ::resource::DeleteOrganizationRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDeleteOrganization(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::resource::DeleteOrganizationRqst,::resource::DeleteOrganizationRsp>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_CreateGroup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_CreateGroup() {
      ::grpc::Service::MarkMethodStreamed(8,
        new ::grpc::internal::StreamedUnaryHandler<
          ::resource::CreateGroupRqst, ::resource::CreateGroupRsp>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::resource::CreateGroupRqst, ::resource::CreateGroupRsp>* streamer) {
                       return this->StreamedCreateGroup(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_CreateGroup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status CreateGroup(::grpc::ServerContext* /*context*/, const ::resource::CreateGroupRqst* /*request*/, ::resource::CreateGroupRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedCreateGroup(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::resource::CreateGroupRqst,::resource::CreateGroupRsp>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DeleteGroup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_DeleteGroup() {
      ::grpc::Service::MarkMethodStreamed(10,
        new ::grpc::internal::StreamedUnaryHandler<
          ::resource::DeleteGroupRqst, ::resource::DeleteGroupRsp>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::resource::DeleteGroupRqst, ::resource::DeleteGroupRsp>* streamer) {
                       return this->StreamedDeleteGroup(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_DeleteGroup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DeleteGroup(::grpc::ServerContext* /*context*/, const ::resource::DeleteGroupRqst* /*request*/, ::resource::DeleteGroupRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDeleteGroup(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::resource::DeleteGroupRqst,::resource::DeleteGroupRsp>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_AddGroupMemberAccount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_AddGroupMemberAccount() {
      ::grpc::Service::MarkMethodStreamed(11,
        new ::grpc::internal::StreamedUnaryHandler<
          ::resource::AddGroupMemberAccountRqst, ::resource::AddGroupMemberAccountRsp>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::resource::AddGroupMemberAccountRqst, ::resource::AddGroupMemberAccountRsp>* streamer) {
                       return this->StreamedAddGroupMemberAccount(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_AddGroupMemberAccount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status AddGroupMemberAccount(::grpc::ServerContext* /*context*/, const ::resource::AddGroupMemberAccountRqst* /*request*/, ::resource::AddGroupMemberAccountRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedAddGroupMemberAccount(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::resource::AddGroupMemberAccountRqst,::resource::AddGroupMemberAccountRsp>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_RemoveGroupMemberAccount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_RemoveGroupMemberAccount() {
      ::grpc::Service::MarkMethodStreamed(12,
        new ::grpc::internal::StreamedUnaryHandler<
          ::resource::RemoveGroupMemberAccountRqst, ::resource::RemoveGroupMemberAccountRsp>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::resource::RemoveGroupMemberAccountRqst, ::resource::RemoveGroupMemberAccountRsp>* streamer) {
                       return this->StreamedRemoveGroupMemberAccount(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_RemoveGroupMemberAccount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status RemoveGroupMemberAccount(::grpc::ServerContext* /*context*/, const ::resource::RemoveGroupMemberAccountRqst* /*request*/, ::resource::RemoveGroupMemberAccountRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedRemoveGroupMemberAccount(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::resource::RemoveGroupMemberAccountRqst,::resource::RemoveGroupMemberAccountRsp>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_RegisterAccount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_RegisterAccount() {
      ::grpc::Service::MarkMethodStreamed(13,
        new ::grpc::internal::StreamedUnaryHandler<
          ::resource::RegisterAccountRqst, ::resource::RegisterAccountRsp>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::resource::RegisterAccountRqst, ::resource::RegisterAccountRsp>* streamer) {
                       return this->StreamedRegisterAccount(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_RegisterAccount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status RegisterAccount(::grpc::ServerContext* /*context*/, const ::resource::RegisterAccountRqst* /*request*/, ::resource::RegisterAccountRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedRegisterAccount(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::resource::RegisterAccountRqst,::resource::RegisterAccountRsp>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DeleteAccount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_DeleteAccount() {
      ::grpc::Service::MarkMethodStreamed(14,
        new ::grpc::internal::StreamedUnaryHandler<
          ::resource::DeleteAccountRqst, ::resource::DeleteAccountRsp>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::resource::DeleteAccountRqst, ::resource::DeleteAccountRsp>* streamer) {
                       return this->StreamedDeleteAccount(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_DeleteAccount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DeleteAccount(::grpc::ServerContext* /*context*/, const ::resource::DeleteAccountRqst* /*request*/, ::resource::DeleteAccountRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDeleteAccount(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::resource::DeleteAccountRqst,::resource::DeleteAccountRsp>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_AddAccountRole : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_AddAccountRole() {
      ::grpc::Service::MarkMethodStreamed(15,
        new ::grpc::internal::StreamedUnaryHandler<
          ::resource::AddAccountRoleRqst, ::resource::AddAccountRoleRsp>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::resource::AddAccountRoleRqst, ::resource::AddAccountRoleRsp>* streamer) {
                       return this->StreamedAddAccountRole(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_AddAccountRole() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status AddAccountRole(::grpc::ServerContext* /*context*/, const ::resource::AddAccountRoleRqst* /*request*/, ::resource::AddAccountRoleRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedAddAccountRole(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::resource::AddAccountRoleRqst,::resource::AddAccountRoleRsp>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_RemoveAccountRole : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_RemoveAccountRole() {
      ::grpc::Service::MarkMethodStreamed(16,
        new ::grpc::internal::StreamedUnaryHandler<
          ::resource::RemoveAccountRoleRqst, ::resource::RemoveAccountRoleRsp>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::resource::RemoveAccountRoleRqst, ::resource::RemoveAccountRoleRsp>* streamer) {
                       return this->StreamedRemoveAccountRole(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_RemoveAccountRole() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status RemoveAccountRole(::grpc::ServerContext* /*context*/, const ::resource::RemoveAccountRoleRqst* /*request*/, ::resource::RemoveAccountRoleRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedRemoveAccountRole(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::resource::RemoveAccountRoleRqst,::resource::RemoveAccountRoleRsp>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_CreateRole : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_CreateRole() {
      ::grpc::Service::MarkMethodStreamed(17,
        new ::grpc::internal::StreamedUnaryHandler<
          ::resource::CreateRoleRqst, ::resource::CreateRoleRsp>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::resource::CreateRoleRqst, ::resource::CreateRoleRsp>* streamer) {
                       return this->StreamedCreateRole(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_CreateRole() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status CreateRole(::grpc::ServerContext* /*context*/, const ::resource::CreateRoleRqst* /*request*/, ::resource::CreateRoleRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedCreateRole(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::resource::CreateRoleRqst,::resource::CreateRoleRsp>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DeleteRole : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_DeleteRole() {
      ::grpc::Service::MarkMethodStreamed(18,
        new ::grpc::internal::StreamedUnaryHandler<
          ::resource::DeleteRoleRqst, ::resource::DeleteRoleRsp>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::resource::DeleteRoleRqst, ::resource::DeleteRoleRsp>* streamer) {
                       return this->StreamedDeleteRole(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_DeleteRole() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DeleteRole(::grpc::ServerContext* /*context*/, const ::resource::DeleteRoleRqst* /*request*/, ::resource::DeleteRoleRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDeleteRole(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::resource::DeleteRoleRqst,::resource::DeleteRoleRsp>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_AddRoleAction : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_AddRoleAction() {
      ::grpc::Service::MarkMethodStreamed(19,
        new ::grpc::internal::StreamedUnaryHandler<
          ::resource::AddRoleActionRqst, ::resource::AddRoleActionRsp>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::resource::AddRoleActionRqst, ::resource::AddRoleActionRsp>* streamer) {
                       return this->StreamedAddRoleAction(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_AddRoleAction() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status AddRoleAction(::grpc::ServerContext* /*context*/, const ::resource::AddRoleActionRqst* /*request*/, ::resource::AddRoleActionRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedAddRoleAction(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::resource::AddRoleActionRqst,::resource::AddRoleActionRsp>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_RemoveRoleAction : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_RemoveRoleAction() {
      ::grpc::Service::MarkMethodStreamed(20,
        new ::grpc::internal::StreamedUnaryHandler<
          ::resource::RemoveRoleActionRqst, ::resource::RemoveRoleActionRsp>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::resource::RemoveRoleActionRqst, ::resource::RemoveRoleActionRsp>* streamer) {
                       return this->StreamedRemoveRoleAction(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_RemoveRoleAction() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status RemoveRoleAction(::grpc::ServerContext* /*context*/, const ::resource::RemoveRoleActionRqst* /*request*/, ::resource::RemoveRoleActionRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedRemoveRoleAction(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::resource::RemoveRoleActionRqst,::resource::RemoveRoleActionRsp>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetAllApplicationsInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetAllApplicationsInfo() {
      ::grpc::Service::MarkMethodStreamed(21,
        new ::grpc::internal::StreamedUnaryHandler<
          ::resource::GetAllApplicationsInfoRqst, ::resource::GetAllApplicationsInfoRsp>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::resource::GetAllApplicationsInfoRqst, ::resource::GetAllApplicationsInfoRsp>* streamer) {
                       return this->StreamedGetAllApplicationsInfo(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetAllApplicationsInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetAllApplicationsInfo(::grpc::ServerContext* /*context*/, const ::resource::GetAllApplicationsInfoRqst* /*request*/, ::resource::GetAllApplicationsInfoRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetAllApplicationsInfo(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::resource::GetAllApplicationsInfoRqst,::resource::GetAllApplicationsInfoRsp>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DeleteApplication : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_DeleteApplication() {
      ::grpc::Service::MarkMethodStreamed(22,
        new ::grpc::internal::StreamedUnaryHandler<
          ::resource::DeleteApplicationRqst, ::resource::DeleteApplicationRsp>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::resource::DeleteApplicationRqst, ::resource::DeleteApplicationRsp>* streamer) {
                       return this->StreamedDeleteApplication(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_DeleteApplication() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DeleteApplication(::grpc::ServerContext* /*context*/, const ::resource::DeleteApplicationRqst* /*request*/, ::resource::DeleteApplicationRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDeleteApplication(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::resource::DeleteApplicationRqst,::resource::DeleteApplicationRsp>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_AddApplicationAction : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_AddApplicationAction() {
      ::grpc::Service::MarkMethodStreamed(23,
        new ::grpc::internal::StreamedUnaryHandler<
          ::resource::AddApplicationActionRqst, ::resource::AddApplicationActionRsp>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::resource::AddApplicationActionRqst, ::resource::AddApplicationActionRsp>* streamer) {
                       return this->StreamedAddApplicationAction(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_AddApplicationAction() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status AddApplicationAction(::grpc::ServerContext* /*context*/, const ::resource::AddApplicationActionRqst* /*request*/, ::resource::AddApplicationActionRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedAddApplicationAction(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::resource::AddApplicationActionRqst,::resource::AddApplicationActionRsp>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_RemoveApplicationAction : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_RemoveApplicationAction() {
      ::grpc::Service::MarkMethodStreamed(24,
        new ::grpc::internal::StreamedUnaryHandler<
          ::resource::RemoveApplicationActionRqst, ::resource::RemoveApplicationActionRsp>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::resource::RemoveApplicationActionRqst, ::resource::RemoveApplicationActionRsp>* streamer) {
                       return this->StreamedRemoveApplicationAction(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_RemoveApplicationAction() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status RemoveApplicationAction(::grpc::ServerContext* /*context*/, const ::resource::RemoveApplicationActionRqst* /*request*/, ::resource::RemoveApplicationActionRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedRemoveApplicationAction(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::resource::RemoveApplicationActionRqst,::resource::RemoveApplicationActionRsp>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_RegisterPeer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_RegisterPeer() {
      ::grpc::Service::MarkMethodStreamed(25,
        new ::grpc::internal::StreamedUnaryHandler<
          ::resource::RegisterPeerRqst, ::resource::RegisterPeerRsp>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::resource::RegisterPeerRqst, ::resource::RegisterPeerRsp>* streamer) {
                       return this->StreamedRegisterPeer(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_RegisterPeer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status RegisterPeer(::grpc::ServerContext* /*context*/, const ::resource::RegisterPeerRqst* /*request*/, ::resource::RegisterPeerRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedRegisterPeer(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::resource::RegisterPeerRqst,::resource::RegisterPeerRsp>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DeletePeer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_DeletePeer() {
      ::grpc::Service::MarkMethodStreamed(27,
        new ::grpc::internal::StreamedUnaryHandler<
          ::resource::DeletePeerRqst, ::resource::DeletePeerRsp>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::resource::DeletePeerRqst, ::resource::DeletePeerRsp>* streamer) {
                       return this->StreamedDeletePeer(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_DeletePeer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DeletePeer(::grpc::ServerContext* /*context*/, const ::resource::DeletePeerRqst* /*request*/, ::resource::DeletePeerRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDeletePeer(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::resource::DeletePeerRqst,::resource::DeletePeerRsp>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_AddPeerAction : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_AddPeerAction() {
      ::grpc::Service::MarkMethodStreamed(28,
        new ::grpc::internal::StreamedUnaryHandler<
          ::resource::AddPeerActionRqst, ::resource::AddPeerActionRsp>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::resource::AddPeerActionRqst, ::resource::AddPeerActionRsp>* streamer) {
                       return this->StreamedAddPeerAction(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_AddPeerAction() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status AddPeerAction(::grpc::ServerContext* /*context*/, const ::resource::AddPeerActionRqst* /*request*/, ::resource::AddPeerActionRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedAddPeerAction(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::resource::AddPeerActionRqst,::resource::AddPeerActionRsp>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_RemovePeerAction : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_RemovePeerAction() {
      ::grpc::Service::MarkMethodStreamed(29,
        new ::grpc::internal::StreamedUnaryHandler<
          ::resource::RemovePeerActionRqst, ::resource::RemovePeerActionRsp>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::resource::RemovePeerActionRqst, ::resource::RemovePeerActionRsp>* streamer) {
                       return this->StreamedRemovePeerAction(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_RemovePeerAction() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status RemovePeerAction(::grpc::ServerContext* /*context*/, const ::resource::RemovePeerActionRqst* /*request*/, ::resource::RemovePeerActionRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedRemovePeerAction(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::resource::RemovePeerActionRqst,::resource::RemovePeerActionRsp>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_GetAllActions<WithStreamedUnaryMethod_ValidateToken<WithStreamedUnaryMethod_RefreshToken<WithStreamedUnaryMethod_Authenticate<WithStreamedUnaryMethod_SynchronizeLdap<WithStreamedUnaryMethod_CreateOrganization<WithStreamedUnaryMethod_DeleteOrganization<WithStreamedUnaryMethod_CreateGroup<WithStreamedUnaryMethod_DeleteGroup<WithStreamedUnaryMethod_AddGroupMemberAccount<WithStreamedUnaryMethod_RemoveGroupMemberAccount<WithStreamedUnaryMethod_RegisterAccount<WithStreamedUnaryMethod_DeleteAccount<WithStreamedUnaryMethod_AddAccountRole<WithStreamedUnaryMethod_RemoveAccountRole<WithStreamedUnaryMethod_CreateRole<WithStreamedUnaryMethod_DeleteRole<WithStreamedUnaryMethod_AddRoleAction<WithStreamedUnaryMethod_RemoveRoleAction<WithStreamedUnaryMethod_GetAllApplicationsInfo<WithStreamedUnaryMethod_DeleteApplication<WithStreamedUnaryMethod_AddApplicationAction<WithStreamedUnaryMethod_RemoveApplicationAction<WithStreamedUnaryMethod_RegisterPeer<WithStreamedUnaryMethod_DeletePeer<WithStreamedUnaryMethod_AddPeerAction<WithStreamedUnaryMethod_RemovePeerAction<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > StreamedUnaryService;
  template <class BaseClass>
  class WithSplitStreamingMethod_GetOrganizations : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_GetOrganizations() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::resource::GetOrganizationsRqst, ::resource::GetOrganizationsRsp>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::resource::GetOrganizationsRqst, ::resource::GetOrganizationsRsp>* streamer) {
                       return this->StreamedGetOrganizations(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_GetOrganizations() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetOrganizations(::grpc::ServerContext* /*context*/, const ::resource::GetOrganizationsRqst* /*request*/, ::grpc::ServerWriter< ::resource::GetOrganizationsRsp>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedGetOrganizations(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::resource::GetOrganizationsRqst,::resource::GetOrganizationsRsp>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_GetGroups : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_GetGroups() {
      ::grpc::Service::MarkMethodStreamed(9,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::resource::GetGroupsRqst, ::resource::GetGroupsRsp>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::resource::GetGroupsRqst, ::resource::GetGroupsRsp>* streamer) {
                       return this->StreamedGetGroups(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_GetGroups() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetGroups(::grpc::ServerContext* /*context*/, const ::resource::GetGroupsRqst* /*request*/, ::grpc::ServerWriter< ::resource::GetGroupsRsp>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedGetGroups(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::resource::GetGroupsRqst,::resource::GetGroupsRsp>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_GetPeers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_GetPeers() {
      ::grpc::Service::MarkMethodStreamed(26,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::resource::GetPeersRqst, ::resource::GetPeersRsp>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::resource::GetPeersRqst, ::resource::GetPeersRsp>* streamer) {
                       return this->StreamedGetPeers(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_GetPeers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetPeers(::grpc::ServerContext* /*context*/, const ::resource::GetPeersRqst* /*request*/, ::grpc::ServerWriter< ::resource::GetPeersRsp>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedGetPeers(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::resource::GetPeersRqst,::resource::GetPeersRsp>* server_split_streamer) = 0;
  };
  typedef WithSplitStreamingMethod_GetOrganizations<WithSplitStreamingMethod_GetGroups<WithSplitStreamingMethod_GetPeers<Service > > > SplitStreamedService;
  typedef WithStreamedUnaryMethod_GetAllActions<WithStreamedUnaryMethod_ValidateToken<WithStreamedUnaryMethod_RefreshToken<WithStreamedUnaryMethod_Authenticate<WithStreamedUnaryMethod_SynchronizeLdap<WithStreamedUnaryMethod_CreateOrganization<WithSplitStreamingMethod_GetOrganizations<WithStreamedUnaryMethod_DeleteOrganization<WithStreamedUnaryMethod_CreateGroup<WithSplitStreamingMethod_GetGroups<WithStreamedUnaryMethod_DeleteGroup<WithStreamedUnaryMethod_AddGroupMemberAccount<WithStreamedUnaryMethod_RemoveGroupMemberAccount<WithStreamedUnaryMethod_RegisterAccount<WithStreamedUnaryMethod_DeleteAccount<WithStreamedUnaryMethod_AddAccountRole<WithStreamedUnaryMethod_RemoveAccountRole<WithStreamedUnaryMethod_CreateRole<WithStreamedUnaryMethod_DeleteRole<WithStreamedUnaryMethod_AddRoleAction<WithStreamedUnaryMethod_RemoveRoleAction<WithStreamedUnaryMethod_GetAllApplicationsInfo<WithStreamedUnaryMethod_DeleteApplication<WithStreamedUnaryMethod_AddApplicationAction<WithStreamedUnaryMethod_RemoveApplicationAction<WithStreamedUnaryMethod_RegisterPeer<WithSplitStreamingMethod_GetPeers<WithStreamedUnaryMethod_DeletePeer<WithStreamedUnaryMethod_AddPeerAction<WithStreamedUnaryMethod_RemovePeerAction<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > StreamedService;
};

// *
// The service to control action and resource access.
class RbacService final {
 public:
  static constexpr char const* service_full_name() {
    return "resource.RbacService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // * Set the action resources permissions *
    virtual ::grpc::Status SetActionResourcesPermission(::grpc::ClientContext* context, const ::resource::SetActionResourcesPermissionRqst& request, ::resource::SetActionResourcesPermissionRsp* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::SetActionResourcesPermissionRsp>> AsyncSetActionResourcesPermission(::grpc::ClientContext* context, const ::resource::SetActionResourcesPermissionRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::SetActionResourcesPermissionRsp>>(AsyncSetActionResourcesPermissionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::SetActionResourcesPermissionRsp>> PrepareAsyncSetActionResourcesPermission(::grpc::ClientContext* context, const ::resource::SetActionResourcesPermissionRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::SetActionResourcesPermissionRsp>>(PrepareAsyncSetActionResourcesPermissionRaw(context, request, cq));
    }
    // * Get the action ressouces permission *
    virtual ::grpc::Status GetActionResourcesPermission(::grpc::ClientContext* context, const ::resource::GetActionResourcesPermissionRqst& request, ::resource::GetActionResourcesPermissionRsp* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::GetActionResourcesPermissionRsp>> AsyncGetActionResourcesPermission(::grpc::ClientContext* context, const ::resource::GetActionResourcesPermissionRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::GetActionResourcesPermissionRsp>>(AsyncGetActionResourcesPermissionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::GetActionResourcesPermissionRsp>> PrepareAsyncGetActionResourcesPermission(::grpc::ClientContext* context, const ::resource::GetActionResourcesPermissionRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::GetActionResourcesPermissionRsp>>(PrepareAsyncGetActionResourcesPermissionRaw(context, request, cq));
    }
    // * Set resource permissions this method will replace existing permission at once *
    virtual ::grpc::Status SetResourcePermissions(::grpc::ClientContext* context, const ::resource::SetResourcePermissionsRqst& request, ::resource::SetResourcePermissionsRqst* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::SetResourcePermissionsRqst>> AsyncSetResourcePermissions(::grpc::ClientContext* context, const ::resource::SetResourcePermissionsRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::SetResourcePermissionsRqst>>(AsyncSetResourcePermissionsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::SetResourcePermissionsRqst>> PrepareAsyncSetResourcePermissions(::grpc::ClientContext* context, const ::resource::SetResourcePermissionsRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::SetResourcePermissionsRqst>>(PrepareAsyncSetResourcePermissionsRaw(context, request, cq));
    }
    // * Delete a resource permissions (when a resource is deleted) *
    virtual ::grpc::Status DeleteResourcePermissions(::grpc::ClientContext* context, const ::resource::DeleteResourcePermissionsRqst& request, ::resource::DeleteResourcePermissionsRqst* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::DeleteResourcePermissionsRqst>> AsyncDeleteResourcePermissions(::grpc::ClientContext* context, const ::resource::DeleteResourcePermissionsRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::DeleteResourcePermissionsRqst>>(AsyncDeleteResourcePermissionsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::DeleteResourcePermissionsRqst>> PrepareAsyncDeleteResourcePermissions(::grpc::ClientContext* context, const ::resource::DeleteResourcePermissionsRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::DeleteResourcePermissionsRqst>>(PrepareAsyncDeleteResourcePermissionsRaw(context, request, cq));
    }
    // * Delete a specific resource permission *
    virtual ::grpc::Status DeleteResourcePermission(::grpc::ClientContext* context, const ::resource::DeleteResourcePermissionRqst& request, ::resource::DeleteResourcePermissionRqst* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::DeleteResourcePermissionRqst>> AsyncDeleteResourcePermission(::grpc::ClientContext* context, const ::resource::DeleteResourcePermissionRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::DeleteResourcePermissionRqst>>(AsyncDeleteResourcePermissionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::DeleteResourcePermissionRqst>> PrepareAsyncDeleteResourcePermission(::grpc::ClientContext* context, const ::resource::DeleteResourcePermissionRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::DeleteResourcePermissionRqst>>(PrepareAsyncDeleteResourcePermissionRaw(context, request, cq));
    }
    // * Set specific resource permission  ex. read permission... *
    virtual ::grpc::Status SetResourcePermission(::grpc::ClientContext* context, const ::resource::SetResourcePermissionRqst& request, ::resource::SetResourcePermissionRsp* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::SetResourcePermissionRsp>> AsyncSetResourcePermission(::grpc::ClientContext* context, const ::resource::SetResourcePermissionRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::SetResourcePermissionRsp>>(AsyncSetResourcePermissionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::SetResourcePermissionRsp>> PrepareAsyncSetResourcePermission(::grpc::ClientContext* context, const ::resource::SetResourcePermissionRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::SetResourcePermissionRsp>>(PrepareAsyncSetResourcePermissionRaw(context, request, cq));
    }
    // * Get a specific resource access *
    virtual ::grpc::Status GetResourcePermission(::grpc::ClientContext* context, const ::resource::GetResourcePermissionRqst& request, ::resource::GetResourcePermissionRsp* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::GetResourcePermissionRsp>> AsyncGetResourcePermission(::grpc::ClientContext* context, const ::resource::GetResourcePermissionRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::GetResourcePermissionRsp>>(AsyncGetResourcePermissionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::GetResourcePermissionRsp>> PrepareAsyncGetResourcePermission(::grpc::ClientContext* context, const ::resource::GetResourcePermissionRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::GetResourcePermissionRsp>>(PrepareAsyncGetResourcePermissionRaw(context, request, cq));
    }
    // * Get resource permissions *
    virtual ::grpc::Status GetResourcePermissions(::grpc::ClientContext* context, const ::resource::GetResourcePermissionsRqst& request, ::resource::GetResourcePermissionsRsp* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::GetResourcePermissionsRsp>> AsyncGetResourcePermissions(::grpc::ClientContext* context, const ::resource::GetResourcePermissionsRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::GetResourcePermissionsRsp>>(AsyncGetResourcePermissionsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::GetResourcePermissionsRsp>> PrepareAsyncGetResourcePermissions(::grpc::ClientContext* context, const ::resource::GetResourcePermissionsRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::GetResourcePermissionsRsp>>(PrepareAsyncGetResourcePermissionsRaw(context, request, cq));
    }
    // * Add resource owner do nothing if it already exist 
    virtual ::grpc::Status AddResourceOwner(::grpc::ClientContext* context, const ::resource::AddResourceOwnerRqst& request, ::resource::AddResourceOwnerRsp* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::AddResourceOwnerRsp>> AsyncAddResourceOwner(::grpc::ClientContext* context, const ::resource::AddResourceOwnerRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::AddResourceOwnerRsp>>(AsyncAddResourceOwnerRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::AddResourceOwnerRsp>> PrepareAsyncAddResourceOwner(::grpc::ClientContext* context, const ::resource::AddResourceOwnerRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::AddResourceOwnerRsp>>(PrepareAsyncAddResourceOwnerRaw(context, request, cq));
    }
    // * Remove resource owner 
    virtual ::grpc::Status removeResourceOwner(::grpc::ClientContext* context, const ::resource::AddResourceOwnerRqst& request, ::resource::AddResourceOwnerRsp* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::AddResourceOwnerRsp>> AsyncremoveResourceOwner(::grpc::ClientContext* context, const ::resource::AddResourceOwnerRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::AddResourceOwnerRsp>>(AsyncremoveResourceOwnerRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::AddResourceOwnerRsp>> PrepareAsyncremoveResourceOwner(::grpc::ClientContext* context, const ::resource::AddResourceOwnerRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::AddResourceOwnerRsp>>(PrepareAsyncremoveResourceOwnerRaw(context, request, cq));
    }
    // * That function must be call when a subject is removed to clean up permissions. 
    virtual ::grpc::Status deleteAllAccess(::grpc::ClientContext* context, const ::resource::deleteAllAccessRqst& request, ::resource::deleteAllAccessRsp* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::deleteAllAccessRsp>> AsyncdeleteAllAccess(::grpc::ClientContext* context, const ::resource::deleteAllAccessRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::deleteAllAccessRsp>>(AsyncdeleteAllAccessRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::deleteAllAccessRsp>> PrepareAsyncdeleteAllAccess(::grpc::ClientContext* context, const ::resource::deleteAllAccessRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::deleteAllAccessRsp>>(PrepareAsyncdeleteAllAccessRaw(context, request, cq));
    }
    // * Validate if a user can get access to a given ressource for a given operation (read, write...) *
    virtual ::grpc::Status validateAccess(::grpc::ClientContext* context, const ::resource::validateAccessRqst& request, ::resource::validateAccessRsp* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::validateAccessRsp>> AsyncvalidateAccess(::grpc::ClientContext* context, const ::resource::validateAccessRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::validateAccessRsp>>(AsyncvalidateAccessRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::validateAccessRsp>> PrepareAsyncvalidateAccess(::grpc::ClientContext* context, const ::resource::validateAccessRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::validateAccessRsp>>(PrepareAsyncvalidateAccessRaw(context, request, cq));
    }
    // * Return the list of access for a given subject 
    virtual ::grpc::Status getAccesses(::grpc::ClientContext* context, const ::resource::getAccessesRqst& request, ::resource::getAccessesRsp* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::getAccessesRsp>> AsyncgetAccesses(::grpc::ClientContext* context, const ::resource::getAccessesRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::getAccessesRsp>>(AsyncgetAccessesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::getAccessesRsp>> PrepareAsyncgetAccesses(::grpc::ClientContext* context, const ::resource::getAccessesRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::getAccessesRsp>>(PrepareAsyncgetAccessesRaw(context, request, cq));
    }
    class experimental_async_interface {
     public:
      virtual ~experimental_async_interface() {}
      // * Set the action resources permissions *
      virtual void SetActionResourcesPermission(::grpc::ClientContext* context, const ::resource::SetActionResourcesPermissionRqst* request, ::resource::SetActionResourcesPermissionRsp* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void SetActionResourcesPermission(::grpc::ClientContext* context, const ::resource::SetActionResourcesPermissionRqst* request, ::resource::SetActionResourcesPermissionRsp* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void SetActionResourcesPermission(::grpc::ClientContext* context, const ::resource::SetActionResourcesPermissionRqst* request, ::resource::SetActionResourcesPermissionRsp* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // * Get the action ressouces permission *
      virtual void GetActionResourcesPermission(::grpc::ClientContext* context, const ::resource::GetActionResourcesPermissionRqst* request, ::resource::GetActionResourcesPermissionRsp* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetActionResourcesPermission(::grpc::ClientContext* context, const ::resource::GetActionResourcesPermissionRqst* request, ::resource::GetActionResourcesPermissionRsp* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetActionResourcesPermission(::grpc::ClientContext* context, const ::resource::GetActionResourcesPermissionRqst* request, ::resource::GetActionResourcesPermissionRsp* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // * Set resource permissions this method will replace existing permission at once *
      virtual void SetResourcePermissions(::grpc::ClientContext* context, const ::resource::SetResourcePermissionsRqst* request, ::resource::SetResourcePermissionsRqst* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void SetResourcePermissions(::grpc::ClientContext* context, const ::resource::SetResourcePermissionsRqst* request, ::resource::SetResourcePermissionsRqst* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void SetResourcePermissions(::grpc::ClientContext* context, const ::resource::SetResourcePermissionsRqst* request, ::resource::SetResourcePermissionsRqst* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // * Delete a resource permissions (when a resource is deleted) *
      virtual void DeleteResourcePermissions(::grpc::ClientContext* context, const ::resource::DeleteResourcePermissionsRqst* request, ::resource::DeleteResourcePermissionsRqst* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void DeleteResourcePermissions(::grpc::ClientContext* context, const ::resource::DeleteResourcePermissionsRqst* request, ::resource::DeleteResourcePermissionsRqst* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void DeleteResourcePermissions(::grpc::ClientContext* context, const ::resource::DeleteResourcePermissionsRqst* request, ::resource::DeleteResourcePermissionsRqst* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // * Delete a specific resource permission *
      virtual void DeleteResourcePermission(::grpc::ClientContext* context, const ::resource::DeleteResourcePermissionRqst* request, ::resource::DeleteResourcePermissionRqst* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void DeleteResourcePermission(::grpc::ClientContext* context, const ::resource::DeleteResourcePermissionRqst* request, ::resource::DeleteResourcePermissionRqst* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void DeleteResourcePermission(::grpc::ClientContext* context, const ::resource::DeleteResourcePermissionRqst* request, ::resource::DeleteResourcePermissionRqst* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // * Set specific resource permission  ex. read permission... *
      virtual void SetResourcePermission(::grpc::ClientContext* context, const ::resource::SetResourcePermissionRqst* request, ::resource::SetResourcePermissionRsp* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void SetResourcePermission(::grpc::ClientContext* context, const ::resource::SetResourcePermissionRqst* request, ::resource::SetResourcePermissionRsp* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void SetResourcePermission(::grpc::ClientContext* context, const ::resource::SetResourcePermissionRqst* request, ::resource::SetResourcePermissionRsp* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // * Get a specific resource access *
      virtual void GetResourcePermission(::grpc::ClientContext* context, const ::resource::GetResourcePermissionRqst* request, ::resource::GetResourcePermissionRsp* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetResourcePermission(::grpc::ClientContext* context, const ::resource::GetResourcePermissionRqst* request, ::resource::GetResourcePermissionRsp* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetResourcePermission(::grpc::ClientContext* context, const ::resource::GetResourcePermissionRqst* request, ::resource::GetResourcePermissionRsp* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // * Get resource permissions *
      virtual void GetResourcePermissions(::grpc::ClientContext* context, const ::resource::GetResourcePermissionsRqst* request, ::resource::GetResourcePermissionsRsp* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetResourcePermissions(::grpc::ClientContext* context, const ::resource::GetResourcePermissionsRqst* request, ::resource::GetResourcePermissionsRsp* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetResourcePermissions(::grpc::ClientContext* context, const ::resource::GetResourcePermissionsRqst* request, ::resource::GetResourcePermissionsRsp* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // * Add resource owner do nothing if it already exist 
      virtual void AddResourceOwner(::grpc::ClientContext* context, const ::resource::AddResourceOwnerRqst* request, ::resource::AddResourceOwnerRsp* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void AddResourceOwner(::grpc::ClientContext* context, const ::resource::AddResourceOwnerRqst* request, ::resource::AddResourceOwnerRsp* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void AddResourceOwner(::grpc::ClientContext* context, const ::resource::AddResourceOwnerRqst* request, ::resource::AddResourceOwnerRsp* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // * Remove resource owner 
      virtual void removeResourceOwner(::grpc::ClientContext* context, const ::resource::AddResourceOwnerRqst* request, ::resource::AddResourceOwnerRsp* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void removeResourceOwner(::grpc::ClientContext* context, const ::resource::AddResourceOwnerRqst* request, ::resource::AddResourceOwnerRsp* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void removeResourceOwner(::grpc::ClientContext* context, const ::resource::AddResourceOwnerRqst* request, ::resource::AddResourceOwnerRsp* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // * That function must be call when a subject is removed to clean up permissions. 
      virtual void deleteAllAccess(::grpc::ClientContext* context, const ::resource::deleteAllAccessRqst* request, ::resource::deleteAllAccessRsp* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void deleteAllAccess(::grpc::ClientContext* context, const ::resource::deleteAllAccessRqst* request, ::resource::deleteAllAccessRsp* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void deleteAllAccess(::grpc::ClientContext* context, const ::resource::deleteAllAccessRqst* request, ::resource::deleteAllAccessRsp* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // * Validate if a user can get access to a given ressource for a given operation (read, write...) *
      virtual void validateAccess(::grpc::ClientContext* context, const ::resource::validateAccessRqst* request, ::resource::validateAccessRsp* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void validateAccess(::grpc::ClientContext* context, const ::resource::validateAccessRqst* request, ::resource::validateAccessRsp* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void validateAccess(::grpc::ClientContext* context, const ::resource::validateAccessRqst* request, ::resource::validateAccessRsp* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // * Return the list of access for a given subject 
      virtual void getAccesses(::grpc::ClientContext* context, const ::resource::getAccessesRqst* request, ::resource::getAccessesRsp* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void getAccesses(::grpc::ClientContext* context, const ::resource::getAccessesRqst* request, ::resource::getAccessesRsp* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void getAccesses(::grpc::ClientContext* context, const ::resource::getAccessesRqst* request, ::resource::getAccessesRsp* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
    };
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    typedef class experimental_async_interface async_interface;
    #endif
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    async_interface* async() { return experimental_async(); }
    #endif
    virtual class experimental_async_interface* experimental_async() { return nullptr; }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::resource::SetActionResourcesPermissionRsp>* AsyncSetActionResourcesPermissionRaw(::grpc::ClientContext* context, const ::resource::SetActionResourcesPermissionRqst& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::resource::SetActionResourcesPermissionRsp>* PrepareAsyncSetActionResourcesPermissionRaw(::grpc::ClientContext* context, const ::resource::SetActionResourcesPermissionRqst& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::resource::GetActionResourcesPermissionRsp>* AsyncGetActionResourcesPermissionRaw(::grpc::ClientContext* context, const ::resource::GetActionResourcesPermissionRqst& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::resource::GetActionResourcesPermissionRsp>* PrepareAsyncGetActionResourcesPermissionRaw(::grpc::ClientContext* context, const ::resource::GetActionResourcesPermissionRqst& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::resource::SetResourcePermissionsRqst>* AsyncSetResourcePermissionsRaw(::grpc::ClientContext* context, const ::resource::SetResourcePermissionsRqst& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::resource::SetResourcePermissionsRqst>* PrepareAsyncSetResourcePermissionsRaw(::grpc::ClientContext* context, const ::resource::SetResourcePermissionsRqst& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::resource::DeleteResourcePermissionsRqst>* AsyncDeleteResourcePermissionsRaw(::grpc::ClientContext* context, const ::resource::DeleteResourcePermissionsRqst& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::resource::DeleteResourcePermissionsRqst>* PrepareAsyncDeleteResourcePermissionsRaw(::grpc::ClientContext* context, const ::resource::DeleteResourcePermissionsRqst& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::resource::DeleteResourcePermissionRqst>* AsyncDeleteResourcePermissionRaw(::grpc::ClientContext* context, const ::resource::DeleteResourcePermissionRqst& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::resource::DeleteResourcePermissionRqst>* PrepareAsyncDeleteResourcePermissionRaw(::grpc::ClientContext* context, const ::resource::DeleteResourcePermissionRqst& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::resource::SetResourcePermissionRsp>* AsyncSetResourcePermissionRaw(::grpc::ClientContext* context, const ::resource::SetResourcePermissionRqst& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::resource::SetResourcePermissionRsp>* PrepareAsyncSetResourcePermissionRaw(::grpc::ClientContext* context, const ::resource::SetResourcePermissionRqst& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::resource::GetResourcePermissionRsp>* AsyncGetResourcePermissionRaw(::grpc::ClientContext* context, const ::resource::GetResourcePermissionRqst& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::resource::GetResourcePermissionRsp>* PrepareAsyncGetResourcePermissionRaw(::grpc::ClientContext* context, const ::resource::GetResourcePermissionRqst& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::resource::GetResourcePermissionsRsp>* AsyncGetResourcePermissionsRaw(::grpc::ClientContext* context, const ::resource::GetResourcePermissionsRqst& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::resource::GetResourcePermissionsRsp>* PrepareAsyncGetResourcePermissionsRaw(::grpc::ClientContext* context, const ::resource::GetResourcePermissionsRqst& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::resource::AddResourceOwnerRsp>* AsyncAddResourceOwnerRaw(::grpc::ClientContext* context, const ::resource::AddResourceOwnerRqst& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::resource::AddResourceOwnerRsp>* PrepareAsyncAddResourceOwnerRaw(::grpc::ClientContext* context, const ::resource::AddResourceOwnerRqst& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::resource::AddResourceOwnerRsp>* AsyncremoveResourceOwnerRaw(::grpc::ClientContext* context, const ::resource::AddResourceOwnerRqst& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::resource::AddResourceOwnerRsp>* PrepareAsyncremoveResourceOwnerRaw(::grpc::ClientContext* context, const ::resource::AddResourceOwnerRqst& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::resource::deleteAllAccessRsp>* AsyncdeleteAllAccessRaw(::grpc::ClientContext* context, const ::resource::deleteAllAccessRqst& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::resource::deleteAllAccessRsp>* PrepareAsyncdeleteAllAccessRaw(::grpc::ClientContext* context, const ::resource::deleteAllAccessRqst& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::resource::validateAccessRsp>* AsyncvalidateAccessRaw(::grpc::ClientContext* context, const ::resource::validateAccessRqst& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::resource::validateAccessRsp>* PrepareAsyncvalidateAccessRaw(::grpc::ClientContext* context, const ::resource::validateAccessRqst& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::resource::getAccessesRsp>* AsyncgetAccessesRaw(::grpc::ClientContext* context, const ::resource::getAccessesRqst& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::resource::getAccessesRsp>* PrepareAsyncgetAccessesRaw(::grpc::ClientContext* context, const ::resource::getAccessesRqst& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    ::grpc::Status SetActionResourcesPermission(::grpc::ClientContext* context, const ::resource::SetActionResourcesPermissionRqst& request, ::resource::SetActionResourcesPermissionRsp* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::SetActionResourcesPermissionRsp>> AsyncSetActionResourcesPermission(::grpc::ClientContext* context, const ::resource::SetActionResourcesPermissionRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::SetActionResourcesPermissionRsp>>(AsyncSetActionResourcesPermissionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::SetActionResourcesPermissionRsp>> PrepareAsyncSetActionResourcesPermission(::grpc::ClientContext* context, const ::resource::SetActionResourcesPermissionRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::SetActionResourcesPermissionRsp>>(PrepareAsyncSetActionResourcesPermissionRaw(context, request, cq));
    }
    ::grpc::Status GetActionResourcesPermission(::grpc::ClientContext* context, const ::resource::GetActionResourcesPermissionRqst& request, ::resource::GetActionResourcesPermissionRsp* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::GetActionResourcesPermissionRsp>> AsyncGetActionResourcesPermission(::grpc::ClientContext* context, const ::resource::GetActionResourcesPermissionRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::GetActionResourcesPermissionRsp>>(AsyncGetActionResourcesPermissionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::GetActionResourcesPermissionRsp>> PrepareAsyncGetActionResourcesPermission(::grpc::ClientContext* context, const ::resource::GetActionResourcesPermissionRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::GetActionResourcesPermissionRsp>>(PrepareAsyncGetActionResourcesPermissionRaw(context, request, cq));
    }
    ::grpc::Status SetResourcePermissions(::grpc::ClientContext* context, const ::resource::SetResourcePermissionsRqst& request, ::resource::SetResourcePermissionsRqst* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::SetResourcePermissionsRqst>> AsyncSetResourcePermissions(::grpc::ClientContext* context, const ::resource::SetResourcePermissionsRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::SetResourcePermissionsRqst>>(AsyncSetResourcePermissionsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::SetResourcePermissionsRqst>> PrepareAsyncSetResourcePermissions(::grpc::ClientContext* context, const ::resource::SetResourcePermissionsRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::SetResourcePermissionsRqst>>(PrepareAsyncSetResourcePermissionsRaw(context, request, cq));
    }
    ::grpc::Status DeleteResourcePermissions(::grpc::ClientContext* context, const ::resource::DeleteResourcePermissionsRqst& request, ::resource::DeleteResourcePermissionsRqst* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::DeleteResourcePermissionsRqst>> AsyncDeleteResourcePermissions(::grpc::ClientContext* context, const ::resource::DeleteResourcePermissionsRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::DeleteResourcePermissionsRqst>>(AsyncDeleteResourcePermissionsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::DeleteResourcePermissionsRqst>> PrepareAsyncDeleteResourcePermissions(::grpc::ClientContext* context, const ::resource::DeleteResourcePermissionsRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::DeleteResourcePermissionsRqst>>(PrepareAsyncDeleteResourcePermissionsRaw(context, request, cq));
    }
    ::grpc::Status DeleteResourcePermission(::grpc::ClientContext* context, const ::resource::DeleteResourcePermissionRqst& request, ::resource::DeleteResourcePermissionRqst* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::DeleteResourcePermissionRqst>> AsyncDeleteResourcePermission(::grpc::ClientContext* context, const ::resource::DeleteResourcePermissionRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::DeleteResourcePermissionRqst>>(AsyncDeleteResourcePermissionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::DeleteResourcePermissionRqst>> PrepareAsyncDeleteResourcePermission(::grpc::ClientContext* context, const ::resource::DeleteResourcePermissionRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::DeleteResourcePermissionRqst>>(PrepareAsyncDeleteResourcePermissionRaw(context, request, cq));
    }
    ::grpc::Status SetResourcePermission(::grpc::ClientContext* context, const ::resource::SetResourcePermissionRqst& request, ::resource::SetResourcePermissionRsp* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::SetResourcePermissionRsp>> AsyncSetResourcePermission(::grpc::ClientContext* context, const ::resource::SetResourcePermissionRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::SetResourcePermissionRsp>>(AsyncSetResourcePermissionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::SetResourcePermissionRsp>> PrepareAsyncSetResourcePermission(::grpc::ClientContext* context, const ::resource::SetResourcePermissionRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::SetResourcePermissionRsp>>(PrepareAsyncSetResourcePermissionRaw(context, request, cq));
    }
    ::grpc::Status GetResourcePermission(::grpc::ClientContext* context, const ::resource::GetResourcePermissionRqst& request, ::resource::GetResourcePermissionRsp* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::GetResourcePermissionRsp>> AsyncGetResourcePermission(::grpc::ClientContext* context, const ::resource::GetResourcePermissionRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::GetResourcePermissionRsp>>(AsyncGetResourcePermissionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::GetResourcePermissionRsp>> PrepareAsyncGetResourcePermission(::grpc::ClientContext* context, const ::resource::GetResourcePermissionRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::GetResourcePermissionRsp>>(PrepareAsyncGetResourcePermissionRaw(context, request, cq));
    }
    ::grpc::Status GetResourcePermissions(::grpc::ClientContext* context, const ::resource::GetResourcePermissionsRqst& request, ::resource::GetResourcePermissionsRsp* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::GetResourcePermissionsRsp>> AsyncGetResourcePermissions(::grpc::ClientContext* context, const ::resource::GetResourcePermissionsRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::GetResourcePermissionsRsp>>(AsyncGetResourcePermissionsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::GetResourcePermissionsRsp>> PrepareAsyncGetResourcePermissions(::grpc::ClientContext* context, const ::resource::GetResourcePermissionsRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::GetResourcePermissionsRsp>>(PrepareAsyncGetResourcePermissionsRaw(context, request, cq));
    }
    ::grpc::Status AddResourceOwner(::grpc::ClientContext* context, const ::resource::AddResourceOwnerRqst& request, ::resource::AddResourceOwnerRsp* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::AddResourceOwnerRsp>> AsyncAddResourceOwner(::grpc::ClientContext* context, const ::resource::AddResourceOwnerRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::AddResourceOwnerRsp>>(AsyncAddResourceOwnerRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::AddResourceOwnerRsp>> PrepareAsyncAddResourceOwner(::grpc::ClientContext* context, const ::resource::AddResourceOwnerRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::AddResourceOwnerRsp>>(PrepareAsyncAddResourceOwnerRaw(context, request, cq));
    }
    ::grpc::Status removeResourceOwner(::grpc::ClientContext* context, const ::resource::AddResourceOwnerRqst& request, ::resource::AddResourceOwnerRsp* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::AddResourceOwnerRsp>> AsyncremoveResourceOwner(::grpc::ClientContext* context, const ::resource::AddResourceOwnerRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::AddResourceOwnerRsp>>(AsyncremoveResourceOwnerRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::AddResourceOwnerRsp>> PrepareAsyncremoveResourceOwner(::grpc::ClientContext* context, const ::resource::AddResourceOwnerRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::AddResourceOwnerRsp>>(PrepareAsyncremoveResourceOwnerRaw(context, request, cq));
    }
    ::grpc::Status deleteAllAccess(::grpc::ClientContext* context, const ::resource::deleteAllAccessRqst& request, ::resource::deleteAllAccessRsp* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::deleteAllAccessRsp>> AsyncdeleteAllAccess(::grpc::ClientContext* context, const ::resource::deleteAllAccessRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::deleteAllAccessRsp>>(AsyncdeleteAllAccessRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::deleteAllAccessRsp>> PrepareAsyncdeleteAllAccess(::grpc::ClientContext* context, const ::resource::deleteAllAccessRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::deleteAllAccessRsp>>(PrepareAsyncdeleteAllAccessRaw(context, request, cq));
    }
    ::grpc::Status validateAccess(::grpc::ClientContext* context, const ::resource::validateAccessRqst& request, ::resource::validateAccessRsp* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::validateAccessRsp>> AsyncvalidateAccess(::grpc::ClientContext* context, const ::resource::validateAccessRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::validateAccessRsp>>(AsyncvalidateAccessRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::validateAccessRsp>> PrepareAsyncvalidateAccess(::grpc::ClientContext* context, const ::resource::validateAccessRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::validateAccessRsp>>(PrepareAsyncvalidateAccessRaw(context, request, cq));
    }
    ::grpc::Status getAccesses(::grpc::ClientContext* context, const ::resource::getAccessesRqst& request, ::resource::getAccessesRsp* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::getAccessesRsp>> AsyncgetAccesses(::grpc::ClientContext* context, const ::resource::getAccessesRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::getAccessesRsp>>(AsyncgetAccessesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::getAccessesRsp>> PrepareAsyncgetAccesses(::grpc::ClientContext* context, const ::resource::getAccessesRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::getAccessesRsp>>(PrepareAsyncgetAccessesRaw(context, request, cq));
    }
    class experimental_async final :
      public StubInterface::experimental_async_interface {
     public:
      void SetActionResourcesPermission(::grpc::ClientContext* context, const ::resource::SetActionResourcesPermissionRqst* request, ::resource::SetActionResourcesPermissionRsp* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void SetActionResourcesPermission(::grpc::ClientContext* context, const ::resource::SetActionResourcesPermissionRqst* request, ::resource::SetActionResourcesPermissionRsp* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void SetActionResourcesPermission(::grpc::ClientContext* context, const ::resource::SetActionResourcesPermissionRqst* request, ::resource::SetActionResourcesPermissionRsp* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetActionResourcesPermission(::grpc::ClientContext* context, const ::resource::GetActionResourcesPermissionRqst* request, ::resource::GetActionResourcesPermissionRsp* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetActionResourcesPermission(::grpc::ClientContext* context, const ::resource::GetActionResourcesPermissionRqst* request, ::resource::GetActionResourcesPermissionRsp* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetActionResourcesPermission(::grpc::ClientContext* context, const ::resource::GetActionResourcesPermissionRqst* request, ::resource::GetActionResourcesPermissionRsp* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void SetResourcePermissions(::grpc::ClientContext* context, const ::resource::SetResourcePermissionsRqst* request, ::resource::SetResourcePermissionsRqst* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void SetResourcePermissions(::grpc::ClientContext* context, const ::resource::SetResourcePermissionsRqst* request, ::resource::SetResourcePermissionsRqst* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void SetResourcePermissions(::grpc::ClientContext* context, const ::resource::SetResourcePermissionsRqst* request, ::resource::SetResourcePermissionsRqst* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void DeleteResourcePermissions(::grpc::ClientContext* context, const ::resource::DeleteResourcePermissionsRqst* request, ::resource::DeleteResourcePermissionsRqst* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void DeleteResourcePermissions(::grpc::ClientContext* context, const ::resource::DeleteResourcePermissionsRqst* request, ::resource::DeleteResourcePermissionsRqst* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void DeleteResourcePermissions(::grpc::ClientContext* context, const ::resource::DeleteResourcePermissionsRqst* request, ::resource::DeleteResourcePermissionsRqst* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void DeleteResourcePermission(::grpc::ClientContext* context, const ::resource::DeleteResourcePermissionRqst* request, ::resource::DeleteResourcePermissionRqst* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void DeleteResourcePermission(::grpc::ClientContext* context, const ::resource::DeleteResourcePermissionRqst* request, ::resource::DeleteResourcePermissionRqst* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void DeleteResourcePermission(::grpc::ClientContext* context, const ::resource::DeleteResourcePermissionRqst* request, ::resource::DeleteResourcePermissionRqst* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void SetResourcePermission(::grpc::ClientContext* context, const ::resource::SetResourcePermissionRqst* request, ::resource::SetResourcePermissionRsp* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void SetResourcePermission(::grpc::ClientContext* context, const ::resource::SetResourcePermissionRqst* request, ::resource::SetResourcePermissionRsp* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void SetResourcePermission(::grpc::ClientContext* context, const ::resource::SetResourcePermissionRqst* request, ::resource::SetResourcePermissionRsp* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetResourcePermission(::grpc::ClientContext* context, const ::resource::GetResourcePermissionRqst* request, ::resource::GetResourcePermissionRsp* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetResourcePermission(::grpc::ClientContext* context, const ::resource::GetResourcePermissionRqst* request, ::resource::GetResourcePermissionRsp* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetResourcePermission(::grpc::ClientContext* context, const ::resource::GetResourcePermissionRqst* request, ::resource::GetResourcePermissionRsp* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetResourcePermissions(::grpc::ClientContext* context, const ::resource::GetResourcePermissionsRqst* request, ::resource::GetResourcePermissionsRsp* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetResourcePermissions(::grpc::ClientContext* context, const ::resource::GetResourcePermissionsRqst* request, ::resource::GetResourcePermissionsRsp* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetResourcePermissions(::grpc::ClientContext* context, const ::resource::GetResourcePermissionsRqst* request, ::resource::GetResourcePermissionsRsp* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void AddResourceOwner(::grpc::ClientContext* context, const ::resource::AddResourceOwnerRqst* request, ::resource::AddResourceOwnerRsp* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void AddResourceOwner(::grpc::ClientContext* context, const ::resource::AddResourceOwnerRqst* request, ::resource::AddResourceOwnerRsp* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void AddResourceOwner(::grpc::ClientContext* context, const ::resource::AddResourceOwnerRqst* request, ::resource::AddResourceOwnerRsp* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void removeResourceOwner(::grpc::ClientContext* context, const ::resource::AddResourceOwnerRqst* request, ::resource::AddResourceOwnerRsp* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void removeResourceOwner(::grpc::ClientContext* context, const ::resource::AddResourceOwnerRqst* request, ::resource::AddResourceOwnerRsp* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void removeResourceOwner(::grpc::ClientContext* context, const ::resource::AddResourceOwnerRqst* request, ::resource::AddResourceOwnerRsp* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void deleteAllAccess(::grpc::ClientContext* context, const ::resource::deleteAllAccessRqst* request, ::resource::deleteAllAccessRsp* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void deleteAllAccess(::grpc::ClientContext* context, const ::resource::deleteAllAccessRqst* request, ::resource::deleteAllAccessRsp* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void deleteAllAccess(::grpc::ClientContext* context, const ::resource::deleteAllAccessRqst* request, ::resource::deleteAllAccessRsp* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void validateAccess(::grpc::ClientContext* context, const ::resource::validateAccessRqst* request, ::resource::validateAccessRsp* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void validateAccess(::grpc::ClientContext* context, const ::resource::validateAccessRqst* request, ::resource::validateAccessRsp* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void validateAccess(::grpc::ClientContext* context, const ::resource::validateAccessRqst* request, ::resource::validateAccessRsp* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void getAccesses(::grpc::ClientContext* context, const ::resource::getAccessesRqst* request, ::resource::getAccessesRsp* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void getAccesses(::grpc::ClientContext* context, const ::resource::getAccessesRqst* request, ::resource::getAccessesRsp* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void getAccesses(::grpc::ClientContext* context, const ::resource::getAccessesRqst* request, ::resource::getAccessesRsp* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
     private:
      friend class Stub;
      explicit experimental_async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class experimental_async_interface* experimental_async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class experimental_async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::resource::SetActionResourcesPermissionRsp>* AsyncSetActionResourcesPermissionRaw(::grpc::ClientContext* context, const ::resource::SetActionResourcesPermissionRqst& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::resource::SetActionResourcesPermissionRsp>* PrepareAsyncSetActionResourcesPermissionRaw(::grpc::ClientContext* context, const ::resource::SetActionResourcesPermissionRqst& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::resource::GetActionResourcesPermissionRsp>* AsyncGetActionResourcesPermissionRaw(::grpc::ClientContext* context, const ::resource::GetActionResourcesPermissionRqst& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::resource::GetActionResourcesPermissionRsp>* PrepareAsyncGetActionResourcesPermissionRaw(::grpc::ClientContext* context, const ::resource::GetActionResourcesPermissionRqst& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::resource::SetResourcePermissionsRqst>* AsyncSetResourcePermissionsRaw(::grpc::ClientContext* context, const ::resource::SetResourcePermissionsRqst& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::resource::SetResourcePermissionsRqst>* PrepareAsyncSetResourcePermissionsRaw(::grpc::ClientContext* context, const ::resource::SetResourcePermissionsRqst& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::resource::DeleteResourcePermissionsRqst>* AsyncDeleteResourcePermissionsRaw(::grpc::ClientContext* context, const ::resource::DeleteResourcePermissionsRqst& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::resource::DeleteResourcePermissionsRqst>* PrepareAsyncDeleteResourcePermissionsRaw(::grpc::ClientContext* context, const ::resource::DeleteResourcePermissionsRqst& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::resource::DeleteResourcePermissionRqst>* AsyncDeleteResourcePermissionRaw(::grpc::ClientContext* context, const ::resource::DeleteResourcePermissionRqst& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::resource::DeleteResourcePermissionRqst>* PrepareAsyncDeleteResourcePermissionRaw(::grpc::ClientContext* context, const ::resource::DeleteResourcePermissionRqst& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::resource::SetResourcePermissionRsp>* AsyncSetResourcePermissionRaw(::grpc::ClientContext* context, const ::resource::SetResourcePermissionRqst& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::resource::SetResourcePermissionRsp>* PrepareAsyncSetResourcePermissionRaw(::grpc::ClientContext* context, const ::resource::SetResourcePermissionRqst& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::resource::GetResourcePermissionRsp>* AsyncGetResourcePermissionRaw(::grpc::ClientContext* context, const ::resource::GetResourcePermissionRqst& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::resource::GetResourcePermissionRsp>* PrepareAsyncGetResourcePermissionRaw(::grpc::ClientContext* context, const ::resource::GetResourcePermissionRqst& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::resource::GetResourcePermissionsRsp>* AsyncGetResourcePermissionsRaw(::grpc::ClientContext* context, const ::resource::GetResourcePermissionsRqst& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::resource::GetResourcePermissionsRsp>* PrepareAsyncGetResourcePermissionsRaw(::grpc::ClientContext* context, const ::resource::GetResourcePermissionsRqst& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::resource::AddResourceOwnerRsp>* AsyncAddResourceOwnerRaw(::grpc::ClientContext* context, const ::resource::AddResourceOwnerRqst& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::resource::AddResourceOwnerRsp>* PrepareAsyncAddResourceOwnerRaw(::grpc::ClientContext* context, const ::resource::AddResourceOwnerRqst& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::resource::AddResourceOwnerRsp>* AsyncremoveResourceOwnerRaw(::grpc::ClientContext* context, const ::resource::AddResourceOwnerRqst& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::resource::AddResourceOwnerRsp>* PrepareAsyncremoveResourceOwnerRaw(::grpc::ClientContext* context, const ::resource::AddResourceOwnerRqst& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::resource::deleteAllAccessRsp>* AsyncdeleteAllAccessRaw(::grpc::ClientContext* context, const ::resource::deleteAllAccessRqst& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::resource::deleteAllAccessRsp>* PrepareAsyncdeleteAllAccessRaw(::grpc::ClientContext* context, const ::resource::deleteAllAccessRqst& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::resource::validateAccessRsp>* AsyncvalidateAccessRaw(::grpc::ClientContext* context, const ::resource::validateAccessRqst& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::resource::validateAccessRsp>* PrepareAsyncvalidateAccessRaw(::grpc::ClientContext* context, const ::resource::validateAccessRqst& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::resource::getAccessesRsp>* AsyncgetAccessesRaw(::grpc::ClientContext* context, const ::resource::getAccessesRqst& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::resource::getAccessesRsp>* PrepareAsyncgetAccessesRaw(::grpc::ClientContext* context, const ::resource::getAccessesRqst& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_SetActionResourcesPermission_;
    const ::grpc::internal::RpcMethod rpcmethod_GetActionResourcesPermission_;
    const ::grpc::internal::RpcMethod rpcmethod_SetResourcePermissions_;
    const ::grpc::internal::RpcMethod rpcmethod_DeleteResourcePermissions_;
    const ::grpc::internal::RpcMethod rpcmethod_DeleteResourcePermission_;
    const ::grpc::internal::RpcMethod rpcmethod_SetResourcePermission_;
    const ::grpc::internal::RpcMethod rpcmethod_GetResourcePermission_;
    const ::grpc::internal::RpcMethod rpcmethod_GetResourcePermissions_;
    const ::grpc::internal::RpcMethod rpcmethod_AddResourceOwner_;
    const ::grpc::internal::RpcMethod rpcmethod_removeResourceOwner_;
    const ::grpc::internal::RpcMethod rpcmethod_deleteAllAccess_;
    const ::grpc::internal::RpcMethod rpcmethod_validateAccess_;
    const ::grpc::internal::RpcMethod rpcmethod_getAccesses_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // * Set the action resources permissions *
    virtual ::grpc::Status SetActionResourcesPermission(::grpc::ServerContext* context, const ::resource::SetActionResourcesPermissionRqst* request, ::resource::SetActionResourcesPermissionRsp* response);
    // * Get the action ressouces permission *
    virtual ::grpc::Status GetActionResourcesPermission(::grpc::ServerContext* context, const ::resource::GetActionResourcesPermissionRqst* request, ::resource::GetActionResourcesPermissionRsp* response);
    // * Set resource permissions this method will replace existing permission at once *
    virtual ::grpc::Status SetResourcePermissions(::grpc::ServerContext* context, const ::resource::SetResourcePermissionsRqst* request, ::resource::SetResourcePermissionsRqst* response);
    // * Delete a resource permissions (when a resource is deleted) *
    virtual ::grpc::Status DeleteResourcePermissions(::grpc::ServerContext* context, const ::resource::DeleteResourcePermissionsRqst* request, ::resource::DeleteResourcePermissionsRqst* response);
    // * Delete a specific resource permission *
    virtual ::grpc::Status DeleteResourcePermission(::grpc::ServerContext* context, const ::resource::DeleteResourcePermissionRqst* request, ::resource::DeleteResourcePermissionRqst* response);
    // * Set specific resource permission  ex. read permission... *
    virtual ::grpc::Status SetResourcePermission(::grpc::ServerContext* context, const ::resource::SetResourcePermissionRqst* request, ::resource::SetResourcePermissionRsp* response);
    // * Get a specific resource access *
    virtual ::grpc::Status GetResourcePermission(::grpc::ServerContext* context, const ::resource::GetResourcePermissionRqst* request, ::resource::GetResourcePermissionRsp* response);
    // * Get resource permissions *
    virtual ::grpc::Status GetResourcePermissions(::grpc::ServerContext* context, const ::resource::GetResourcePermissionsRqst* request, ::resource::GetResourcePermissionsRsp* response);
    // * Add resource owner do nothing if it already exist 
    virtual ::grpc::Status AddResourceOwner(::grpc::ServerContext* context, const ::resource::AddResourceOwnerRqst* request, ::resource::AddResourceOwnerRsp* response);
    // * Remove resource owner 
    virtual ::grpc::Status removeResourceOwner(::grpc::ServerContext* context, const ::resource::AddResourceOwnerRqst* request, ::resource::AddResourceOwnerRsp* response);
    // * That function must be call when a subject is removed to clean up permissions. 
    virtual ::grpc::Status deleteAllAccess(::grpc::ServerContext* context, const ::resource::deleteAllAccessRqst* request, ::resource::deleteAllAccessRsp* response);
    // * Validate if a user can get access to a given ressource for a given operation (read, write...) *
    virtual ::grpc::Status validateAccess(::grpc::ServerContext* context, const ::resource::validateAccessRqst* request, ::resource::validateAccessRsp* response);
    // * Return the list of access for a given subject 
    virtual ::grpc::Status getAccesses(::grpc::ServerContext* context, const ::resource::getAccessesRqst* request, ::resource::getAccessesRsp* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_SetActionResourcesPermission : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetActionResourcesPermission() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_SetActionResourcesPermission() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetActionResourcesPermission(::grpc::ServerContext* /*context*/, const ::resource::SetActionResourcesPermissionRqst* /*request*/, ::resource::SetActionResourcesPermissionRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetActionResourcesPermission(::grpc::ServerContext* context, ::resource::SetActionResourcesPermissionRqst* request, ::grpc::ServerAsyncResponseWriter< ::resource::SetActionResourcesPermissionRsp>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetActionResourcesPermission : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetActionResourcesPermission() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_GetActionResourcesPermission() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetActionResourcesPermission(::grpc::ServerContext* /*context*/, const ::resource::GetActionResourcesPermissionRqst* /*request*/, ::resource::GetActionResourcesPermissionRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetActionResourcesPermission(::grpc::ServerContext* context, ::resource::GetActionResourcesPermissionRqst* request, ::grpc::ServerAsyncResponseWriter< ::resource::GetActionResourcesPermissionRsp>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetResourcePermissions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetResourcePermissions() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_SetResourcePermissions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetResourcePermissions(::grpc::ServerContext* /*context*/, const ::resource::SetResourcePermissionsRqst* /*request*/, ::resource::SetResourcePermissionsRqst* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetResourcePermissions(::grpc::ServerContext* context, ::resource::SetResourcePermissionsRqst* request, ::grpc::ServerAsyncResponseWriter< ::resource::SetResourcePermissionsRqst>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DeleteResourcePermissions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_DeleteResourcePermissions() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_DeleteResourcePermissions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteResourcePermissions(::grpc::ServerContext* /*context*/, const ::resource::DeleteResourcePermissionsRqst* /*request*/, ::resource::DeleteResourcePermissionsRqst* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteResourcePermissions(::grpc::ServerContext* context, ::resource::DeleteResourcePermissionsRqst* request, ::grpc::ServerAsyncResponseWriter< ::resource::DeleteResourcePermissionsRqst>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DeleteResourcePermission : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_DeleteResourcePermission() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_DeleteResourcePermission() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteResourcePermission(::grpc::ServerContext* /*context*/, const ::resource::DeleteResourcePermissionRqst* /*request*/, ::resource::DeleteResourcePermissionRqst* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteResourcePermission(::grpc::ServerContext* context, ::resource::DeleteResourcePermissionRqst* request, ::grpc::ServerAsyncResponseWriter< ::resource::DeleteResourcePermissionRqst>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetResourcePermission : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetResourcePermission() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_SetResourcePermission() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetResourcePermission(::grpc::ServerContext* /*context*/, const ::resource::SetResourcePermissionRqst* /*request*/, ::resource::SetResourcePermissionRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetResourcePermission(::grpc::ServerContext* context, ::resource::SetResourcePermissionRqst* request, ::grpc::ServerAsyncResponseWriter< ::resource::SetResourcePermissionRsp>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetResourcePermission : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetResourcePermission() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_GetResourcePermission() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetResourcePermission(::grpc::ServerContext* /*context*/, const ::resource::GetResourcePermissionRqst* /*request*/, ::resource::GetResourcePermissionRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetResourcePermission(::grpc::ServerContext* context, ::resource::GetResourcePermissionRqst* request, ::grpc::ServerAsyncResponseWriter< ::resource::GetResourcePermissionRsp>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetResourcePermissions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetResourcePermissions() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_GetResourcePermissions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetResourcePermissions(::grpc::ServerContext* /*context*/, const ::resource::GetResourcePermissionsRqst* /*request*/, ::resource::GetResourcePermissionsRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetResourcePermissions(::grpc::ServerContext* context, ::resource::GetResourcePermissionsRqst* request, ::grpc::ServerAsyncResponseWriter< ::resource::GetResourcePermissionsRsp>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_AddResourceOwner : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_AddResourceOwner() {
      ::grpc::Service::MarkMethodAsync(8);
    }
    ~WithAsyncMethod_AddResourceOwner() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AddResourceOwner(::grpc::ServerContext* /*context*/, const ::resource::AddResourceOwnerRqst* /*request*/, ::resource::AddResourceOwnerRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAddResourceOwner(::grpc::ServerContext* context, ::resource::AddResourceOwnerRqst* request, ::grpc::ServerAsyncResponseWriter< ::resource::AddResourceOwnerRsp>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_removeResourceOwner : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_removeResourceOwner() {
      ::grpc::Service::MarkMethodAsync(9);
    }
    ~WithAsyncMethod_removeResourceOwner() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status removeResourceOwner(::grpc::ServerContext* /*context*/, const ::resource::AddResourceOwnerRqst* /*request*/, ::resource::AddResourceOwnerRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestremoveResourceOwner(::grpc::ServerContext* context, ::resource::AddResourceOwnerRqst* request, ::grpc::ServerAsyncResponseWriter< ::resource::AddResourceOwnerRsp>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_deleteAllAccess : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_deleteAllAccess() {
      ::grpc::Service::MarkMethodAsync(10);
    }
    ~WithAsyncMethod_deleteAllAccess() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status deleteAllAccess(::grpc::ServerContext* /*context*/, const ::resource::deleteAllAccessRqst* /*request*/, ::resource::deleteAllAccessRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestdeleteAllAccess(::grpc::ServerContext* context, ::resource::deleteAllAccessRqst* request, ::grpc::ServerAsyncResponseWriter< ::resource::deleteAllAccessRsp>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_validateAccess : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_validateAccess() {
      ::grpc::Service::MarkMethodAsync(11);
    }
    ~WithAsyncMethod_validateAccess() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status validateAccess(::grpc::ServerContext* /*context*/, const ::resource::validateAccessRqst* /*request*/, ::resource::validateAccessRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestvalidateAccess(::grpc::ServerContext* context, ::resource::validateAccessRqst* request, ::grpc::ServerAsyncResponseWriter< ::resource::validateAccessRsp>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_getAccesses : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_getAccesses() {
      ::grpc::Service::MarkMethodAsync(12);
    }
    ~WithAsyncMethod_getAccesses() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getAccesses(::grpc::ServerContext* /*context*/, const ::resource::getAccessesRqst* /*request*/, ::resource::getAccessesRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetAccesses(::grpc::ServerContext* context, ::resource::getAccessesRqst* request, ::grpc::ServerAsyncResponseWriter< ::resource::getAccessesRsp>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_SetActionResourcesPermission<WithAsyncMethod_GetActionResourcesPermission<WithAsyncMethod_SetResourcePermissions<WithAsyncMethod_DeleteResourcePermissions<WithAsyncMethod_DeleteResourcePermission<WithAsyncMethod_SetResourcePermission<WithAsyncMethod_GetResourcePermission<WithAsyncMethod_GetResourcePermissions<WithAsyncMethod_AddResourceOwner<WithAsyncMethod_removeResourceOwner<WithAsyncMethod_deleteAllAccess<WithAsyncMethod_validateAccess<WithAsyncMethod_getAccesses<Service > > > > > > > > > > > > > AsyncService;
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SetActionResourcesPermission : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_SetActionResourcesPermission() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::resource::SetActionResourcesPermissionRqst, ::resource::SetActionResourcesPermissionRsp>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::resource::SetActionResourcesPermissionRqst* request, ::resource::SetActionResourcesPermissionRsp* response) { return this->SetActionResourcesPermission(context, request, response); }));}
    void SetMessageAllocatorFor_SetActionResourcesPermission(
        ::grpc::experimental::MessageAllocator< ::resource::SetActionResourcesPermissionRqst, ::resource::SetActionResourcesPermissionRsp>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(0);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::resource::SetActionResourcesPermissionRqst, ::resource::SetActionResourcesPermissionRsp>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_SetActionResourcesPermission() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetActionResourcesPermission(::grpc::ServerContext* /*context*/, const ::resource::SetActionResourcesPermissionRqst* /*request*/, ::resource::SetActionResourcesPermissionRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* SetActionResourcesPermission(
      ::grpc::CallbackServerContext* /*context*/, const ::resource::SetActionResourcesPermissionRqst* /*request*/, ::resource::SetActionResourcesPermissionRsp* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* SetActionResourcesPermission(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::resource::SetActionResourcesPermissionRqst* /*request*/, ::resource::SetActionResourcesPermissionRsp* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetActionResourcesPermission : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetActionResourcesPermission() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::resource::GetActionResourcesPermissionRqst, ::resource::GetActionResourcesPermissionRsp>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::resource::GetActionResourcesPermissionRqst* request, ::resource::GetActionResourcesPermissionRsp* response) { return this->GetActionResourcesPermission(context, request, response); }));}
    void SetMessageAllocatorFor_GetActionResourcesPermission(
        ::grpc::experimental::MessageAllocator< ::resource::GetActionResourcesPermissionRqst, ::resource::GetActionResourcesPermissionRsp>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(1);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::resource::GetActionResourcesPermissionRqst, ::resource::GetActionResourcesPermissionRsp>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetActionResourcesPermission() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetActionResourcesPermission(::grpc::ServerContext* /*context*/, const ::resource::GetActionResourcesPermissionRqst* /*request*/, ::resource::GetActionResourcesPermissionRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetActionResourcesPermission(
      ::grpc::CallbackServerContext* /*context*/, const ::resource::GetActionResourcesPermissionRqst* /*request*/, ::resource::GetActionResourcesPermissionRsp* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetActionResourcesPermission(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::resource::GetActionResourcesPermissionRqst* /*request*/, ::resource::GetActionResourcesPermissionRsp* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SetResourcePermissions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_SetResourcePermissions() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::resource::SetResourcePermissionsRqst, ::resource::SetResourcePermissionsRqst>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::resource::SetResourcePermissionsRqst* request, ::resource::SetResourcePermissionsRqst* response) { return this->SetResourcePermissions(context, request, response); }));}
    void SetMessageAllocatorFor_SetResourcePermissions(
        ::grpc::experimental::MessageAllocator< ::resource::SetResourcePermissionsRqst, ::resource::SetResourcePermissionsRqst>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(2);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::resource::SetResourcePermissionsRqst, ::resource::SetResourcePermissionsRqst>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_SetResourcePermissions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetResourcePermissions(::grpc::ServerContext* /*context*/, const ::resource::SetResourcePermissionsRqst* /*request*/, ::resource::SetResourcePermissionsRqst* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* SetResourcePermissions(
      ::grpc::CallbackServerContext* /*context*/, const ::resource::SetResourcePermissionsRqst* /*request*/, ::resource::SetResourcePermissionsRqst* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* SetResourcePermissions(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::resource::SetResourcePermissionsRqst* /*request*/, ::resource::SetResourcePermissionsRqst* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_DeleteResourcePermissions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_DeleteResourcePermissions() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::resource::DeleteResourcePermissionsRqst, ::resource::DeleteResourcePermissionsRqst>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::resource::DeleteResourcePermissionsRqst* request, ::resource::DeleteResourcePermissionsRqst* response) { return this->DeleteResourcePermissions(context, request, response); }));}
    void SetMessageAllocatorFor_DeleteResourcePermissions(
        ::grpc::experimental::MessageAllocator< ::resource::DeleteResourcePermissionsRqst, ::resource::DeleteResourcePermissionsRqst>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(3);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::resource::DeleteResourcePermissionsRqst, ::resource::DeleteResourcePermissionsRqst>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_DeleteResourcePermissions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteResourcePermissions(::grpc::ServerContext* /*context*/, const ::resource::DeleteResourcePermissionsRqst* /*request*/, ::resource::DeleteResourcePermissionsRqst* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DeleteResourcePermissions(
      ::grpc::CallbackServerContext* /*context*/, const ::resource::DeleteResourcePermissionsRqst* /*request*/, ::resource::DeleteResourcePermissionsRqst* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DeleteResourcePermissions(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::resource::DeleteResourcePermissionsRqst* /*request*/, ::resource::DeleteResourcePermissionsRqst* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_DeleteResourcePermission : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_DeleteResourcePermission() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::resource::DeleteResourcePermissionRqst, ::resource::DeleteResourcePermissionRqst>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::resource::DeleteResourcePermissionRqst* request, ::resource::DeleteResourcePermissionRqst* response) { return this->DeleteResourcePermission(context, request, response); }));}
    void SetMessageAllocatorFor_DeleteResourcePermission(
        ::grpc::experimental::MessageAllocator< ::resource::DeleteResourcePermissionRqst, ::resource::DeleteResourcePermissionRqst>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(4);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::resource::DeleteResourcePermissionRqst, ::resource::DeleteResourcePermissionRqst>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_DeleteResourcePermission() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteResourcePermission(::grpc::ServerContext* /*context*/, const ::resource::DeleteResourcePermissionRqst* /*request*/, ::resource::DeleteResourcePermissionRqst* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DeleteResourcePermission(
      ::grpc::CallbackServerContext* /*context*/, const ::resource::DeleteResourcePermissionRqst* /*request*/, ::resource::DeleteResourcePermissionRqst* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DeleteResourcePermission(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::resource::DeleteResourcePermissionRqst* /*request*/, ::resource::DeleteResourcePermissionRqst* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SetResourcePermission : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_SetResourcePermission() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::resource::SetResourcePermissionRqst, ::resource::SetResourcePermissionRsp>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::resource::SetResourcePermissionRqst* request, ::resource::SetResourcePermissionRsp* response) { return this->SetResourcePermission(context, request, response); }));}
    void SetMessageAllocatorFor_SetResourcePermission(
        ::grpc::experimental::MessageAllocator< ::resource::SetResourcePermissionRqst, ::resource::SetResourcePermissionRsp>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(5);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(5);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::resource::SetResourcePermissionRqst, ::resource::SetResourcePermissionRsp>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_SetResourcePermission() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetResourcePermission(::grpc::ServerContext* /*context*/, const ::resource::SetResourcePermissionRqst* /*request*/, ::resource::SetResourcePermissionRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* SetResourcePermission(
      ::grpc::CallbackServerContext* /*context*/, const ::resource::SetResourcePermissionRqst* /*request*/, ::resource::SetResourcePermissionRsp* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* SetResourcePermission(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::resource::SetResourcePermissionRqst* /*request*/, ::resource::SetResourcePermissionRsp* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetResourcePermission : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetResourcePermission() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::resource::GetResourcePermissionRqst, ::resource::GetResourcePermissionRsp>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::resource::GetResourcePermissionRqst* request, ::resource::GetResourcePermissionRsp* response) { return this->GetResourcePermission(context, request, response); }));}
    void SetMessageAllocatorFor_GetResourcePermission(
        ::grpc::experimental::MessageAllocator< ::resource::GetResourcePermissionRqst, ::resource::GetResourcePermissionRsp>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(6);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(6);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::resource::GetResourcePermissionRqst, ::resource::GetResourcePermissionRsp>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetResourcePermission() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetResourcePermission(::grpc::ServerContext* /*context*/, const ::resource::GetResourcePermissionRqst* /*request*/, ::resource::GetResourcePermissionRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetResourcePermission(
      ::grpc::CallbackServerContext* /*context*/, const ::resource::GetResourcePermissionRqst* /*request*/, ::resource::GetResourcePermissionRsp* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetResourcePermission(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::resource::GetResourcePermissionRqst* /*request*/, ::resource::GetResourcePermissionRsp* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetResourcePermissions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetResourcePermissions() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::resource::GetResourcePermissionsRqst, ::resource::GetResourcePermissionsRsp>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::resource::GetResourcePermissionsRqst* request, ::resource::GetResourcePermissionsRsp* response) { return this->GetResourcePermissions(context, request, response); }));}
    void SetMessageAllocatorFor_GetResourcePermissions(
        ::grpc::experimental::MessageAllocator< ::resource::GetResourcePermissionsRqst, ::resource::GetResourcePermissionsRsp>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(7);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(7);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::resource::GetResourcePermissionsRqst, ::resource::GetResourcePermissionsRsp>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetResourcePermissions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetResourcePermissions(::grpc::ServerContext* /*context*/, const ::resource::GetResourcePermissionsRqst* /*request*/, ::resource::GetResourcePermissionsRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetResourcePermissions(
      ::grpc::CallbackServerContext* /*context*/, const ::resource::GetResourcePermissionsRqst* /*request*/, ::resource::GetResourcePermissionsRsp* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetResourcePermissions(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::resource::GetResourcePermissionsRqst* /*request*/, ::resource::GetResourcePermissionsRsp* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_AddResourceOwner : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_AddResourceOwner() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::resource::AddResourceOwnerRqst, ::resource::AddResourceOwnerRsp>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::resource::AddResourceOwnerRqst* request, ::resource::AddResourceOwnerRsp* response) { return this->AddResourceOwner(context, request, response); }));}
    void SetMessageAllocatorFor_AddResourceOwner(
        ::grpc::experimental::MessageAllocator< ::resource::AddResourceOwnerRqst, ::resource::AddResourceOwnerRsp>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(8);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(8);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::resource::AddResourceOwnerRqst, ::resource::AddResourceOwnerRsp>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_AddResourceOwner() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AddResourceOwner(::grpc::ServerContext* /*context*/, const ::resource::AddResourceOwnerRqst* /*request*/, ::resource::AddResourceOwnerRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* AddResourceOwner(
      ::grpc::CallbackServerContext* /*context*/, const ::resource::AddResourceOwnerRqst* /*request*/, ::resource::AddResourceOwnerRsp* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* AddResourceOwner(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::resource::AddResourceOwnerRqst* /*request*/, ::resource::AddResourceOwnerRsp* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_removeResourceOwner : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_removeResourceOwner() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::resource::AddResourceOwnerRqst, ::resource::AddResourceOwnerRsp>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::resource::AddResourceOwnerRqst* request, ::resource::AddResourceOwnerRsp* response) { return this->removeResourceOwner(context, request, response); }));}
    void SetMessageAllocatorFor_removeResourceOwner(
        ::grpc::experimental::MessageAllocator< ::resource::AddResourceOwnerRqst, ::resource::AddResourceOwnerRsp>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(9);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(9);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::resource::AddResourceOwnerRqst, ::resource::AddResourceOwnerRsp>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_removeResourceOwner() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status removeResourceOwner(::grpc::ServerContext* /*context*/, const ::resource::AddResourceOwnerRqst* /*request*/, ::resource::AddResourceOwnerRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* removeResourceOwner(
      ::grpc::CallbackServerContext* /*context*/, const ::resource::AddResourceOwnerRqst* /*request*/, ::resource::AddResourceOwnerRsp* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* removeResourceOwner(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::resource::AddResourceOwnerRqst* /*request*/, ::resource::AddResourceOwnerRsp* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_deleteAllAccess : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_deleteAllAccess() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(10,
          new ::grpc::internal::CallbackUnaryHandler< ::resource::deleteAllAccessRqst, ::resource::deleteAllAccessRsp>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::resource::deleteAllAccessRqst* request, ::resource::deleteAllAccessRsp* response) { return this->deleteAllAccess(context, request, response); }));}
    void SetMessageAllocatorFor_deleteAllAccess(
        ::grpc::experimental::MessageAllocator< ::resource::deleteAllAccessRqst, ::resource::deleteAllAccessRsp>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(10);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(10);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::resource::deleteAllAccessRqst, ::resource::deleteAllAccessRsp>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_deleteAllAccess() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status deleteAllAccess(::grpc::ServerContext* /*context*/, const ::resource::deleteAllAccessRqst* /*request*/, ::resource::deleteAllAccessRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* deleteAllAccess(
      ::grpc::CallbackServerContext* /*context*/, const ::resource::deleteAllAccessRqst* /*request*/, ::resource::deleteAllAccessRsp* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* deleteAllAccess(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::resource::deleteAllAccessRqst* /*request*/, ::resource::deleteAllAccessRsp* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_validateAccess : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_validateAccess() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(11,
          new ::grpc::internal::CallbackUnaryHandler< ::resource::validateAccessRqst, ::resource::validateAccessRsp>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::resource::validateAccessRqst* request, ::resource::validateAccessRsp* response) { return this->validateAccess(context, request, response); }));}
    void SetMessageAllocatorFor_validateAccess(
        ::grpc::experimental::MessageAllocator< ::resource::validateAccessRqst, ::resource::validateAccessRsp>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(11);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(11);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::resource::validateAccessRqst, ::resource::validateAccessRsp>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_validateAccess() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status validateAccess(::grpc::ServerContext* /*context*/, const ::resource::validateAccessRqst* /*request*/, ::resource::validateAccessRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* validateAccess(
      ::grpc::CallbackServerContext* /*context*/, const ::resource::validateAccessRqst* /*request*/, ::resource::validateAccessRsp* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* validateAccess(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::resource::validateAccessRqst* /*request*/, ::resource::validateAccessRsp* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_getAccesses : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_getAccesses() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(12,
          new ::grpc::internal::CallbackUnaryHandler< ::resource::getAccessesRqst, ::resource::getAccessesRsp>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::resource::getAccessesRqst* request, ::resource::getAccessesRsp* response) { return this->getAccesses(context, request, response); }));}
    void SetMessageAllocatorFor_getAccesses(
        ::grpc::experimental::MessageAllocator< ::resource::getAccessesRqst, ::resource::getAccessesRsp>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(12);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(12);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::resource::getAccessesRqst, ::resource::getAccessesRsp>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_getAccesses() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getAccesses(::grpc::ServerContext* /*context*/, const ::resource::getAccessesRqst* /*request*/, ::resource::getAccessesRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* getAccesses(
      ::grpc::CallbackServerContext* /*context*/, const ::resource::getAccessesRqst* /*request*/, ::resource::getAccessesRsp* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* getAccesses(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::resource::getAccessesRqst* /*request*/, ::resource::getAccessesRsp* /*response*/)
    #endif
      { return nullptr; }
  };
  #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
  typedef ExperimentalWithCallbackMethod_SetActionResourcesPermission<ExperimentalWithCallbackMethod_GetActionResourcesPermission<ExperimentalWithCallbackMethod_SetResourcePermissions<ExperimentalWithCallbackMethod_DeleteResourcePermissions<ExperimentalWithCallbackMethod_DeleteResourcePermission<ExperimentalWithCallbackMethod_SetResourcePermission<ExperimentalWithCallbackMethod_GetResourcePermission<ExperimentalWithCallbackMethod_GetResourcePermissions<ExperimentalWithCallbackMethod_AddResourceOwner<ExperimentalWithCallbackMethod_removeResourceOwner<ExperimentalWithCallbackMethod_deleteAllAccess<ExperimentalWithCallbackMethod_validateAccess<ExperimentalWithCallbackMethod_getAccesses<Service > > > > > > > > > > > > > CallbackService;
  #endif

  typedef ExperimentalWithCallbackMethod_SetActionResourcesPermission<ExperimentalWithCallbackMethod_GetActionResourcesPermission<ExperimentalWithCallbackMethod_SetResourcePermissions<ExperimentalWithCallbackMethod_DeleteResourcePermissions<ExperimentalWithCallbackMethod_DeleteResourcePermission<ExperimentalWithCallbackMethod_SetResourcePermission<ExperimentalWithCallbackMethod_GetResourcePermission<ExperimentalWithCallbackMethod_GetResourcePermissions<ExperimentalWithCallbackMethod_AddResourceOwner<ExperimentalWithCallbackMethod_removeResourceOwner<ExperimentalWithCallbackMethod_deleteAllAccess<ExperimentalWithCallbackMethod_validateAccess<ExperimentalWithCallbackMethod_getAccesses<Service > > > > > > > > > > > > > ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_SetActionResourcesPermission : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetActionResourcesPermission() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_SetActionResourcesPermission() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetActionResourcesPermission(::grpc::ServerContext* /*context*/, const ::resource::SetActionResourcesPermissionRqst* /*request*/, ::resource::SetActionResourcesPermissionRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetActionResourcesPermission : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetActionResourcesPermission() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_GetActionResourcesPermission() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetActionResourcesPermission(::grpc::ServerContext* /*context*/, const ::resource::GetActionResourcesPermissionRqst* /*request*/, ::resource::GetActionResourcesPermissionRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetResourcePermissions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetResourcePermissions() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_SetResourcePermissions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetResourcePermissions(::grpc::ServerContext* /*context*/, const ::resource::SetResourcePermissionsRqst* /*request*/, ::resource::SetResourcePermissionsRqst* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DeleteResourcePermissions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_DeleteResourcePermissions() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_DeleteResourcePermissions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteResourcePermissions(::grpc::ServerContext* /*context*/, const ::resource::DeleteResourcePermissionsRqst* /*request*/, ::resource::DeleteResourcePermissionsRqst* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DeleteResourcePermission : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_DeleteResourcePermission() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_DeleteResourcePermission() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteResourcePermission(::grpc::ServerContext* /*context*/, const ::resource::DeleteResourcePermissionRqst* /*request*/, ::resource::DeleteResourcePermissionRqst* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetResourcePermission : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetResourcePermission() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_SetResourcePermission() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetResourcePermission(::grpc::ServerContext* /*context*/, const ::resource::SetResourcePermissionRqst* /*request*/, ::resource::SetResourcePermissionRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetResourcePermission : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetResourcePermission() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_GetResourcePermission() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetResourcePermission(::grpc::ServerContext* /*context*/, const ::resource::GetResourcePermissionRqst* /*request*/, ::resource::GetResourcePermissionRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetResourcePermissions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetResourcePermissions() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_GetResourcePermissions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetResourcePermissions(::grpc::ServerContext* /*context*/, const ::resource::GetResourcePermissionsRqst* /*request*/, ::resource::GetResourcePermissionsRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_AddResourceOwner : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_AddResourceOwner() {
      ::grpc::Service::MarkMethodGeneric(8);
    }
    ~WithGenericMethod_AddResourceOwner() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AddResourceOwner(::grpc::ServerContext* /*context*/, const ::resource::AddResourceOwnerRqst* /*request*/, ::resource::AddResourceOwnerRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_removeResourceOwner : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_removeResourceOwner() {
      ::grpc::Service::MarkMethodGeneric(9);
    }
    ~WithGenericMethod_removeResourceOwner() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status removeResourceOwner(::grpc::ServerContext* /*context*/, const ::resource::AddResourceOwnerRqst* /*request*/, ::resource::AddResourceOwnerRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_deleteAllAccess : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_deleteAllAccess() {
      ::grpc::Service::MarkMethodGeneric(10);
    }
    ~WithGenericMethod_deleteAllAccess() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status deleteAllAccess(::grpc::ServerContext* /*context*/, const ::resource::deleteAllAccessRqst* /*request*/, ::resource::deleteAllAccessRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_validateAccess : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_validateAccess() {
      ::grpc::Service::MarkMethodGeneric(11);
    }
    ~WithGenericMethod_validateAccess() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status validateAccess(::grpc::ServerContext* /*context*/, const ::resource::validateAccessRqst* /*request*/, ::resource::validateAccessRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_getAccesses : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_getAccesses() {
      ::grpc::Service::MarkMethodGeneric(12);
    }
    ~WithGenericMethod_getAccesses() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getAccesses(::grpc::ServerContext* /*context*/, const ::resource::getAccessesRqst* /*request*/, ::resource::getAccessesRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetActionResourcesPermission : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetActionResourcesPermission() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_SetActionResourcesPermission() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetActionResourcesPermission(::grpc::ServerContext* /*context*/, const ::resource::SetActionResourcesPermissionRqst* /*request*/, ::resource::SetActionResourcesPermissionRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetActionResourcesPermission(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetActionResourcesPermission : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetActionResourcesPermission() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_GetActionResourcesPermission() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetActionResourcesPermission(::grpc::ServerContext* /*context*/, const ::resource::GetActionResourcesPermissionRqst* /*request*/, ::resource::GetActionResourcesPermissionRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetActionResourcesPermission(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetResourcePermissions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetResourcePermissions() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_SetResourcePermissions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetResourcePermissions(::grpc::ServerContext* /*context*/, const ::resource::SetResourcePermissionsRqst* /*request*/, ::resource::SetResourcePermissionsRqst* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetResourcePermissions(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DeleteResourcePermissions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_DeleteResourcePermissions() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_DeleteResourcePermissions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteResourcePermissions(::grpc::ServerContext* /*context*/, const ::resource::DeleteResourcePermissionsRqst* /*request*/, ::resource::DeleteResourcePermissionsRqst* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteResourcePermissions(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DeleteResourcePermission : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_DeleteResourcePermission() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_DeleteResourcePermission() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteResourcePermission(::grpc::ServerContext* /*context*/, const ::resource::DeleteResourcePermissionRqst* /*request*/, ::resource::DeleteResourcePermissionRqst* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteResourcePermission(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetResourcePermission : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetResourcePermission() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_SetResourcePermission() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetResourcePermission(::grpc::ServerContext* /*context*/, const ::resource::SetResourcePermissionRqst* /*request*/, ::resource::SetResourcePermissionRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetResourcePermission(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetResourcePermission : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetResourcePermission() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_GetResourcePermission() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetResourcePermission(::grpc::ServerContext* /*context*/, const ::resource::GetResourcePermissionRqst* /*request*/, ::resource::GetResourcePermissionRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetResourcePermission(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetResourcePermissions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetResourcePermissions() {
      ::grpc::Service::MarkMethodRaw(7);
    }
    ~WithRawMethod_GetResourcePermissions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetResourcePermissions(::grpc::ServerContext* /*context*/, const ::resource::GetResourcePermissionsRqst* /*request*/, ::resource::GetResourcePermissionsRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetResourcePermissions(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_AddResourceOwner : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_AddResourceOwner() {
      ::grpc::Service::MarkMethodRaw(8);
    }
    ~WithRawMethod_AddResourceOwner() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AddResourceOwner(::grpc::ServerContext* /*context*/, const ::resource::AddResourceOwnerRqst* /*request*/, ::resource::AddResourceOwnerRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAddResourceOwner(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_removeResourceOwner : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_removeResourceOwner() {
      ::grpc::Service::MarkMethodRaw(9);
    }
    ~WithRawMethod_removeResourceOwner() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status removeResourceOwner(::grpc::ServerContext* /*context*/, const ::resource::AddResourceOwnerRqst* /*request*/, ::resource::AddResourceOwnerRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestremoveResourceOwner(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_deleteAllAccess : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_deleteAllAccess() {
      ::grpc::Service::MarkMethodRaw(10);
    }
    ~WithRawMethod_deleteAllAccess() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status deleteAllAccess(::grpc::ServerContext* /*context*/, const ::resource::deleteAllAccessRqst* /*request*/, ::resource::deleteAllAccessRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestdeleteAllAccess(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_validateAccess : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_validateAccess() {
      ::grpc::Service::MarkMethodRaw(11);
    }
    ~WithRawMethod_validateAccess() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status validateAccess(::grpc::ServerContext* /*context*/, const ::resource::validateAccessRqst* /*request*/, ::resource::validateAccessRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestvalidateAccess(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_getAccesses : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_getAccesses() {
      ::grpc::Service::MarkMethodRaw(12);
    }
    ~WithRawMethod_getAccesses() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getAccesses(::grpc::ServerContext* /*context*/, const ::resource::getAccessesRqst* /*request*/, ::resource::getAccessesRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetAccesses(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SetActionResourcesPermission : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_SetActionResourcesPermission() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetActionResourcesPermission(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_SetActionResourcesPermission() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetActionResourcesPermission(::grpc::ServerContext* /*context*/, const ::resource::SetActionResourcesPermissionRqst* /*request*/, ::resource::SetActionResourcesPermissionRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* SetActionResourcesPermission(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* SetActionResourcesPermission(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetActionResourcesPermission : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetActionResourcesPermission() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetActionResourcesPermission(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetActionResourcesPermission() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetActionResourcesPermission(::grpc::ServerContext* /*context*/, const ::resource::GetActionResourcesPermissionRqst* /*request*/, ::resource::GetActionResourcesPermissionRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetActionResourcesPermission(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetActionResourcesPermission(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SetResourcePermissions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_SetResourcePermissions() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetResourcePermissions(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_SetResourcePermissions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetResourcePermissions(::grpc::ServerContext* /*context*/, const ::resource::SetResourcePermissionsRqst* /*request*/, ::resource::SetResourcePermissionsRqst* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* SetResourcePermissions(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* SetResourcePermissions(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_DeleteResourcePermissions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_DeleteResourcePermissions() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->DeleteResourcePermissions(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_DeleteResourcePermissions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteResourcePermissions(::grpc::ServerContext* /*context*/, const ::resource::DeleteResourcePermissionsRqst* /*request*/, ::resource::DeleteResourcePermissionsRqst* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DeleteResourcePermissions(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DeleteResourcePermissions(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_DeleteResourcePermission : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_DeleteResourcePermission() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->DeleteResourcePermission(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_DeleteResourcePermission() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteResourcePermission(::grpc::ServerContext* /*context*/, const ::resource::DeleteResourcePermissionRqst* /*request*/, ::resource::DeleteResourcePermissionRqst* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DeleteResourcePermission(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DeleteResourcePermission(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SetResourcePermission : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_SetResourcePermission() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetResourcePermission(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_SetResourcePermission() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetResourcePermission(::grpc::ServerContext* /*context*/, const ::resource::SetResourcePermissionRqst* /*request*/, ::resource::SetResourcePermissionRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* SetResourcePermission(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* SetResourcePermission(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetResourcePermission : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetResourcePermission() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetResourcePermission(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetResourcePermission() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetResourcePermission(::grpc::ServerContext* /*context*/, const ::resource::GetResourcePermissionRqst* /*request*/, ::resource::GetResourcePermissionRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetResourcePermission(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetResourcePermission(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetResourcePermissions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetResourcePermissions() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetResourcePermissions(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetResourcePermissions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetResourcePermissions(::grpc::ServerContext* /*context*/, const ::resource::GetResourcePermissionsRqst* /*request*/, ::resource::GetResourcePermissionsRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetResourcePermissions(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetResourcePermissions(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_AddResourceOwner : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_AddResourceOwner() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->AddResourceOwner(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_AddResourceOwner() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AddResourceOwner(::grpc::ServerContext* /*context*/, const ::resource::AddResourceOwnerRqst* /*request*/, ::resource::AddResourceOwnerRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* AddResourceOwner(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* AddResourceOwner(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_removeResourceOwner : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_removeResourceOwner() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->removeResourceOwner(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_removeResourceOwner() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status removeResourceOwner(::grpc::ServerContext* /*context*/, const ::resource::AddResourceOwnerRqst* /*request*/, ::resource::AddResourceOwnerRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* removeResourceOwner(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* removeResourceOwner(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_deleteAllAccess : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_deleteAllAccess() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(10,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->deleteAllAccess(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_deleteAllAccess() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status deleteAllAccess(::grpc::ServerContext* /*context*/, const ::resource::deleteAllAccessRqst* /*request*/, ::resource::deleteAllAccessRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* deleteAllAccess(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* deleteAllAccess(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_validateAccess : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_validateAccess() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(11,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->validateAccess(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_validateAccess() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status validateAccess(::grpc::ServerContext* /*context*/, const ::resource::validateAccessRqst* /*request*/, ::resource::validateAccessRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* validateAccess(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* validateAccess(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_getAccesses : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_getAccesses() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(12,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->getAccesses(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_getAccesses() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getAccesses(::grpc::ServerContext* /*context*/, const ::resource::getAccessesRqst* /*request*/, ::resource::getAccessesRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* getAccesses(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* getAccesses(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetActionResourcesPermission : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetActionResourcesPermission() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::resource::SetActionResourcesPermissionRqst, ::resource::SetActionResourcesPermissionRsp>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::resource::SetActionResourcesPermissionRqst, ::resource::SetActionResourcesPermissionRsp>* streamer) {
                       return this->StreamedSetActionResourcesPermission(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetActionResourcesPermission() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetActionResourcesPermission(::grpc::ServerContext* /*context*/, const ::resource::SetActionResourcesPermissionRqst* /*request*/, ::resource::SetActionResourcesPermissionRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetActionResourcesPermission(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::resource::SetActionResourcesPermissionRqst,::resource::SetActionResourcesPermissionRsp>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetActionResourcesPermission : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetActionResourcesPermission() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::resource::GetActionResourcesPermissionRqst, ::resource::GetActionResourcesPermissionRsp>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::resource::GetActionResourcesPermissionRqst, ::resource::GetActionResourcesPermissionRsp>* streamer) {
                       return this->StreamedGetActionResourcesPermission(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetActionResourcesPermission() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetActionResourcesPermission(::grpc::ServerContext* /*context*/, const ::resource::GetActionResourcesPermissionRqst* /*request*/, ::resource::GetActionResourcesPermissionRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetActionResourcesPermission(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::resource::GetActionResourcesPermissionRqst,::resource::GetActionResourcesPermissionRsp>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetResourcePermissions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetResourcePermissions() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::resource::SetResourcePermissionsRqst, ::resource::SetResourcePermissionsRqst>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::resource::SetResourcePermissionsRqst, ::resource::SetResourcePermissionsRqst>* streamer) {
                       return this->StreamedSetResourcePermissions(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetResourcePermissions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetResourcePermissions(::grpc::ServerContext* /*context*/, const ::resource::SetResourcePermissionsRqst* /*request*/, ::resource::SetResourcePermissionsRqst* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetResourcePermissions(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::resource::SetResourcePermissionsRqst,::resource::SetResourcePermissionsRqst>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DeleteResourcePermissions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_DeleteResourcePermissions() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::resource::DeleteResourcePermissionsRqst, ::resource::DeleteResourcePermissionsRqst>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::resource::DeleteResourcePermissionsRqst, ::resource::DeleteResourcePermissionsRqst>* streamer) {
                       return this->StreamedDeleteResourcePermissions(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_DeleteResourcePermissions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DeleteResourcePermissions(::grpc::ServerContext* /*context*/, const ::resource::DeleteResourcePermissionsRqst* /*request*/, ::resource::DeleteResourcePermissionsRqst* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDeleteResourcePermissions(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::resource::DeleteResourcePermissionsRqst,::resource::DeleteResourcePermissionsRqst>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DeleteResourcePermission : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_DeleteResourcePermission() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler<
          ::resource::DeleteResourcePermissionRqst, ::resource::DeleteResourcePermissionRqst>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::resource::DeleteResourcePermissionRqst, ::resource::DeleteResourcePermissionRqst>* streamer) {
                       return this->StreamedDeleteResourcePermission(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_DeleteResourcePermission() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DeleteResourcePermission(::grpc::ServerContext* /*context*/, const ::resource::DeleteResourcePermissionRqst* /*request*/, ::resource::DeleteResourcePermissionRqst* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDeleteResourcePermission(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::resource::DeleteResourcePermissionRqst,::resource::DeleteResourcePermissionRqst>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetResourcePermission : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetResourcePermission() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler<
          ::resource::SetResourcePermissionRqst, ::resource::SetResourcePermissionRsp>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::resource::SetResourcePermissionRqst, ::resource::SetResourcePermissionRsp>* streamer) {
                       return this->StreamedSetResourcePermission(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetResourcePermission() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetResourcePermission(::grpc::ServerContext* /*context*/, const ::resource::SetResourcePermissionRqst* /*request*/, ::resource::SetResourcePermissionRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetResourcePermission(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::resource::SetResourcePermissionRqst,::resource::SetResourcePermissionRsp>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetResourcePermission : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetResourcePermission() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler<
          ::resource::GetResourcePermissionRqst, ::resource::GetResourcePermissionRsp>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::resource::GetResourcePermissionRqst, ::resource::GetResourcePermissionRsp>* streamer) {
                       return this->StreamedGetResourcePermission(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetResourcePermission() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetResourcePermission(::grpc::ServerContext* /*context*/, const ::resource::GetResourcePermissionRqst* /*request*/, ::resource::GetResourcePermissionRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetResourcePermission(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::resource::GetResourcePermissionRqst,::resource::GetResourcePermissionRsp>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetResourcePermissions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetResourcePermissions() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::StreamedUnaryHandler<
          ::resource::GetResourcePermissionsRqst, ::resource::GetResourcePermissionsRsp>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::resource::GetResourcePermissionsRqst, ::resource::GetResourcePermissionsRsp>* streamer) {
                       return this->StreamedGetResourcePermissions(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetResourcePermissions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetResourcePermissions(::grpc::ServerContext* /*context*/, const ::resource::GetResourcePermissionsRqst* /*request*/, ::resource::GetResourcePermissionsRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetResourcePermissions(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::resource::GetResourcePermissionsRqst,::resource::GetResourcePermissionsRsp>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_AddResourceOwner : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_AddResourceOwner() {
      ::grpc::Service::MarkMethodStreamed(8,
        new ::grpc::internal::StreamedUnaryHandler<
          ::resource::AddResourceOwnerRqst, ::resource::AddResourceOwnerRsp>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::resource::AddResourceOwnerRqst, ::resource::AddResourceOwnerRsp>* streamer) {
                       return this->StreamedAddResourceOwner(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_AddResourceOwner() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status AddResourceOwner(::grpc::ServerContext* /*context*/, const ::resource::AddResourceOwnerRqst* /*request*/, ::resource::AddResourceOwnerRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedAddResourceOwner(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::resource::AddResourceOwnerRqst,::resource::AddResourceOwnerRsp>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_removeResourceOwner : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_removeResourceOwner() {
      ::grpc::Service::MarkMethodStreamed(9,
        new ::grpc::internal::StreamedUnaryHandler<
          ::resource::AddResourceOwnerRqst, ::resource::AddResourceOwnerRsp>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::resource::AddResourceOwnerRqst, ::resource::AddResourceOwnerRsp>* streamer) {
                       return this->StreamedremoveResourceOwner(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_removeResourceOwner() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status removeResourceOwner(::grpc::ServerContext* /*context*/, const ::resource::AddResourceOwnerRqst* /*request*/, ::resource::AddResourceOwnerRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedremoveResourceOwner(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::resource::AddResourceOwnerRqst,::resource::AddResourceOwnerRsp>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_deleteAllAccess : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_deleteAllAccess() {
      ::grpc::Service::MarkMethodStreamed(10,
        new ::grpc::internal::StreamedUnaryHandler<
          ::resource::deleteAllAccessRqst, ::resource::deleteAllAccessRsp>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::resource::deleteAllAccessRqst, ::resource::deleteAllAccessRsp>* streamer) {
                       return this->StreameddeleteAllAccess(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_deleteAllAccess() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status deleteAllAccess(::grpc::ServerContext* /*context*/, const ::resource::deleteAllAccessRqst* /*request*/, ::resource::deleteAllAccessRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreameddeleteAllAccess(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::resource::deleteAllAccessRqst,::resource::deleteAllAccessRsp>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_validateAccess : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_validateAccess() {
      ::grpc::Service::MarkMethodStreamed(11,
        new ::grpc::internal::StreamedUnaryHandler<
          ::resource::validateAccessRqst, ::resource::validateAccessRsp>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::resource::validateAccessRqst, ::resource::validateAccessRsp>* streamer) {
                       return this->StreamedvalidateAccess(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_validateAccess() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status validateAccess(::grpc::ServerContext* /*context*/, const ::resource::validateAccessRqst* /*request*/, ::resource::validateAccessRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedvalidateAccess(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::resource::validateAccessRqst,::resource::validateAccessRsp>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_getAccesses : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_getAccesses() {
      ::grpc::Service::MarkMethodStreamed(12,
        new ::grpc::internal::StreamedUnaryHandler<
          ::resource::getAccessesRqst, ::resource::getAccessesRsp>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::resource::getAccessesRqst, ::resource::getAccessesRsp>* streamer) {
                       return this->StreamedgetAccesses(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_getAccesses() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status getAccesses(::grpc::ServerContext* /*context*/, const ::resource::getAccessesRqst* /*request*/, ::resource::getAccessesRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedgetAccesses(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::resource::getAccessesRqst,::resource::getAccessesRsp>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_SetActionResourcesPermission<WithStreamedUnaryMethod_GetActionResourcesPermission<WithStreamedUnaryMethod_SetResourcePermissions<WithStreamedUnaryMethod_DeleteResourcePermissions<WithStreamedUnaryMethod_DeleteResourcePermission<WithStreamedUnaryMethod_SetResourcePermission<WithStreamedUnaryMethod_GetResourcePermission<WithStreamedUnaryMethod_GetResourcePermissions<WithStreamedUnaryMethod_AddResourceOwner<WithStreamedUnaryMethod_removeResourceOwner<WithStreamedUnaryMethod_deleteAllAccess<WithStreamedUnaryMethod_validateAccess<WithStreamedUnaryMethod_getAccesses<Service > > > > > > > > > > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_SetActionResourcesPermission<WithStreamedUnaryMethod_GetActionResourcesPermission<WithStreamedUnaryMethod_SetResourcePermissions<WithStreamedUnaryMethod_DeleteResourcePermissions<WithStreamedUnaryMethod_DeleteResourcePermission<WithStreamedUnaryMethod_SetResourcePermission<WithStreamedUnaryMethod_GetResourcePermission<WithStreamedUnaryMethod_GetResourcePermissions<WithStreamedUnaryMethod_AddResourceOwner<WithStreamedUnaryMethod_removeResourceOwner<WithStreamedUnaryMethod_deleteAllAccess<WithStreamedUnaryMethod_validateAccess<WithStreamedUnaryMethod_getAccesses<Service > > > > > > > > > > > > > StreamedService;
};

class LogService final {
 public:
  static constexpr char const* service_full_name() {
    return "resource.LogService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // * Set a method into the log... *
    virtual ::grpc::Status Log(::grpc::ClientContext* context, const ::resource::LogRqst& request, ::resource::LogRsp* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::LogRsp>> AsyncLog(::grpc::ClientContext* context, const ::resource::LogRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::LogRsp>>(AsyncLogRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::LogRsp>> PrepareAsyncLog(::grpc::ClientContext* context, const ::resource::LogRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::LogRsp>>(PrepareAsyncLogRaw(context, request, cq));
    }
    // * Get the list of logs *
    std::unique_ptr< ::grpc::ClientReaderInterface< ::resource::GetLogRsp>> GetLog(::grpc::ClientContext* context, const ::resource::GetLogRqst& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::resource::GetLogRsp>>(GetLogRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::resource::GetLogRsp>> AsyncGetLog(::grpc::ClientContext* context, const ::resource::GetLogRqst& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::resource::GetLogRsp>>(AsyncGetLogRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::resource::GetLogRsp>> PrepareAsyncGetLog(::grpc::ClientContext* context, const ::resource::GetLogRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::resource::GetLogRsp>>(PrepareAsyncGetLogRaw(context, request, cq));
    }
    // * Delete a single log entry *
    virtual ::grpc::Status DeleteLog(::grpc::ClientContext* context, const ::resource::DeleteLogRqst& request, ::resource::DeleteLogRsp* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::DeleteLogRsp>> AsyncDeleteLog(::grpc::ClientContext* context, const ::resource::DeleteLogRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::DeleteLogRsp>>(AsyncDeleteLogRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::DeleteLogRsp>> PrepareAsyncDeleteLog(::grpc::ClientContext* context, const ::resource::DeleteLogRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::DeleteLogRsp>>(PrepareAsyncDeleteLogRaw(context, request, cq));
    }
    // * Delete all log *
    virtual ::grpc::Status ClearAllLog(::grpc::ClientContext* context, const ::resource::ClearAllLogRqst& request, ::resource::ClearAllLogRsp* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::ClearAllLogRsp>> AsyncClearAllLog(::grpc::ClientContext* context, const ::resource::ClearAllLogRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::ClearAllLogRsp>>(AsyncClearAllLogRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::ClearAllLogRsp>> PrepareAsyncClearAllLog(::grpc::ClientContext* context, const ::resource::ClearAllLogRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::resource::ClearAllLogRsp>>(PrepareAsyncClearAllLogRaw(context, request, cq));
    }
    class experimental_async_interface {
     public:
      virtual ~experimental_async_interface() {}
      // * Set a method into the log... *
      virtual void Log(::grpc::ClientContext* context, const ::resource::LogRqst* request, ::resource::LogRsp* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void Log(::grpc::ClientContext* context, const ::resource::LogRqst* request, ::resource::LogRsp* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void Log(::grpc::ClientContext* context, const ::resource::LogRqst* request, ::resource::LogRsp* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // * Get the list of logs *
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetLog(::grpc::ClientContext* context, ::resource::GetLogRqst* request, ::grpc::ClientReadReactor< ::resource::GetLogRsp>* reactor) = 0;
      #else
      virtual void GetLog(::grpc::ClientContext* context, ::resource::GetLogRqst* request, ::grpc::experimental::ClientReadReactor< ::resource::GetLogRsp>* reactor) = 0;
      #endif
      // * Delete a single log entry *
      virtual void DeleteLog(::grpc::ClientContext* context, const ::resource::DeleteLogRqst* request, ::resource::DeleteLogRsp* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void DeleteLog(::grpc::ClientContext* context, const ::resource::DeleteLogRqst* request, ::resource::DeleteLogRsp* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void DeleteLog(::grpc::ClientContext* context, const ::resource::DeleteLogRqst* request, ::resource::DeleteLogRsp* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // * Delete all log *
      virtual void ClearAllLog(::grpc::ClientContext* context, const ::resource::ClearAllLogRqst* request, ::resource::ClearAllLogRsp* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ClearAllLog(::grpc::ClientContext* context, const ::resource::ClearAllLogRqst* request, ::resource::ClearAllLogRsp* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ClearAllLog(::grpc::ClientContext* context, const ::resource::ClearAllLogRqst* request, ::resource::ClearAllLogRsp* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
    };
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    typedef class experimental_async_interface async_interface;
    #endif
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    async_interface* async() { return experimental_async(); }
    #endif
    virtual class experimental_async_interface* experimental_async() { return nullptr; }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::resource::LogRsp>* AsyncLogRaw(::grpc::ClientContext* context, const ::resource::LogRqst& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::resource::LogRsp>* PrepareAsyncLogRaw(::grpc::ClientContext* context, const ::resource::LogRqst& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::resource::GetLogRsp>* GetLogRaw(::grpc::ClientContext* context, const ::resource::GetLogRqst& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::resource::GetLogRsp>* AsyncGetLogRaw(::grpc::ClientContext* context, const ::resource::GetLogRqst& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::resource::GetLogRsp>* PrepareAsyncGetLogRaw(::grpc::ClientContext* context, const ::resource::GetLogRqst& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::resource::DeleteLogRsp>* AsyncDeleteLogRaw(::grpc::ClientContext* context, const ::resource::DeleteLogRqst& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::resource::DeleteLogRsp>* PrepareAsyncDeleteLogRaw(::grpc::ClientContext* context, const ::resource::DeleteLogRqst& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::resource::ClearAllLogRsp>* AsyncClearAllLogRaw(::grpc::ClientContext* context, const ::resource::ClearAllLogRqst& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::resource::ClearAllLogRsp>* PrepareAsyncClearAllLogRaw(::grpc::ClientContext* context, const ::resource::ClearAllLogRqst& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    ::grpc::Status Log(::grpc::ClientContext* context, const ::resource::LogRqst& request, ::resource::LogRsp* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::LogRsp>> AsyncLog(::grpc::ClientContext* context, const ::resource::LogRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::LogRsp>>(AsyncLogRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::LogRsp>> PrepareAsyncLog(::grpc::ClientContext* context, const ::resource::LogRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::LogRsp>>(PrepareAsyncLogRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::resource::GetLogRsp>> GetLog(::grpc::ClientContext* context, const ::resource::GetLogRqst& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::resource::GetLogRsp>>(GetLogRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::resource::GetLogRsp>> AsyncGetLog(::grpc::ClientContext* context, const ::resource::GetLogRqst& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::resource::GetLogRsp>>(AsyncGetLogRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::resource::GetLogRsp>> PrepareAsyncGetLog(::grpc::ClientContext* context, const ::resource::GetLogRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::resource::GetLogRsp>>(PrepareAsyncGetLogRaw(context, request, cq));
    }
    ::grpc::Status DeleteLog(::grpc::ClientContext* context, const ::resource::DeleteLogRqst& request, ::resource::DeleteLogRsp* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::DeleteLogRsp>> AsyncDeleteLog(::grpc::ClientContext* context, const ::resource::DeleteLogRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::DeleteLogRsp>>(AsyncDeleteLogRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::DeleteLogRsp>> PrepareAsyncDeleteLog(::grpc::ClientContext* context, const ::resource::DeleteLogRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::DeleteLogRsp>>(PrepareAsyncDeleteLogRaw(context, request, cq));
    }
    ::grpc::Status ClearAllLog(::grpc::ClientContext* context, const ::resource::ClearAllLogRqst& request, ::resource::ClearAllLogRsp* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::ClearAllLogRsp>> AsyncClearAllLog(::grpc::ClientContext* context, const ::resource::ClearAllLogRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::ClearAllLogRsp>>(AsyncClearAllLogRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::ClearAllLogRsp>> PrepareAsyncClearAllLog(::grpc::ClientContext* context, const ::resource::ClearAllLogRqst& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::resource::ClearAllLogRsp>>(PrepareAsyncClearAllLogRaw(context, request, cq));
    }
    class experimental_async final :
      public StubInterface::experimental_async_interface {
     public:
      void Log(::grpc::ClientContext* context, const ::resource::LogRqst* request, ::resource::LogRsp* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void Log(::grpc::ClientContext* context, const ::resource::LogRqst* request, ::resource::LogRsp* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void Log(::grpc::ClientContext* context, const ::resource::LogRqst* request, ::resource::LogRsp* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetLog(::grpc::ClientContext* context, ::resource::GetLogRqst* request, ::grpc::ClientReadReactor< ::resource::GetLogRsp>* reactor) override;
      #else
      void GetLog(::grpc::ClientContext* context, ::resource::GetLogRqst* request, ::grpc::experimental::ClientReadReactor< ::resource::GetLogRsp>* reactor) override;
      #endif
      void DeleteLog(::grpc::ClientContext* context, const ::resource::DeleteLogRqst* request, ::resource::DeleteLogRsp* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void DeleteLog(::grpc::ClientContext* context, const ::resource::DeleteLogRqst* request, ::resource::DeleteLogRsp* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void DeleteLog(::grpc::ClientContext* context, const ::resource::DeleteLogRqst* request, ::resource::DeleteLogRsp* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void ClearAllLog(::grpc::ClientContext* context, const ::resource::ClearAllLogRqst* request, ::resource::ClearAllLogRsp* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ClearAllLog(::grpc::ClientContext* context, const ::resource::ClearAllLogRqst* request, ::resource::ClearAllLogRsp* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ClearAllLog(::grpc::ClientContext* context, const ::resource::ClearAllLogRqst* request, ::resource::ClearAllLogRsp* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
     private:
      friend class Stub;
      explicit experimental_async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class experimental_async_interface* experimental_async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class experimental_async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::resource::LogRsp>* AsyncLogRaw(::grpc::ClientContext* context, const ::resource::LogRqst& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::resource::LogRsp>* PrepareAsyncLogRaw(::grpc::ClientContext* context, const ::resource::LogRqst& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::resource::GetLogRsp>* GetLogRaw(::grpc::ClientContext* context, const ::resource::GetLogRqst& request) override;
    ::grpc::ClientAsyncReader< ::resource::GetLogRsp>* AsyncGetLogRaw(::grpc::ClientContext* context, const ::resource::GetLogRqst& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::resource::GetLogRsp>* PrepareAsyncGetLogRaw(::grpc::ClientContext* context, const ::resource::GetLogRqst& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::resource::DeleteLogRsp>* AsyncDeleteLogRaw(::grpc::ClientContext* context, const ::resource::DeleteLogRqst& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::resource::DeleteLogRsp>* PrepareAsyncDeleteLogRaw(::grpc::ClientContext* context, const ::resource::DeleteLogRqst& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::resource::ClearAllLogRsp>* AsyncClearAllLogRaw(::grpc::ClientContext* context, const ::resource::ClearAllLogRqst& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::resource::ClearAllLogRsp>* PrepareAsyncClearAllLogRaw(::grpc::ClientContext* context, const ::resource::ClearAllLogRqst& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_Log_;
    const ::grpc::internal::RpcMethod rpcmethod_GetLog_;
    const ::grpc::internal::RpcMethod rpcmethod_DeleteLog_;
    const ::grpc::internal::RpcMethod rpcmethod_ClearAllLog_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // * Set a method into the log... *
    virtual ::grpc::Status Log(::grpc::ServerContext* context, const ::resource::LogRqst* request, ::resource::LogRsp* response);
    // * Get the list of logs *
    virtual ::grpc::Status GetLog(::grpc::ServerContext* context, const ::resource::GetLogRqst* request, ::grpc::ServerWriter< ::resource::GetLogRsp>* writer);
    // * Delete a single log entry *
    virtual ::grpc::Status DeleteLog(::grpc::ServerContext* context, const ::resource::DeleteLogRqst* request, ::resource::DeleteLogRsp* response);
    // * Delete all log *
    virtual ::grpc::Status ClearAllLog(::grpc::ServerContext* context, const ::resource::ClearAllLogRqst* request, ::resource::ClearAllLogRsp* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_Log : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Log() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_Log() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Log(::grpc::ServerContext* /*context*/, const ::resource::LogRqst* /*request*/, ::resource::LogRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLog(::grpc::ServerContext* context, ::resource::LogRqst* request, ::grpc::ServerAsyncResponseWriter< ::resource::LogRsp>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetLog : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetLog() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_GetLog() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetLog(::grpc::ServerContext* /*context*/, const ::resource::GetLogRqst* /*request*/, ::grpc::ServerWriter< ::resource::GetLogRsp>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetLog(::grpc::ServerContext* context, ::resource::GetLogRqst* request, ::grpc::ServerAsyncWriter< ::resource::GetLogRsp>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(1, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DeleteLog : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_DeleteLog() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_DeleteLog() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteLog(::grpc::ServerContext* /*context*/, const ::resource::DeleteLogRqst* /*request*/, ::resource::DeleteLogRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteLog(::grpc::ServerContext* context, ::resource::DeleteLogRqst* request, ::grpc::ServerAsyncResponseWriter< ::resource::DeleteLogRsp>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ClearAllLog : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ClearAllLog() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_ClearAllLog() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ClearAllLog(::grpc::ServerContext* /*context*/, const ::resource::ClearAllLogRqst* /*request*/, ::resource::ClearAllLogRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestClearAllLog(::grpc::ServerContext* context, ::resource::ClearAllLogRqst* request, ::grpc::ServerAsyncResponseWriter< ::resource::ClearAllLogRsp>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_Log<WithAsyncMethod_GetLog<WithAsyncMethod_DeleteLog<WithAsyncMethod_ClearAllLog<Service > > > > AsyncService;
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_Log : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_Log() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::resource::LogRqst, ::resource::LogRsp>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::resource::LogRqst* request, ::resource::LogRsp* response) { return this->Log(context, request, response); }));}
    void SetMessageAllocatorFor_Log(
        ::grpc::experimental::MessageAllocator< ::resource::LogRqst, ::resource::LogRsp>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(0);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::resource::LogRqst, ::resource::LogRsp>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_Log() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Log(::grpc::ServerContext* /*context*/, const ::resource::LogRqst* /*request*/, ::resource::LogRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Log(
      ::grpc::CallbackServerContext* /*context*/, const ::resource::LogRqst* /*request*/, ::resource::LogRsp* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Log(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::resource::LogRqst* /*request*/, ::resource::LogRsp* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetLog : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetLog() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(1,
          new ::grpc::internal::CallbackServerStreamingHandler< ::resource::GetLogRqst, ::resource::GetLogRsp>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::resource::GetLogRqst* request) { return this->GetLog(context, request); }));
    }
    ~ExperimentalWithCallbackMethod_GetLog() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetLog(::grpc::ServerContext* /*context*/, const ::resource::GetLogRqst* /*request*/, ::grpc::ServerWriter< ::resource::GetLogRsp>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::resource::GetLogRsp>* GetLog(
      ::grpc::CallbackServerContext* /*context*/, const ::resource::GetLogRqst* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::resource::GetLogRsp>* GetLog(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::resource::GetLogRqst* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_DeleteLog : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_DeleteLog() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::resource::DeleteLogRqst, ::resource::DeleteLogRsp>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::resource::DeleteLogRqst* request, ::resource::DeleteLogRsp* response) { return this->DeleteLog(context, request, response); }));}
    void SetMessageAllocatorFor_DeleteLog(
        ::grpc::experimental::MessageAllocator< ::resource::DeleteLogRqst, ::resource::DeleteLogRsp>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(2);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::resource::DeleteLogRqst, ::resource::DeleteLogRsp>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_DeleteLog() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteLog(::grpc::ServerContext* /*context*/, const ::resource::DeleteLogRqst* /*request*/, ::resource::DeleteLogRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DeleteLog(
      ::grpc::CallbackServerContext* /*context*/, const ::resource::DeleteLogRqst* /*request*/, ::resource::DeleteLogRsp* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DeleteLog(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::resource::DeleteLogRqst* /*request*/, ::resource::DeleteLogRsp* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ClearAllLog : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ClearAllLog() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::resource::ClearAllLogRqst, ::resource::ClearAllLogRsp>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::resource::ClearAllLogRqst* request, ::resource::ClearAllLogRsp* response) { return this->ClearAllLog(context, request, response); }));}
    void SetMessageAllocatorFor_ClearAllLog(
        ::grpc::experimental::MessageAllocator< ::resource::ClearAllLogRqst, ::resource::ClearAllLogRsp>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(3);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::resource::ClearAllLogRqst, ::resource::ClearAllLogRsp>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ClearAllLog() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ClearAllLog(::grpc::ServerContext* /*context*/, const ::resource::ClearAllLogRqst* /*request*/, ::resource::ClearAllLogRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ClearAllLog(
      ::grpc::CallbackServerContext* /*context*/, const ::resource::ClearAllLogRqst* /*request*/, ::resource::ClearAllLogRsp* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ClearAllLog(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::resource::ClearAllLogRqst* /*request*/, ::resource::ClearAllLogRsp* /*response*/)
    #endif
      { return nullptr; }
  };
  #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
  typedef ExperimentalWithCallbackMethod_Log<ExperimentalWithCallbackMethod_GetLog<ExperimentalWithCallbackMethod_DeleteLog<ExperimentalWithCallbackMethod_ClearAllLog<Service > > > > CallbackService;
  #endif

  typedef ExperimentalWithCallbackMethod_Log<ExperimentalWithCallbackMethod_GetLog<ExperimentalWithCallbackMethod_DeleteLog<ExperimentalWithCallbackMethod_ClearAllLog<Service > > > > ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_Log : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Log() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_Log() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Log(::grpc::ServerContext* /*context*/, const ::resource::LogRqst* /*request*/, ::resource::LogRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetLog : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetLog() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_GetLog() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetLog(::grpc::ServerContext* /*context*/, const ::resource::GetLogRqst* /*request*/, ::grpc::ServerWriter< ::resource::GetLogRsp>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DeleteLog : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_DeleteLog() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_DeleteLog() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteLog(::grpc::ServerContext* /*context*/, const ::resource::DeleteLogRqst* /*request*/, ::resource::DeleteLogRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ClearAllLog : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ClearAllLog() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_ClearAllLog() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ClearAllLog(::grpc::ServerContext* /*context*/, const ::resource::ClearAllLogRqst* /*request*/, ::resource::ClearAllLogRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_Log : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Log() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_Log() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Log(::grpc::ServerContext* /*context*/, const ::resource::LogRqst* /*request*/, ::resource::LogRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLog(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetLog : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetLog() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_GetLog() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetLog(::grpc::ServerContext* /*context*/, const ::resource::GetLogRqst* /*request*/, ::grpc::ServerWriter< ::resource::GetLogRsp>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetLog(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(1, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DeleteLog : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_DeleteLog() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_DeleteLog() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteLog(::grpc::ServerContext* /*context*/, const ::resource::DeleteLogRqst* /*request*/, ::resource::DeleteLogRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteLog(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ClearAllLog : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ClearAllLog() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_ClearAllLog() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ClearAllLog(::grpc::ServerContext* /*context*/, const ::resource::ClearAllLogRqst* /*request*/, ::resource::ClearAllLogRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestClearAllLog(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_Log : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_Log() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Log(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_Log() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Log(::grpc::ServerContext* /*context*/, const ::resource::LogRqst* /*request*/, ::resource::LogRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Log(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Log(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetLog : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetLog() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const::grpc::ByteBuffer* request) { return this->GetLog(context, request); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetLog() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetLog(::grpc::ServerContext* /*context*/, const ::resource::GetLogRqst* /*request*/, ::grpc::ServerWriter< ::resource::GetLogRsp>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* GetLog(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::grpc::ByteBuffer>* GetLog(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_DeleteLog : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_DeleteLog() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->DeleteLog(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_DeleteLog() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteLog(::grpc::ServerContext* /*context*/, const ::resource::DeleteLogRqst* /*request*/, ::resource::DeleteLogRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DeleteLog(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DeleteLog(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ClearAllLog : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ClearAllLog() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ClearAllLog(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ClearAllLog() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ClearAllLog(::grpc::ServerContext* /*context*/, const ::resource::ClearAllLogRqst* /*request*/, ::resource::ClearAllLogRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ClearAllLog(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ClearAllLog(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Log : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Log() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::resource::LogRqst, ::resource::LogRsp>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::resource::LogRqst, ::resource::LogRsp>* streamer) {
                       return this->StreamedLog(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Log() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Log(::grpc::ServerContext* /*context*/, const ::resource::LogRqst* /*request*/, ::resource::LogRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedLog(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::resource::LogRqst,::resource::LogRsp>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DeleteLog : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_DeleteLog() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::resource::DeleteLogRqst, ::resource::DeleteLogRsp>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::resource::DeleteLogRqst, ::resource::DeleteLogRsp>* streamer) {
                       return this->StreamedDeleteLog(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_DeleteLog() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DeleteLog(::grpc::ServerContext* /*context*/, const ::resource::DeleteLogRqst* /*request*/, ::resource::DeleteLogRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDeleteLog(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::resource::DeleteLogRqst,::resource::DeleteLogRsp>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ClearAllLog : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ClearAllLog() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::resource::ClearAllLogRqst, ::resource::ClearAllLogRsp>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::resource::ClearAllLogRqst, ::resource::ClearAllLogRsp>* streamer) {
                       return this->StreamedClearAllLog(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ClearAllLog() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ClearAllLog(::grpc::ServerContext* /*context*/, const ::resource::ClearAllLogRqst* /*request*/, ::resource::ClearAllLogRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedClearAllLog(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::resource::ClearAllLogRqst,::resource::ClearAllLogRsp>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_Log<WithStreamedUnaryMethod_DeleteLog<WithStreamedUnaryMethod_ClearAllLog<Service > > > StreamedUnaryService;
  template <class BaseClass>
  class WithSplitStreamingMethod_GetLog : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_GetLog() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::resource::GetLogRqst, ::resource::GetLogRsp>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::resource::GetLogRqst, ::resource::GetLogRsp>* streamer) {
                       return this->StreamedGetLog(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_GetLog() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetLog(::grpc::ServerContext* /*context*/, const ::resource::GetLogRqst* /*request*/, ::grpc::ServerWriter< ::resource::GetLogRsp>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedGetLog(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::resource::GetLogRqst,::resource::GetLogRsp>* server_split_streamer) = 0;
  };
  typedef WithSplitStreamingMethod_GetLog<Service > SplitStreamedService;
  typedef WithStreamedUnaryMethod_Log<WithSplitStreamingMethod_GetLog<WithStreamedUnaryMethod_DeleteLog<WithStreamedUnaryMethod_ClearAllLog<Service > > > > StreamedService;
};

}  // namespace resource


#endif  // GRPC_resource_2eproto__INCLUDED
